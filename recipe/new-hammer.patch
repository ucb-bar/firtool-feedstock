diff --git a/docs/Dialects/FIRRTL/FIRRTLAnnotations.md b/docs/Dialects/FIRRTL/FIRRTLAnnotations.md
index 34a3ae07f..fecb0c4fb 100644
--- a/docs/Dialects/FIRRTL/FIRRTLAnnotations.md
+++ b/docs/Dialects/FIRRTL/FIRRTLAnnotations.md
@@ -173,7 +173,7 @@ operation or port attributes.  As an example of this, the above parses into the
 following MLIR representation:
 
 ```mlir
-firrtl.circuit "Foo"  {
+firrtl.circuit "Foo" {
   firrtl.module @Foo() attributes {annotations = [{hello = "world"}]} {
     firrtl.skip
   }
diff --git a/docs/Dialects/FIRRTL/RationaleFIRRTL.md b/docs/Dialects/FIRRTL/RationaleFIRRTL.md
index b97d400c9..e2192fb26 100644
--- a/docs/Dialects/FIRRTL/RationaleFIRRTL.md
+++ b/docs/Dialects/FIRRTL/RationaleFIRRTL.md
@@ -390,7 +390,7 @@ followed by instance `@baz` in module `@Bar`, followed by the wire named `@w` in
 module `@Baz`.
 
 ``` mlir
-firrtl.circuit "Foo"   {
+firrtl.circuit "Foo" {
   firrtl.hierpath @nla [@Foo::@bar, @Bar::@baz, @Baz::@w]
   firrtl.module @Baz() {
     %w = firrtl.wire sym @w {annotations = [{circt.nonlocal = @nla, class = "ExampleAnno"}]} : !firrtl.uint
diff --git a/docs/PythonBindings.md b/docs/PythonBindings.md
index d88faee85..4a41c6b0e 100644
--- a/docs/PythonBindings.md
+++ b/docs/PythonBindings.md
@@ -83,8 +83,7 @@ Now you are able to use the CIRCT dialects and infrastructure from a Python inte
 ```python
 # silicon.py
 import circt
-import mlir
-from mlir.ir import *
+from circt.ir import Context, InsertionPoint, IntegerType, Location, Module
 from circt.dialects import hw, comb
 
 with Context() as ctx, Location.unknown():
@@ -92,17 +91,23 @@ with Context() as ctx, Location.unknown():
   i42 = IntegerType.get_signless(42)
   m = Module.create()
   with InsertionPoint(m.body):
-    def magic(a, b):
-      return comb.XorOp(i42, [a, b]).result
-    hw.HWModuleOp(name="magic", body_builder=magic)
+
+    def magic(module):
+      xor = comb.XorOp.create(module.a, module.b)
+      return {"c": xor}
+
+    hw.HWModuleOp(name="magic",
+                  input_ports=[("a", i42), ("b", i42)],
+                  output_ports=[("c", i42)],
+                  body_builder=magic)
   print(m)
 ```
 
 Running this script through `python3 silicon.py` should print the following MLIR:
 
 ```mlir
-module  {
-  hw.module @magic(%a: i42, %b: i42) -> (%result0: i42) {
+module {
+  hw.module @magic(%a: i42, %b: i42) -> (c: i42) {
     %0 = comb.xor %a, %b : i42
     hw.output %0 : i42
   }
diff --git a/frontends/PyCDE/src/CMakeLists.txt b/frontends/PyCDE/src/CMakeLists.txt
index 306eebcac..89b7fd697 100644
--- a/frontends/PyCDE/src/CMakeLists.txt
+++ b/frontends/PyCDE/src/CMakeLists.txt
@@ -32,7 +32,7 @@ declare_mlir_python_sources(PyCDESources
   system.py
   devicedb.py
   instance.py
-  value.py
+  signals.py
   ndarray.py
   esi.py
   esi_api.py
@@ -42,6 +42,15 @@ declare_mlir_python_sources(PyCDESources
 
   esi_api.py.j2
   Makefile.cosim
+
+  bsp/__init__.py
+  bsp/xrt.py
+  bsp/EsiXrtPython.cpp
+  bsp/Makefile.xrt.j2
+  bsp/xrt_package.tcl.j2
+  bsp/xrt_api.py
+  bsp/xrt.ini
+  bsp/xsim.tcl
 )
 
 ################################################################################
diff --git a/frontends/PyCDE/src/__init__.py b/frontends/PyCDE/src/__init__.py
index 0262ecf1f..1f8af4074 100644
--- a/frontends/PyCDE/src/__init__.py
+++ b/frontends/PyCDE/src/__init__.py
@@ -22,7 +22,7 @@ from .common import (AppID, Clock, Input, InputChannel, Output, OutputChannel)
 from .module import (generator, modparams, Module)
 from .system import (System)
 from .types import (dim, types)
-from .value import (Value)
+from .signals import (Signal)
 
 # Until we get source location based on Python stack traces, default to unknown
 # locations.
diff --git a/frontends/PyCDE/src/behavioral.py b/frontends/PyCDE/src/behavioral.py
index e07330a4b..a14e73ea7 100644
--- a/frontends/PyCDE/src/behavioral.py
+++ b/frontends/PyCDE/src/behavioral.py
@@ -4,8 +4,8 @@
 
 from __future__ import annotations
 
-from .value import BitVectorSignal, Signal, Value
 from .dialects import comb
+from .signals import BitVectorSignal, Signal
 
 import ctypes
 from contextvars import ContextVar
@@ -49,7 +49,7 @@ class If:
     if (cond.type.width != 1):
       raise TypeError("'Cond' bit width must be 1")
     self._cond = cond
-    self._muxes: Dict[str, Tuple[Value, Value]] = {}
+    self._muxes: Dict[str, Tuple[Signal, Signal]] = {}
 
   @staticmethod
   def current() -> Optional[If]:
@@ -71,7 +71,7 @@ class If:
     _current_if_stmt.reset(self._old_system_token)
 
     # Create the set of muxes from the 'then' and/or 'else' blocks.
-    new_locals: Dict[str, Value] = {}
+    new_locals: Dict[str, Signal] = {}
     for (varname, (else_value, then_value)) in self._muxes.items():
       # New values need to have a value assigned from both the 'then' and 'else'.
       if then_value is None or else_value is None:
@@ -112,7 +112,7 @@ class _IfBlock:
     if_stmt = If.current()
     s = inspect.stack()[stack_level][0]
     lcls_to_del = set()
-    new_lcls: Dict[str, Value] = {}
+    new_lcls: Dict[str, Signal] = {}
     for (varname, value) in s.f_locals.items():
       # Only operate on Values.
       if not isinstance(value, Signal):
diff --git a/frontends/PyCDE/src/bsp/EsiXrtPython.cpp b/frontends/PyCDE/src/bsp/EsiXrtPython.cpp
new file mode 100644
index 000000000..4873f5c2b
--- /dev/null
+++ b/frontends/PyCDE/src/bsp/EsiXrtPython.cpp
@@ -0,0 +1,37 @@
+#include <cstring>
+#include <iostream>
+#include <unistd.h>
+#include <vector>
+
+// pybind11 includes
+#include "pybind11/pybind11.h"
+#include "pybind11/stl.h"
+namespace py = pybind11;
+
+// XRT includes
+#include "experimental/xrt_bo.h"
+#include "experimental/xrt_device.h"
+#include "experimental/xrt_ip.h"
+#include "experimental/xrt_xclbin.h"
+
+// We don't want to clutter up the symbol space any more than necessary, so use
+// an anonymous namespace.
+namespace {
+class Accelerator {
+  xrt::device m_device;
+  xrt::ip m_ip;
+
+public:
+  Accelerator(const std::string &xclbin_path, const std::string kernel_name) {
+    m_device = xrt::device(0);
+    auto uuid = m_device.load_xclbin(xclbin_path);
+    m_ip = xrt::ip(m_device, uuid, kernel_name);
+  }
+};
+
+} // namespace
+
+PYBIND11_MODULE(esiXrtPython, m) {
+  py::class_<Accelerator>(m, "Accelerator")
+      .def(py::init<const std::string &, const std::string &>());
+}
diff --git a/frontends/PyCDE/src/bsp/Makefile.xrt.j2 b/frontends/PyCDE/src/bsp/Makefile.xrt.j2
new file mode 100644
index 000000000..cfca9e598
--- /dev/null
+++ b/frontends/PyCDE/src/bsp/Makefile.xrt.j2
@@ -0,0 +1,160 @@
+# Please source Vitis and XRT before running this makefile
+# $ source /opt/xilinx/Vitis/2022.1/settings64.sh
+# $ source /opt/xilinx/xrt/setup.sh
+
+PYTHON ?= python3
+CXX ?= g++
+VIVADO := $(XILINX_VIVADO)/bin/vivado
+VPP := $(XILINX_VITIS)/bin/v++
+
+# Specify 'hw_emu' for hardware emulation support instead of a bitfile
+# Note, the Azure shell verison is not officially supported in hw_emu mode
+TARGET := hw_emu
+
+NAME := {{system_name}}
+SRC := hw
+BUILD := build_$(TARGET)
+TEMP := $(BUILD)/temp
+
+# Toggle to automatically set custom options for running in Azure NP-series VMs
+AZURE := true
+
+XO_OUT := $(TEMP)/kernel.xo
+LINK_OUT := $(BUILD)/$(NAME).link.xclbin
+XCL_OUT := $(NAME).$(TARGET).xclbin
+HOST_APP := $(BUILD)/host_app
+
+VPPFLAGS = --save-temps
+
+# Used for compiling C++ apps for XRT
+CXXFLAGS = -I$(XILINX_XRT)/include -I$(XILINX_VIVADO)/include -Wall -g -O0 -std=c++2a -fmessage-length=0
+LDFLAGS = -L$(XILINX_XRT)/lib -pthread -lxrt_coreutil
+
+# Platform must match the device + shell you're using
+# For Azure NP-series, use the official Azure Shell
+# For a local card or hw_emu mode, use the latest U250 XDMA Shell
+
+ifeq ($(AZURE), true)
+PLATFORM := xilinx_u250_gen3x16_xdma_2_1_202010_1
+# For Azure NP-series, output the routed netlist as a DCP instead of a bitsream!
+VPPFLAGS += --advanced.param compiler.acceleratorBinaryContent=dcp
+else
+PLATFORM := xilinx_u250_gen3x16_xdma_4_1_202210_1
+endif
+
+VPPFLAGS += -t $(TARGET) --platform $(PLATFORM)
+PACKAGE := $(BUILD)/package
+
+ifneq ($(TARGET), hw)
+VPPFLAGS += -g
+endif
+
+device2xsa = $(strip $(patsubst %.xpfm, % , $(shell basename $(PLATFORM))))
+XSA := $(call device2xsa, $(PLATFORM))
+
+.PHONY: clean emconfig exec
+.INTERMEDIATE: azure_creds
+
+all: esiXrtPython $(XCL_OUT) emconfig
+
+$(BUILD):
+	mkdir -p $(BUILD)
+
+$(TEMP):
+	mkdir -p $(TEMP)
+
+# Package everything into a Vitis compatible kernel (.xo format)
+$(XO_OUT): $(TEMP)
+	$(VIVADO) -mode batch -source $(SRC)/xrt_package.tcl -tclargs $(SRC) $(XO_OUT) $(TARGET) $(PLATFORM) $(XSA)
+
+# Link Vitis system using the generated kernel for the chosen platform
+$(LINK_OUT): $(XO_OUT) | $(BUILD)
+	$(VPP) $(VPPFLAGS) -l --temp_dir $(TEMP) -o'$(LINK_OUT)' $(+)
+
+# Build the xclbin
+$(XCL_OUT): $(LINK_OUT)
+	$(VPP) -p $(LINK_OUT) $(VPPFLAGS) --package.out_dir $(PACKAGE) -o $(XCL_OUT)
+
+# Generate configuration for use with hw_emu mode
+emconfig: $(BUILD)/emconfig.json
+$(BUILD)/emconfig.json:
+	emconfigutil --platform $(PLATFORM) --od $(BUILD)
+
+# Compile the Python interface driver.
+# TODO: build for a list of python versions.
+PY_EXT := $(shell $(PYTHON)-config --extension-suffix)
+PYBIND11_INC := $(shell $(PYTHON) -m pybind11 --includes)
+runtime/$(NAME)/esiXrtPython$(PY_EXT): runtime/$(NAME)/EsiXrtPython.cpp
+	$(CXX) -o runtime/$(NAME)/esiXrtPython$(PY_EXT) $^ $(CXXFLAGS) $(LDFLAGS) -shared -fPIC $(PYBIND11_INC)
+esiXrtPython: runtime/$(NAME)/esiXrtPython$(PY_EXT)
+
+clean:
+	rm -rf $(BUILD) .Xil vivado* kernel *.jou *.log *.wdb *.wcfg *.protoinst *.csv
+	rm runtime/*.so
+
+# Targets which only apply to image builds.
+ifeq ($(TARGET), hw)
+
+# Submit the image to Azure for attestation. Follows the instructions at:
+# https://learn.microsoft.com/en-us/azure/virtual-machines/field-programmable-gate-arrays-attestation
+IMAGE_AZ_BASENAME ?= $(NAME)_$(shell date +%s).hw
+IMAGE_AZ_NAME := $(USER)_$(IMAGE_AZ_BASENAME)
+azure: $(IMAGE_AZ_NAME).azure.xclbin
+azure_creds:
+	@echo "*************************"
+	@echo "* Getting Azure credentials. MUST 'az login' first!"
+	@echo "*************************"
+	@ if [ "${AZ_FPGA_SUB}" = "" ] || [ "${AZ_FPGA_STORAGE_ACCOUNT}" = "" ] || \
+	     [ "${AZ_FPGA_STORAGE_CONTAINER}" = "" ]; then \
+		@echo "** AZ_FPGA_SUB, AZ_FPGA_STORAGE_ACCOUNT, and AZ_FPGA_STORAGE_CONTAINER" \
+		exit 1; \
+	fi
+
+	$(eval SAS_EXPIRY=$(shell date --date "now + 48hours" +"%Y-%m-%dT%0k:%MZ"))
+	$(eval SAS=$(shell \
+		az storage container generate-sas \
+			--subscription $(AZ_FPGA_SUB) \
+			--account-name $(AZ_FPGA_STORAGE_ACCOUNT) \
+			--name $(AZ_FPGA_STORAGE_CONTAINER) \
+			--https-only --permissions rwc --auth-mode key \
+			--expiry $(SAS_EXPIRY) --output tsv))
+
+$(IMAGE_AZ_NAME).azure.xclbin: azure_creds $(XCL_OUT) validate-fpgaimage.sh
+	@echo "*************************"
+	@echo "* Submitting job to Azure attestation."
+	@echo "* This step WILL take a LONG time (between 30 mins and 1.5 hours)."
+	@echo "*   Using name $(IMAGE_AZ_NAME)"
+	@echo "*************************"
+
+	az storage blob upload \
+		--subscription $(AZ_FPGA_SUB) \
+		--account-name $(AZ_FPGA_STORAGE_ACCOUNT) \
+		--container-name $(AZ_FPGA_STORAGE_CONTAINER) \
+	  --sas-token "$(SAS)" --overwrite \
+		--name $(IMAGE_AZ_NAME).xclbin --file $(NAME).hw.xclbin
+
+	bash validate-fpgaimage.sh --storage-account $(AZ_FPGA_STORAGE_ACCOUNT) \
+														 --container $(AZ_FPGA_STORAGE_CONTAINER) \
+														 --netlist-name $(IMAGE_AZ_NAME) \
+														 --blob-container-sas "$(SAS)"
+
+	az storage blob download \
+		--subscription $(AZ_FPGA_SUB) \
+		--account-name $(AZ_FPGA_STORAGE_ACCOUNT) \
+		--container-name $(AZ_FPGA_STORAGE_CONTAINER) \
+		--sas-token "$(SAS)" \
+		--name $(IMAGE_AZ_NAME).azure.xclbin --file $(IMAGE_AZ_NAME).azure.xclbin
+
+validate-fpgaimage.sh:
+	wget -O azure_validate.zip \
+		https://fpgaattestation.blob.core.windows.net/validationscripts/validate.zip
+	unzip azure_validate.zip
+
+azpackage: $(NAME)_azpackage.tar.gz
+$(NAME)_azpackage.tar.gz: $(IMAGE_AZ_NAME).azure.xclbin
+	mkdir -p package
+	cp -r runtime/* package
+	cp $(IMAGE_AZ_NAME).azure.xclbin package/$(NAME)/$(NAME).hw.azure.xclbin
+	cd package && tar -zcf ../$(NAME)_azpackage.tar.gz *
+	cd ..
+endif
diff --git a/frontends/PyCDE/src/bsp/__init__.py b/frontends/PyCDE/src/bsp/__init__.py
new file mode 100644
index 000000000..f5155b5c1
--- /dev/null
+++ b/frontends/PyCDE/src/bsp/__init__.py
@@ -0,0 +1,5 @@
+#  Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+#  See https://llvm.org/LICENSE.txt for license information.
+#  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+
+from .xrt import XrtBSP
diff --git a/frontends/PyCDE/src/bsp/xrt.ini b/frontends/PyCDE/src/bsp/xrt.ini
new file mode 100644
index 000000000..8edd9c0c6
--- /dev/null
+++ b/frontends/PyCDE/src/bsp/xrt.ini
@@ -0,0 +1,8 @@
+[Debug]
+native_xrt_trace=true
+device_trace=fine
+xocl_debug=true
+
+[Emulation]
+debug_mode=batch
+user_pre_sim_script=xsim.tcl
diff --git a/frontends/PyCDE/src/bsp/xrt.py b/frontends/PyCDE/src/bsp/xrt.py
new file mode 100644
index 000000000..9c35647f5
--- /dev/null
+++ b/frontends/PyCDE/src/bsp/xrt.py
@@ -0,0 +1,120 @@
+#  Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+#  See https://llvm.org/LICENSE.txt for license information.
+#  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+
+from pycde import Clock, Input, Output, System
+from pycde import Module, generator, types
+
+import glob
+import pathlib
+import shutil
+
+__dir__ = pathlib.Path(__file__).parent
+
+# Parameters for AXI4-Lite interface
+axil_addr_width = 24
+axil_data_width = 32
+
+
+def XrtBSP(user_module):
+  """Use the Xilinx RunTime (XRT) shell to implement ESI services and build an
+  image or emulation package.
+
+  How to use this BSP:
+  - Wrap your top PyCDE module in `XrtBSP`.
+  - Run your script. This BSP will write a 'build package' to the output dir.
+  This package contains a Makefile.xrt which (given a proper Vitis dev
+  environment) will compile a hw image or hw_emu image. It is a free-standing
+  build package -- you do not need PyCDE installed on the same machine as you
+  want to do the image build.
+  - To build the `hw` image, run 'make -f Makefile.xrt TARGET=hw'. If you want
+  an image which runs on an Azure NP-series instance, run the 'azure' target
+  (requires an Azure subscription set up with as per
+  https://learn.microsoft.com/en-us/azure/virtual-machines/field-programmable-gate-arrays-attestation).
+  This target requires a few environment variables to be set (which the Makefile
+  will tell you about).
+  - To build a hw emulation image, run with TARGET=hw_emu.
+  - The makefile also builds a Python plugin. To specify the python version to
+  build against (if different from the version ran by 'python3' in your
+  environment), set the PYTHON variable (e.g. 'PYTHON=python3.9').
+  """
+
+  class top(Module):
+    ap_clk = Clock()
+    ap_resetn = Input(types.i1)
+
+    # AXI4-Lite slave interface
+    s_axi_control_AWVALID = Input(types.i1)
+    s_axi_control_AWREADY = Output(types.i1)
+    s_axi_control_AWADDR = Input(types.int(32))
+    s_axi_control_WVALID = Input(types.i1)
+    s_axi_control_WREADY = Output(types.i1)
+    s_axi_control_WDATA = Input(types.int(axil_data_width))
+    s_axi_control_WSTRB = Input(types.int(axil_data_width // 8))
+    s_axi_control_ARVALID = Input(types.i1)
+    s_axi_control_ARREADY = Output(types.i1)
+    s_axi_control_ARADDR = Input(types.int(axil_addr_width))
+    s_axi_control_RVALID = Output(types.i1)
+    s_axi_control_RREADY = Input(types.i1)
+    s_axi_control_RDATA = Output(types.int(axil_data_width))
+    s_axi_control_RRESP = Output(types.i2)
+    s_axi_control_BVALID = Output(types.i1)
+    s_axi_control_BREADY = Input(types.i1)
+    s_axi_control_BRESP = Output(types.i2)
+
+    @generator
+    def construct(ports):
+
+      rst = ~ports.ap_resetn
+
+      # Splice in the user's code
+      # NOTE: the clock is `ports.ap_clk`
+      #       and reset is `ports.ap_resetn` which is active low
+      user_module(clk=ports.ap_clk, rst=rst)
+
+      # Copy additional sources
+      sys: System = System.current()
+      sys.add_packaging_step(top.package)
+
+      # Tie off outputs.
+      ports.s_axi_control_AWREADY = 0
+      ports.s_axi_control_WREADY = 0
+      ports.s_axi_control_ARREADY = 0
+      ports.s_axi_control_RVALID = 0
+      ports.s_axi_control_RDATA = 0
+      ports.s_axi_control_RRESP = 0
+      ports.s_axi_control_BVALID = 0
+      ports.s_axi_control_BRESP = 0
+
+    @staticmethod
+    def package(sys: System):
+      """Assemble a 'build' package which includes all the necessary build
+      collateral (about which we are aware), build/debug scripts, and the
+      generated runtime."""
+
+      from jinja2 import Environment, FileSystemLoader, StrictUndefined
+
+      sv_sources = glob.glob(str(__dir__ / '*.sv'))
+      tcl_sources = glob.glob(str(__dir__ / '*.tcl'))
+      for source in sv_sources + tcl_sources:
+        shutil.copy(source, sys.hw_output_dir)
+
+      env = Environment(loader=FileSystemLoader(str(__dir__)),
+                        undefined=StrictUndefined)
+      makefile_template = env.get_template("Makefile.xrt.j2")
+      dst_makefile = sys.output_directory / "Makefile.xrt"
+      dst_makefile.open("w").write(
+          makefile_template.render(system_name=sys.name))
+      tcl_template = env.get_template("xrt_package.tcl.j2")
+      dst_tcl = sys.hw_output_dir / "xrt_package.tcl"
+      dst_tcl.open("w").write(tcl_template.render(system_name=sys.name))
+
+      shutil.copy(__dir__ / "xrt.ini", sys.output_directory / "xrt.ini")
+      shutil.copy(__dir__ / "xsim.tcl", sys.output_directory / "xsim.tcl")
+
+      runtime_dir = sys.output_directory / "runtime" / sys.name
+      shutil.copy(__dir__ / "xrt_api.py", runtime_dir / "xrt.py")
+      shutil.copy(__dir__ / "EsiXrtPython.cpp",
+                  sys.sys_runtime_output_dir / "EsiXrtPython.cpp")
+
+  return top
diff --git a/frontends/PyCDE/src/bsp/xrt_api.py b/frontends/PyCDE/src/bsp/xrt_api.py
new file mode 100644
index 000000000..0176b17a3
--- /dev/null
+++ b/frontends/PyCDE/src/bsp/xrt_api.py
@@ -0,0 +1,48 @@
+import json
+import os
+from pathlib import Path
+import typing
+
+__dir__ = Path(__file__).parent
+
+
+class _XrtNode:
+
+  def __init__(self, root, prefix: typing.List[str]):
+    self._root: Xrt = root
+    self._endpoint_prefix = prefix
+
+  def supports_impl(self, impl_type: str) -> bool:
+    return False
+
+  def get_child(self, child_name: str):
+    """When instantiating a child instance, get the backend node with which it
+    is associated."""
+    child_path = self._endpoint_prefix + [child_name]
+    return _XrtNode(self._root, child_path)
+
+
+class Xrt(_XrtNode):
+
+  def __init__(self,
+               xclbin: os.PathLike = None,
+               kernel: str = None,
+               chan_desc_path: os.PathLike = None,
+               hw_emu: bool = False) -> None:
+    if xclbin is None:
+      xclbin_files = list(__dir__.glob("*.xclbin"))
+      if len(xclbin_files) == 0:
+        raise RuntimeError("Could not find FPGA image.")
+      if len(xclbin_files) > 1:
+        raise RuntimeError("Found multiple FPGA images.")
+      xclbin = __dir__ / xclbin_files[0]
+    if kernel is None:
+      xclbin_fn = os.path.basename(xclbin)
+      kernel = xclbin_fn.split('.')[0]
+    super().__init__(self, [])
+
+    if hw_emu:
+      os.environ["XCL_EMULATION_MODE"] = "hw_emu"
+
+    from .esiXrtPython import Accelerator
+    self._acc = Accelerator(os.path.abspath(str(xclbin)), kernel)
diff --git a/frontends/PyCDE/src/bsp/xrt_package.tcl.j2 b/frontends/PyCDE/src/bsp/xrt_package.tcl.j2
new file mode 100644
index 000000000..269d9e2d2
--- /dev/null
+++ b/frontends/PyCDE/src/bsp/xrt_package.tcl.j2
@@ -0,0 +1,72 @@
+# Built from Xilinx provided files
+
+if { $::argc != 5 } {
+    puts "ERROR: Program \"$::argv0\" requires 5 arguments!\n"
+    puts "Usage: $::argv0 <src_dir> <xoname> <target> <xpfm_path> <device>\n"
+    exit 1
+}
+
+set srcs      [lindex $::argv 0]
+set xoname    [lindex $::argv 1]
+set target    [lindex $::argv 2]
+set xpfm_path [lindex $::argv 3]
+set device    [lindex $::argv 4]
+
+set krnl_name {{system_name}}
+set suffix "${krnl_name}_${target}_${device}"
+
+set project_path "./temp_kernel"
+set package_path "./kernel"
+
+# Create a temporary project that groups the kernel RTL together
+create_project -force kernel $project_path
+
+# Collect all the necessary SystemVerilog files
+add_files -norecurse [glob $srcs/*.sv]
+
+# Use the correct top level module
+set_property top top [current_fileset]
+
+update_compile_order -fileset sources_1
+update_compile_order -fileset sim_1
+
+# Package the temporary project
+ipx::package_project -root_dir $package_path -vendor circt.llvm.org -library {{system_name}} -taxonomy /KernelIP -import_files -set_current false
+
+# Load a new project to edit the packaged kernel IP
+ipx::unload_core $package_path/component.xml
+ipx::edit_ip_in_project -upgrade true -name tmp_prj -directory $package_path $package_path/component.xml
+
+set core [ipx::current_core]
+
+# Associate AXI-Lite control interfaces
+ipx::associate_bus_interfaces -busif s_axi_control -clock ap_clk $core
+
+# Create the address space for CSRs
+set mem_map     [::ipx::add_memory_map -quiet "s_axi_control" $core]
+set addr_block  [::ipx::add_address_block -quiet "reg0" $mem_map]
+
+set reg      [::ipx::add_register "required_for_vitis" $addr_block]
+  # Required so we don't get the error "ERROR: [Common 17-69] Command failed: No kernel args have been found from IP"
+  set_property description    "Vitis requires a register here." $reg
+  set_property address_offset 16 $reg
+  set_property size           8 $reg
+
+set_property slave_memory_map_ref "s_axi_control" [::ipx::get_bus_interfaces -of $core "s_axi_control"]
+
+set_property xpm_libraries {XPM_CDC XPM_FIFO} $core
+set_property sdx_kernel true $core
+set_property sdx_kernel_type rtl $core
+set_property supported_families { } $core
+set_property auto_family_support_level level_2 $core
+ipx::create_xgui_files $core
+ipx::update_checksums $core
+ipx::check_integrity -kernel $core
+ipx::save_core $core
+close_project -delete
+
+if {[file exists "${xoname}"]} {
+    file delete -force "${xoname}"
+}
+
+package_xo -ctrl_protocol user_managed -xo_path ${xoname} -kernel_name ${krnl_name} -ip_directory ${package_path}
diff --git a/frontends/PyCDE/src/bsp/xsim.tcl b/frontends/PyCDE/src/bsp/xsim.tcl
new file mode 100644
index 000000000..8376011d4
--- /dev/null
+++ b/frontends/PyCDE/src/bsp/xsim.tcl
@@ -0,0 +1,3 @@
+log_wave -r /
+run all
+exit
diff --git a/frontends/PyCDE/src/common.py b/frontends/PyCDE/src/common.py
index ff2da1adb..f195a678f 100644
--- a/frontends/PyCDE/src/common.py
+++ b/frontends/PyCDE/src/common.py
@@ -4,7 +4,7 @@
 
 from __future__ import annotations
 
-from .circt.dialects import esi as raw_esi, msft
+from .circt.dialects import msft
 from .circt import ir
 
 from .types import Type, Channel, ClockType
diff --git a/frontends/PyCDE/src/constructs.py b/frontends/PyCDE/src/constructs.py
index a102be608..4c01f2ab5 100644
--- a/frontends/PyCDE/src/constructs.py
+++ b/frontends/PyCDE/src/constructs.py
@@ -5,14 +5,15 @@
 from __future__ import annotations
 
 from .common import Clock, Input, Output
-from .types import dim, types, Array, InOut, Type
-from .value import ArraySignal, BitsSignal, BitVectorSignal, ArraySignal, Value, Signal
-from .value import get_slice_bounds
+from .dialects import comb, msft, sv
 from .module import generator, modparams, Module, _BlockContext
+from .signals import ArraySignal, BitsSignal, BitVectorSignal, Signal
+from .signals import get_slice_bounds, _FromCirctValue
+from .types import dim, types, InOut, Type
+
+from .circt import ir
 from .circt.support import BackedgeBuilder
 from .circt.dialects import msft as raw_msft
-from pycde.dialects import comb, msft, sv
-from .circt import ir
 
 import typing
 from typing import List, Union
@@ -41,17 +42,17 @@ def NamedWire(type_or_value: Union[Type, Signal], name: str):
       uniq_name = _BlockContext.current().uniquify_symbol(name)
       self.wire_op = sv.WireOp(InOut(type), name, inner_sym=uniq_name)
       read_val = sv.ReadInOutOp(self.wire_op)
-      super().__init__(Value(read_val), type)
+      super().__init__(read_val, type)
       self.name = name
 
-    def assign(self, new_value: Value):
+    def assign(self, new_signal: Signal):
       if self.assigned_value is not None:
         raise ValueError("Cannot assign value to Wire twice.")
-      if new_value.type != self.type:
+      if new_signal.type != self.type:
         raise TypeError(
-            f"Cannot assign {new_value.value.type} to {self.value.type}")
-      sv.AssignOp(self.wire_op, new_value.value)
-      self.assigned_value = new_value
+            f"Cannot assign {new_signal.value.type} to {self.value.type}")
+      sv.AssignOp(self.wire_op, new_signal.value)
+      self.assigned_value = new_signal
       return self
 
   w = NamedWire()
@@ -177,7 +178,7 @@ def ControlReg(clk: Signal, rst: Signal, asserts: List[Signal],
                                                resets=resets).out
 
 
-def Mux(sel: BitVectorSignal, *data_inputs: typing.List[Value]):
+def Mux(sel: BitVectorSignal, *data_inputs: typing.List[Signal]):
   """Create a single mux from a list of values."""
   num_inputs = len(data_inputs)
   if num_inputs == 0:
@@ -212,11 +213,13 @@ def SystolicArray(row_inputs: ArraySignal, col_inputs: ArraySignal, pe_builder):
   pe_block = dummy_op.regions[0].blocks.append(
       row_inputs_type.element_type._type, col_inputs_type.element_type._type)
   with ir.InsertionPoint(pe_block):
-    result = pe_builder(Value(pe_block.arguments[0]),
-                        Value(pe_block.arguments[1]))
-    value = Value(result)
-    pe_output_type = value.type
-    msft.PEOutputOp(value)
+    result = pe_builder(_FromCirctValue(pe_block.arguments[0]),
+                        _FromCirctValue(pe_block.arguments[1]))
+    if not isinstance(result, Signal):
+      raise TypeError(
+          f"pe_builder function must return a `Signal` not {result}")
+    pe_output_type = result.type
+    msft.PEOutputOp(result)
 
   sa_result_type = dim(pe_output_type, col_inputs_type.size,
                        row_inputs_type.size)
@@ -225,4 +228,4 @@ def SystolicArray(row_inputs: ArraySignal, col_inputs: ArraySignal, pe_builder):
   dummy_op.regions[0].blocks[0].append_to(array.regions[0])
   dummy_op.operation.erase()
 
-  return Value(array.peOutputs)
+  return _FromCirctValue(array.peOutputs)
diff --git a/frontends/PyCDE/src/devicedb.py b/frontends/PyCDE/src/devicedb.py
index 88b34c67f..fe3cf60bb 100644
--- a/frontends/PyCDE/src/devicedb.py
+++ b/frontends/PyCDE/src/devicedb.py
@@ -5,11 +5,11 @@
 from __future__ import annotations
 from typing import Any, List, Optional, Tuple, Union
 
+from .support import get_user_loc
+
 from .circt.dialects import msft
 from .circt.support import attribute_to_var
-
 from .circt.ir import Attribute, StringAttr, ArrayAttr, FlatSymbolRefAttr
-from .support import get_user_loc
 
 from functools import singledispatchmethod
 
diff --git a/frontends/PyCDE/src/dialects/comb.py b/frontends/PyCDE/src/dialects/comb.py
index 4a5b7651b..25e72b8f1 100644
--- a/frontends/PyCDE/src/dialects/comb.py
+++ b/frontends/PyCDE/src/dialects/comb.py
@@ -2,7 +2,7 @@
 #  See https://llvm.org/LICENSE.txt for license information.
 #  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
-from ..value import wrap_opviews_with_values
+from ..signals import wrap_opviews_with_values
 from ..circt.dialects import comb
 
 wrap_opviews_with_values(comb, __name__)
diff --git a/frontends/PyCDE/src/dialects/esi.py b/frontends/PyCDE/src/dialects/esi.py
index 02b35d4a4..aae3acb40 100644
--- a/frontends/PyCDE/src/dialects/esi.py
+++ b/frontends/PyCDE/src/dialects/esi.py
@@ -2,7 +2,7 @@
 #  See https://llvm.org/LICENSE.txt for license information.
 #  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
-from ..value import wrap_opviews_with_values
+from ..signals import wrap_opviews_with_values
 from ..circt.dialects import esi
 
 wrap_opviews_with_values(esi, __name__)
diff --git a/frontends/PyCDE/src/dialects/fsm.py b/frontends/PyCDE/src/dialects/fsm.py
index a619f2c87..4119f6d66 100644
--- a/frontends/PyCDE/src/dialects/fsm.py
+++ b/frontends/PyCDE/src/dialects/fsm.py
@@ -2,7 +2,7 @@
 #  See https://llvm.org/LICENSE.txt for license information.
 #  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
-from ..value import wrap_opviews_with_values
+from ..signals import wrap_opviews_with_values
 from ..circt.dialects import fsm
 
 wrap_opviews_with_values(fsm, __name__,
diff --git a/frontends/PyCDE/src/dialects/hw.py b/frontends/PyCDE/src/dialects/hw.py
index d76dc880f..466fc30f7 100644
--- a/frontends/PyCDE/src/dialects/hw.py
+++ b/frontends/PyCDE/src/dialects/hw.py
@@ -2,7 +2,7 @@
 #  See https://llvm.org/LICENSE.txt for license information.
 #  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
-from ..value import wrap_opviews_with_values
+from ..signals import wrap_opviews_with_values
 from ..circt.dialects import hw
 
 wrap_opviews_with_values(hw, __name__)
diff --git a/frontends/PyCDE/src/dialects/hwarith.py b/frontends/PyCDE/src/dialects/hwarith.py
index c131a3420..679895e67 100644
--- a/frontends/PyCDE/src/dialects/hwarith.py
+++ b/frontends/PyCDE/src/dialects/hwarith.py
@@ -2,7 +2,7 @@
 #  See https://llvm.org/LICENSE.txt for license information.
 #  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
-from ..value import wrap_opviews_with_values
+from ..signals import wrap_opviews_with_values
 from ..circt.dialects import hwarith
 
 wrap_opviews_with_values(hwarith, __name__)
diff --git a/frontends/PyCDE/src/dialects/msft.py b/frontends/PyCDE/src/dialects/msft.py
index e6434ec2e..acc1f0229 100644
--- a/frontends/PyCDE/src/dialects/msft.py
+++ b/frontends/PyCDE/src/dialects/msft.py
@@ -2,7 +2,7 @@
 #  See https://llvm.org/LICENSE.txt for license information.
 #  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
-from ..value import wrap_opviews_with_values
+from ..signals import wrap_opviews_with_values
 from ..circt.dialects import msft
 
 wrap_opviews_with_values(msft, __name__)
diff --git a/frontends/PyCDE/src/dialects/seq.py b/frontends/PyCDE/src/dialects/seq.py
index 40b7ccd75..6fa84b30a 100644
--- a/frontends/PyCDE/src/dialects/seq.py
+++ b/frontends/PyCDE/src/dialects/seq.py
@@ -2,7 +2,7 @@
 #  See https://llvm.org/LICENSE.txt for license information.
 #  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
-from ..value import wrap_opviews_with_values
+from ..signals import wrap_opviews_with_values
 from ..circt.dialects import seq
 
 wrap_opviews_with_values(seq, __name__)
diff --git a/frontends/PyCDE/src/dialects/sv.py b/frontends/PyCDE/src/dialects/sv.py
index 8b73b22a2..c35cbdaec 100644
--- a/frontends/PyCDE/src/dialects/sv.py
+++ b/frontends/PyCDE/src/dialects/sv.py
@@ -2,7 +2,7 @@
 #  See https://llvm.org/LICENSE.txt for license information.
 #  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
-from ..value import wrap_opviews_with_values
+from ..signals import wrap_opviews_with_values
 from ..circt.dialects import sv
 
 wrap_opviews_with_values(sv, __name__)
diff --git a/frontends/PyCDE/src/esi.py b/frontends/PyCDE/src/esi.py
index f8cb0f22b..1bd448d80 100644
--- a/frontends/PyCDE/src/esi.py
+++ b/frontends/PyCDE/src/esi.py
@@ -2,10 +2,11 @@
 #  See https://llvm.org/LICENSE.txt for license information.
 #  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
+from .common import (Input, Output, InputChannel, OutputChannel, Clock,
+                     _PyProxy, PortError)
+from .module import Generator, Module, ModuleLikeBuilderBase, PortProxyBase
+from .signals import ChannelSignal, Signal, _FromCirctValue
 from .system import System
-from .module import Generator, _BlockContext, Module, ModuleLikeBuilderBase
-from .value import ChannelValue, Signal, Value
-from .common import Input, Output, InputChannel, OutputChannel, _PyProxy
 from .types import Channel, Type, types, _FromCirctType
 
 from .circt import ir
@@ -101,7 +102,7 @@ class ServiceDecl(_PyProxy):
             self._materialize_service_decl()),
         impl_type=ir.StringAttr.get(builtin),
         inputs=[x.value for x in inputs]).operation.results
-    return [Value(x) for x in impl_results]
+    return [_FromCirctValue(x) for x in impl_results]
 
 
 class _RequestConnection:
@@ -125,7 +126,7 @@ class _RequestConnection:
 
 class _RequestToServerConn(_RequestConnection):
 
-  def __call__(self, chan: ChannelValue, chan_name: str = ""):
+  def __call__(self, chan: ChannelSignal, chan_name: str = ""):
     self.decl._materialize_service_decl()
     raw_esi.RequestToServerConnectionOp(
         self.service_port, chan.value,
@@ -146,13 +147,13 @@ class _RequestToClientConn(_RequestConnection):
     req_op = raw_esi.RequestToClientConnectionOp(
         type._type, self.service_port,
         ir.ArrayAttr.get([ir.StringAttr.get(chan_name)]))
-    return ChannelValue(req_op)
+    return ChannelSignal(req_op.result, type)
 
 
 class _RequestToFromServerConn(_RequestConnection):
 
   def __call__(self,
-               to_server_channel: ChannelValue,
+               to_server_channel: ChannelSignal,
                chan_name: str = "",
                to_client_type: Optional[Type] = None):
     self.decl._materialize_service_decl()
@@ -167,7 +168,7 @@ class _RequestToFromServerConn(_RequestConnection):
     to_client = raw_esi.RequestInOutChannelOp(
         self.to_client_type._type, self.service_port, to_server_channel.value,
         ir.ArrayAttr.get([ir.StringAttr.get(chan_name)]))
-    return ChannelValue(to_client)
+    return ChannelSignal(to_client.result, type)
 
 
 def Cosim(decl: ServiceDecl, clk, rst):
@@ -218,12 +219,12 @@ def CosimBSP(user_module):
   return top
 
 
-class NamedChannelValue(ChannelValue):
+class NamedChannelValue(ChannelSignal):
   """A ChannelValue with the name of the client request."""
 
   def __init__(self, input_chan: ir.Value, client_name: List[str]):
     self.client_name = client_name
-    super().__init__(input_chan)
+    super().__init__(input_chan, _FromCirctType(input_chan.type))
 
 
 class _OutputChannelSetter:
@@ -232,12 +233,12 @@ class _OutputChannelSetter:
   have implemented for this request."""
 
   def __init__(self, req: raw_esi.RequestToClientConnectionOp,
-               old_chan_to_replace: ChannelValue):
+               old_chan_to_replace: ChannelSignal):
     self.type = Channel(_FromCirctType(req.toClient.type))
     self.client_name = req.clientNamePath
     self._chan_to_replace = old_chan_to_replace
 
-  def assign(self, new_value: ChannelValue):
+  def assign(self, new_value: ChannelSignal):
     """Assign the generated channel to this request."""
     if self._chan_to_replace is None:
       name_str = ".".join(self.client_name)
@@ -452,3 +453,66 @@ def _import_ram_decl(sys: "System", ram_op: raw_esi.RandomAccessMemoryDeclOp):
   ram.symbol = ir.StringAttr.get(sym)
   install(ram_op)
   return ram
+
+
+class PureModuleBuilder(ModuleLikeBuilderBase):
+  """Defines how an ESI `PureModule` gets built."""
+
+  @property
+  def circt_mod(self):
+    from .system import System
+    sys: System = System.current()
+    ret = sys._op_cache.get_circt_mod(self)
+    if ret is None:
+      return sys._create_circt_mod(self)
+    return ret
+
+  def create_op(self, sys: System, symbol):
+    """Callback for creating a ESIPureModule op."""
+    return raw_esi.ESIPureModuleOp(symbol, loc=self.loc, ip=sys._get_ip())
+
+  def scan_cls(self):
+    """Scan the class for input/output ports and generators. (Most `ModuleLike`
+    will use these.) Store the results for later use."""
+
+    generators = {}
+    for attr_name, attr in self.cls_dct.items():
+      if attr_name.startswith("_"):
+        continue
+
+      if isinstance(attr, (Clock, Input, Output)):
+        raise PortError("ESI pure modules cannot have ports")
+      elif isinstance(attr, Generator):
+        generators[attr_name] = attr
+
+    self.generators = generators
+
+  def create_port_proxy(self):
+    """Since pure ESI modules don't have any ports, this function is pretty
+    boring."""
+    proxy_attrs = {}
+    return type(self.modcls.__name__ + "Ports", (PortProxyBase,), proxy_attrs)
+
+  def add_external_port_accessors(self):
+    """Since we don't have ports, do nothing."""
+    pass
+
+  def generate(self):
+    """Fill in (generate) this module. Only supports a single generator
+    currently."""
+    if len(self.generators) != 1:
+      raise ValueError("Must have exactly one generator.")
+    g: Generator = list(self.generators.values())[0]
+
+    entry_block = self.circt_mod.add_entry_block()
+    ports = self.generator_port_proxy(None, self)
+    with self.GeneratorCtxt(self, ports, entry_block, g.loc):
+      g.gen_func(ports)
+
+
+class PureModule(Module):
+  """A pure ESI module has no ports and contains only instances of modules with
+  only ESI ports and connections between said instances. Use ESI services for
+  external communication."""
+
+  BuilderType = PureModuleBuilder
diff --git a/frontends/PyCDE/src/esi_api.py b/frontends/PyCDE/src/esi_api.py
index e56af30b4..64b1ae018 100644
--- a/frontends/PyCDE/src/esi_api.py
+++ b/frontends/PyCDE/src/esi_api.py
@@ -5,7 +5,6 @@
 from jinja2 import Environment, FileSystemLoader, StrictUndefined
 
 from io import FileIO
-import os
 import json
 import pathlib
 import re
diff --git a/frontends/PyCDE/src/esi_api.py.j2 b/frontends/PyCDE/src/esi_api.py.j2
index 52896a89a..4a753b64e 100644
--- a/frontends/PyCDE/src/esi_api.py.j2
+++ b/frontends/PyCDE/src/esi_api.py.j2
@@ -42,6 +42,7 @@ class {{ svc['name' ]}}:
     {%- for port in svc.ports %}
     self.{{port.name}} = {{port.name}}_ports
     {%- endfor %}
+    pass
 
   {% for port in svc.ports if port['to-server-type'] is defined -%}
   def {{port.name}}_read_any(self):
@@ -112,6 +113,7 @@ class DesignModules:
         {%- for pn in ports.keys() -%}{{pn}}_ports={{pn}}{% if not loop.last %}, {% endif %}{% endfor -%}
       )
       {%- endfor %}
+      pass
 
 {% endfor %} 
 
@@ -131,6 +133,7 @@ class ESITypes:
   {{type_name}}.capnp_name = "{{type_dict.capnp_name}}"
   {% endif -%}
 {%- endfor %}
+  pass
 
 {# Instantiate the top modules. E.g.: 
 
diff --git a/frontends/PyCDE/src/fsm.py b/frontends/PyCDE/src/fsm.py
index 54dca2e91..66d0b6d8a 100644
--- a/frontends/PyCDE/src/fsm.py
+++ b/frontends/PyCDE/src/fsm.py
@@ -1,14 +1,14 @@
-from pycde import Input, Output, generator
-from pycde.module import Generator, Module
-from pycde.dialects import fsm
-from pycde.types import types
-from typing import Callable
+from .common import Input, Output
+from .dialects import fsm
+from .module import generator, Generator, Module
+from .support import _obj_to_attribute, attributes_of_type
+from .types import types
 
 from .circt.ir import InsertionPoint
-
-from pycde.support import _obj_to_attribute, attributes_of_type
 from .circt.support import connect
 
+from typing import Callable
+
 
 class State:
 
diff --git a/frontends/PyCDE/src/instance.py b/frontends/PyCDE/src/instance.py
index 570dbb90a..f16a749ac 100644
--- a/frontends/PyCDE/src/instance.py
+++ b/frontends/PyCDE/src/instance.py
@@ -3,13 +3,14 @@
 #  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
 from __future__ import annotations
-from typing import Dict, Iterator, List, Optional, Tuple, Union
+
+from .devicedb import LocationVector
+from .module import AppID
 
 from .circt.dialects import msft, seq
 from .circt import ir
 
-from pycde.devicedb import LocationVector
-from pycde.module import AppID
+from typing import Dict, Iterator, List, Optional, Tuple, Union
 
 
 class Instance:
diff --git a/frontends/PyCDE/src/module.py b/frontends/PyCDE/src/module.py
index a5aefc83a..5b097b41b 100644
--- a/frontends/PyCDE/src/module.py
+++ b/frontends/PyCDE/src/module.py
@@ -3,15 +3,13 @@
 #  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
 from __future__ import annotations
-from typing import List, Optional, Set, Tuple, Union, Dict
-from pycde.types import ClockType
-
-from pycde.support import _obj_to_value
+from typing import List, Optional, Set, Tuple, Dict
 
 from .common import (AppID, Clock, Input, Output, PortError, _PyProxy)
-from .support import (get_user_loc, _obj_to_attribute, OpOperandConnect,
-                      create_type_string, create_const_zero)
-from .value import ClockSignal, Signal, Value
+from .support import (get_user_loc, _obj_to_attribute, create_type_string,
+                      create_const_zero)
+from .signals import ClockSignal, Signal, _FromCirctValue
+from .types import ClockType
 
 from .circt import ir, support
 from .circt.dialects import hw, msft
@@ -125,14 +123,15 @@ class PortProxyBase:
 
   def __init__(self, block_args, builder):
     self._block_args = block_args
-    self._output_values = [None] * len(builder.outputs)
+    if builder.outputs is not None:
+      self._output_values = [None] * len(builder.outputs)
     self._builder = builder
 
   def _get_input(self, idx):
     val = self._block_args[idx]
     if idx in self._builder.clocks:
       return ClockSignal(val, ClockType())
-    return Value(val)
+    return _FromCirctValue(val)
 
   def _set_output(self, idx, signal):
     assert signal is not None
@@ -142,7 +141,7 @@ class PortProxyBase:
         raise PortError(
             f"Input port {pname} expected type {ptype}, not {signal.type}")
     else:
-      signal = _obj_to_value(signal, ptype)
+      signal = ptype(signal)
     self._output_values[idx] = signal
 
   def _set_outputs(self, signal_dict: Dict[str, Signal]):
@@ -281,7 +280,7 @@ class ModuleLikeBuilderBase(_PyProxy):
     for idx, (name, port_type) in enumerate(self.outputs):
 
       def fget(self, idx=idx):
-        return Value(self.inst.results[idx])
+        return _FromCirctValue(self.inst.results[idx])
 
       named_outputs[name] = fget
       setattr(self.modcls, name, property(fget=fget))
@@ -316,7 +315,7 @@ class ModuleLikeBuilderBase(_PyProxy):
       self.loc = loc
       self.clk = None
       self.ports = ports
-      if len(builder.clocks) == 1:
+      if builder.clocks is not None and len(builder.clocks) == 1:
         # Enter clock block implicitly if only one clock given.
         clk_port = list(builder.clocks)[0]
         self.clk = ClockSignal(ports._block_args[clk_port], ClockType())
@@ -435,7 +434,7 @@ class ModuleBuilder(ModuleLikeBuilderBase):
       else:
         # If it's not a signal, assume the user wants to specify a constant and
         # try to convert it to a hardware constant.
-        signal = _obj_to_value(signal, ptype)
+        signal = ptype(signal)
       input_values[idx] = signal
       del input_lookup[name]
 
diff --git a/frontends/PyCDE/src/ndarray.py b/frontends/PyCDE/src/ndarray.py
index e4401d347..3a6380e46 100644
--- a/frontends/PyCDE/src/ndarray.py
+++ b/frontends/PyCDE/src/ndarray.py
@@ -2,11 +2,13 @@
 #  See https://llvm.org/LICENSE.txt for license information.
 #  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
-from .value import BitVectorSignal, ArraySignal
+from .dialects import hw, sv
+from .signals import BitVectorSignal, ArraySignal
 from .types import BitVectorType, dim
-from pycde.dialects import hw, sv
-import numpy as np
+
 from .circt import ir
+
+import numpy as np
 from functools import lru_cache
 from dataclasses import dataclass
 from typing import Union
@@ -79,7 +81,7 @@ class NDArray(np.ndarray):
         TypeError: _description_
     """
 
-    from pycde.value import ArraySignal
+    from pycde.signals import ArraySignal
 
     if (from_value is not None) and (shape is not None or dtype is not None):
       raise ValueError(
@@ -135,7 +137,7 @@ class NDArray(np.ndarray):
   def _circt_to_arr(value: Union[BitVectorSignal, ArraySignal],
                     target_shape: _TargetShape):
     """Converts a CIRCT value into a numpy array."""
-    from .value import (BitVectorSignal, ArraySignal)
+    from .signals import (BitVectorSignal, ArraySignal)
 
     if isinstance(value, BitVectorSignal) and isinstance(
         target_shape.dtype, BitVectorType):
@@ -271,7 +273,7 @@ class NDArray(np.ndarray):
     self.check_is_fully_assigned()
 
     def build_subarray(lstOrVal):
-      from .value import BitVectorSignal
+      from .signals import BitVectorSignal
       # Recursively converts this matrix into ListValues through hw.array_create
       # operations.
       if not isinstance(lstOrVal, BitVectorSignal):
diff --git a/frontends/PyCDE/src/value.py b/frontends/PyCDE/src/signals.py
similarity index 86%
rename from frontends/PyCDE/src/value.py
rename to frontends/PyCDE/src/signals.py
index cde743daf..c36371e3a 100644
--- a/frontends/PyCDE/src/value.py
+++ b/frontends/PyCDE/src/signals.py
@@ -5,6 +5,7 @@
 from __future__ import annotations
 
 from .support import get_user_loc, _obj_to_value_infer_type
+from .types import Type
 
 from .circt.dialects import sv
 from .circt import support
@@ -12,48 +13,43 @@ from .circt import ir
 
 from contextvars import ContextVar
 from functools import singledispatchmethod
-from typing import List, Optional, Union
+from typing import List, Optional, Tuple, Union
 import re
 import numpy as np
 
 
-def Value(value, type=None):
+def _FromCirctValue(value: ir.Value, type: Type = None) -> Signal:
   from .types import _FromCirctType
-
-  if isinstance(value, Signal):
-    return value
-
-  resvalue = support.get_value(value)
-  if resvalue is None:
-    return _obj_to_value_infer_type(value)
-
+  assert isinstance(value, ir.Value)
   if type is None:
-    type = resvalue.type
-  type = _FromCirctType(type)
-
-  return type._get_value_class()(resvalue, type)
+    type = _FromCirctType(value.type)
+  return type._get_value_class()(value, type)
 
 
 class Signal:
   """Root of the PyCDE value (signal, in RTL terms) hierarchy."""
 
-  def __init__(self, value, type=None):
-    from .types import _FromCirctType
+  def __init__(self, value: Union[Signal, ir.Value], type: Type):
+    assert value is not None
+    assert type is not None
 
+    self.type = type
     if isinstance(value, ir.Value):
       self.value = value
+    elif isinstance(value, Signal):
+      self.value = value.value
     else:
-      self.value = support.get_value(value)
-      if self.value is None:
-        self.value = _obj_to_value_infer_type(value).value
-
-    if type is not None:
-      self.type = type
-    else:
-      self.type = _FromCirctType(self.value.type)
+      assert False, "'value' must be either ir.Value or Signal"
 
   _reg_name = re.compile(r"^(.*)__reg(\d+)$")
 
+  @staticmethod
+  def create(obj) -> Signal:
+    """Create a Signal from any python object from which the hardware type can
+    be inferred. For instance, a list of Signals is inferred as an `Array` of
+    those signal types, assuming the types of all the `Signal` are the same."""
+    return _obj_to_value_infer_type(obj)
+
   def reg(self,
           clk=None,
           rst=None,
@@ -205,7 +201,7 @@ class InOutSignal(Signal):
   @property
   def read(self):
     if self.read_value is None:
-      self.read_value = Value(sv.ReadInOutOp.create(self).results[0])
+      self.read_value = _FromCirctValue(sv.ReadInOutOp.create(self).results[0])
     return self.read_value
 
 
@@ -218,8 +214,8 @@ def _validate_idx(size: int, idx: Union[int, BitVectorSignal]):
     idx = support.get_value(idx)
     if idx is None or not isinstance(support.type_to_pytype(idx.type),
                                      ir.IntegerType):
-      raise TypeError("Subscript on array must be either int or MLIR int"
-                      f" Value, not {type(idx)}.")
+      raise TypeError("Subscript on array must be either int or int signal"
+                      f" not {type(idx)}.")
 
 
 def get_slice_bounds(size, idxOrSlice: Union[int, slice]):
@@ -267,14 +263,14 @@ class BitVectorSignal(Signal):
     Returns this value as a a signed integer. If 'width' is provided, this value
     will be truncated or sign-extended to that width.
     """
-    return self._exec_cast(SIntValue, ir.IntegerType.get_signed, width)
+    return self._exec_cast(SIntSignal, ir.IntegerType.get_signed, width)
 
   def as_uint(self, width: int = None):
     """
-    Returns this value as an unsigned integer. If 'width' is provided, this value
-    will be truncated or zero-padded to that width.
+    Returns this value as an unsigned integer. If 'width' is provided, this
+    value will be truncated or zero-padded to that width.
     """
-    return self._exec_cast(UIntValue, ir.IntegerType.get_unsigned, width)
+    return self._exec_cast(UIntSignal, ir.IntegerType.get_unsigned, width)
 
 
 class BitsSignal(BitVectorSignal):
@@ -391,7 +387,7 @@ class BitsSignal(BitVectorSignal):
     return ret
 
 
-class IntValue(BitVectorSignal):
+class IntSignal(BitVectorSignal):
 
   #  === Infix operators ===
 
@@ -409,11 +405,11 @@ class IntValue(BitVectorSignal):
         const_type = ir.IntegerType.get_unsigned(other.bit_length())
       other = hwarith.ConstantOp(const_type, other)
 
-    if not isinstance(other, IntValue):
+    if not isinstance(other, IntSignal):
       raise TypeError(
           f"Operator '{op_symbol}' is not supported on non-int or signless "
-          "values. RHS operand should be cast .as_sint()/.as_uint() if possible."
-      )
+          "signals. RHS operand should be cast .as_sint()/.as_uint() if "
+          "possible.")
 
     ret = op(self, other)
     if self.name is not None and other.name is not None:
@@ -448,7 +444,7 @@ class IntValue(BitVectorSignal):
         const_type = ir.IntegerType.get_unsigned(other.bit_length())
       other = hwarith.ConstantOp(const_type, other)
 
-    if not isinstance(other, IntValue):
+    if not isinstance(other, IntSignal):
       raise TypeError(
           f"Comparisons of signed/unsigned integers to {other.type} not "
           "supported. RHS operand should be cast .as_sint()/.as_uint() if "
@@ -479,11 +475,11 @@ class IntValue(BitVectorSignal):
     assert False, "Unimplemented"
 
 
-class UIntValue(IntValue):
+class UIntSignal(IntSignal):
   pass
 
 
-class SIntValue(IntValue):
+class SIntSignal(IntSignal):
 
   def __neg__(self):
     from .types import types
@@ -560,12 +556,12 @@ class ArraySignal(Signal):
     return self.type.strip.size
 
   """
-  Add a curated set of Numpy functions through the Matrix class.
-  This allows for directly manipulating the ListValues with numpy functionality.
+  Add a curated set of Numpy functions through the Matrix class. This allows
+  for directly manipulating the ArraySignals with numpy functionality.
   Power-users who use the Matrix directly have access to all numpy functions.
   In reality, it will only be a subset of the numpy array functions which are
   safe to be used in the PyCDE context. Curating access at the level of
-  ListValues seems like a safe starting point.
+  ArraySignals seems like a safe starting point.
   """
 
   def transpose(self, *args, **kwargs):
@@ -602,7 +598,7 @@ class ArraySignal(Signal):
     return np.roll(NDArray(from_value=self), shift=shift, axis=axis).to_circt()
 
 
-class StructValue(Signal):
+class StructSignal(Signal):
 
   def __getitem__(self, sub):
     if sub not in [name for name, _ in self.type.strip.fields]:
@@ -620,27 +616,68 @@ class StructValue(Signal):
         if self.name:
           v.name = f"{self.name}__{attr}"
         return v
-    raise AttributeError(f"'Value' object has no attribute '{attr}'")
+    raise AttributeError(f"{type(self)} object has no attribute '{attr}'")
+
+
+class StructMetaType(type):
+
+  def __new__(self, name, bases, dct):
+    """Scans the class being created for type hints, creates a CIRCT struct
+    object and returns the CIRCT struct object instead of the class. Use the
+    class when a `Signal` of the struct type is instantiated."""
+
+    cls = super().__new__(self, name, bases, dct)
+    from .types import RegisteredStruct, Type
+    if "__annotations__" not in dct:
+      return cls
+    fields: List[Tuple[str, Type]] = []
+    for attr_name, attr in dct["__annotations__"].items():
+      if isinstance(attr, Type):
+        fields.append((attr_name, attr))
+
+    return RegisteredStruct(fields, name, cls)
+
+
+class Struct(StructSignal, metaclass=StructMetaType):
+  """Subclassing this class creates a hardware struct which can be used in port
+  definitions and will be instantiated in generators:
+
+  ```
+  class ExStruct(Struct):
+    a: Bits(4)
+    b: UInt(32)
+
+    def get_b(self):
+      return self.b
+
+  class TestStruct(Module):
+    inp1 = Input(ExStruct)
+
+    @generator
+    def build(self):
+      ... = self.inp1.get_b()
+  ```
+  """
+  # All the work is done in the metaclass.
 
 
-class ChannelValue(Signal):
+class ChannelSignal(Signal):
 
   def reg(self, clk, rst=None, name=None):
     raise TypeError("Cannot register a channel")
 
   def unwrap(self, ready):
     from .dialects import esi
-    from .support import _obj_to_value
     from .types import types
-    ready = _obj_to_value(ready, types.i1)
+    ready = types.i1(ready)
     unwrap_op = esi.UnwrapValidReadyOp(self.type.inner_type, types.i1,
                                        self.value, ready.value)
-    return Value(unwrap_op[0]), Value(unwrap_op[1])
+    return unwrap_op[0], unwrap_op[1]
 
 
 def wrap_opviews_with_values(dialect, module_name, excluded=[]):
   """Wraps all of a dialect's OpView classes to have their create method return
-     a PyCDE Value instead of an OpView. The wrapped classes are inserted into
+     a Signal instead of an OpView. The wrapped classes are inserted into
      the provided module."""
   import sys
   from .types import Type
@@ -655,7 +692,7 @@ def wrap_opviews_with_values(dialect, module_name, excluded=[]):
       def specialize_create(cls):
 
         def create(*args, **kwargs):
-          # If any of the arguments are Value or Type (which are both PyCDE
+          # If any of the arguments are Signal or Type (which are both PyCDE
           # classes) objects, we need to convert them.
           def to_circt(arg):
             if isinstance(arg, Signal):
@@ -678,7 +715,8 @@ def wrap_opviews_with_values(dialect, module_name, excluded=[]):
               created.twoState = True
 
           # Return the wrapped values, if any.
-          converted_results = tuple(Value(res) for res in created.results)
+          converted_results = tuple(
+              _FromCirctValue(res) for res in created.results)
           return converted_results[0] if len(
               converted_results) == 1 else converted_results
 
diff --git a/frontends/PyCDE/src/support.py b/frontends/PyCDE/src/support.py
index cdc31ccae..23f77853b 100644
--- a/frontends/PyCDE/src/support.py
+++ b/frontends/PyCDE/src/support.py
@@ -63,90 +63,10 @@ def create_const_zero(type):
     return hw.BitcastOp(type, zero)
 
 
-class OpOperandConnect(support.OpOperand):
-  """An OpOperand pycde extension which adds a connect method."""
-
-  def connect(self, obj, result_type=None):
-    if result_type is None:
-      result_type = self.type
-    val = _obj_to_value(obj, self.type, result_type)
-    support.connect(self, val)
-
-
-def _obj_to_value(x, type, result_type=None):
-  """Convert a python object to a CIRCT value, given the CIRCT type."""
-  if x is None:
-    raise ValueError(
-        "Encountered 'None' when trying to build hardware for python value.")
-  from .value import Signal
-  from .dialects import hw, hwarith
-  from .types import (TypeAlias, Array, Struct, BitVectorType, Bits, UInt, SInt,
-                      _FromCirctType)
-
-  if isinstance(x, Signal):
-    return x
-
-  type = _FromCirctType(type)
-  if isinstance(type, TypeAlias):
-    return _obj_to_value(x, type.inner_type, type)
-
-  if result_type is None:
-    result_type = type
-  else:
-    result_type = _FromCirctType(result_type)
-    assert isinstance(result_type, TypeAlias) or result_type == type
-
-  val = support.get_value(x)
-  # If x is already a valid value, just return it.
-  if val is not None:
-    if val.type != result_type:
-      raise ValueError(f"Expected {result_type}, got {val.type}")
-    return val
-
-  if isinstance(x, int):
-    if not isinstance(type, BitVectorType):
-      raise ValueError(f"Int can only be converted to hw int, not '{type}'")
-    with get_user_loc():
-      if isinstance(type, Bits):
-        return hw.ConstantOp(type, x)
-      elif isinstance(type, (UInt, SInt)):
-        return hwarith.ConstantOp(type, x)
-      else:
-        assert False, "Internal error: bit vector type unknown"
-
-  if isinstance(x, (list, tuple)):
-    if not isinstance(type, Array):
-      raise ValueError(f"List is only convertable to hw array, not '{type}'")
-    elemty = result_type.element_type
-    if len(x) != type.size:
-      raise ValueError("List must have same size as array "
-                       f"{len(x)} vs {type.size}")
-    list_of_vals = list(map(lambda x: _obj_to_value(x, elemty), x))
-    # CIRCT's ArrayCreate op takes the array in reverse order.
-    with get_user_loc():
-      return hw.ArrayCreateOp(reversed(list_of_vals))
-
-  if isinstance(x, dict):
-    if not isinstance(type, Struct):
-      raise ValueError(f"Dict is only convertable to hw struct, not '{type}'")
-    elem_name_values = []
-    for (fname, ftype) in type.fields:
-      if fname not in x:
-        raise ValueError(f"Could not find expected field: {fname}")
-      elem_name_values.append((fname, _obj_to_value(x[fname], ftype)))
-      x.pop(fname)
-    if len(x) > 0:
-      raise ValueError(f"Extra fields specified: {x}")
-    with get_user_loc():
-      return hw.StructCreateOp(elem_name_values, result_type=result_type._type)
-
-  raise ValueError(f"Unable to map object '{x}' to MLIR Value")
-
-
 def _infer_type(x):
   """Infer the CIRCT type from a python object. Only works on lists."""
-  from .types import types
-  from .value import Signal
+  from .types import Array
+  from .signals import Signal
   if isinstance(x, Signal):
     return x.type
 
@@ -155,7 +75,7 @@ def _infer_type(x):
     list_type = list_types[0]
     if not all([i == list_type for i in list_types]):
       raise ValueError("CIRCT array must be homogenous, unlike object")
-    return types.array(list_type, len(x))
+    return Array(list_type, len(x))
   if isinstance(x, int):
     raise ValueError(f"Cannot infer width of {x}")
   if isinstance(x, dict):
@@ -163,13 +83,13 @@ def _infer_type(x):
   return None
 
 
-def _obj_to_value_infer_type(value):
+def _obj_to_value_infer_type(value) -> ir.Value:
   """Infer the CIRCT type, then convert the Python object to a CIRCT Value of
   that type."""
-  type = _infer_type(value)
-  if type is None:
+  cde_type = _infer_type(value)
+  if cde_type is None:
     raise ValueError(f"Cannot infer CIRCT type from '{value}")
-  return _obj_to_value(value, type)
+  return cde_type(value)
 
 
 def create_type_string(ty):
diff --git a/frontends/PyCDE/src/system.py b/frontends/PyCDE/src/system.py
index 3b861e8a3..df5244b9e 100644
--- a/frontends/PyCDE/src/system.py
+++ b/frontends/PyCDE/src/system.py
@@ -8,12 +8,12 @@ from pycde.devicedb import (EntityExtern, PlacementDB, PrimitiveDB,
                             PhysicalRegion)
 
 from .common import _PyProxy
+from .instance import Instance, InstanceHierarchyRoot
 from .module import Module, ModuleLikeType, ModuleLikeBuilderBase
 from .types import TypeAlias
-from .instance import Instance, InstanceHierarchyRoot
 
 from . import circt
-from .circt import ir, passmanager, support
+from .circt import ir, passmanager
 from .circt.dialects import esi, hw, msft
 from .esi_api import PythonApiBuilder
 
@@ -93,13 +93,23 @@ class System:
   def add_packaging_step(self, func: Callable):
     self.packaging_funcs.append(func)
 
+  def _return_create_if_necessary(self, dir: pathlib.Path):
+    """Return the director given by 'dir' but create it if it doesn't exist."""
+    if not dir.exists():
+      dir.mkdir()
+    return dir
+
   @property
   def hw_output_dir(self):
-    return self.output_directory / "hw"
+    return self._return_create_if_necessary(self.output_directory / "hw")
 
   @property
   def runtime_output_dir(self):
-    return self.output_directory / "runtime"
+    return self._return_create_if_necessary(self.output_directory / "runtime")
+
+  @property
+  def sys_runtime_output_dir(self):
+    return self._return_create_if_necessary(self.output_directory / self.name)
 
   def _get_ip(self):
     return ir.InsertionPoint(self.mod.body)
@@ -277,6 +287,8 @@ class System:
     self.files.add(self.output_directory / tcl_file)
 
     self._op_cache.release_ops()
+    if debug:
+      open("after_generate.mlir", "w").write(str(self.mod))
     for idx, phase in enumerate(self.PASS_PHASES):
       aplog = None
       if debug:
@@ -296,6 +308,9 @@ class System:
       except RuntimeError as err:
         sys.stderr.write(f"Exception while executing phase {phase}.\n")
         raise err
+      finally:
+        if debug:
+          open(f"after_phase_{idx}.mlir", "w").write(str(self.mod))
       self._op_cache.release_ops()
       if aplog is not None:
         aplog.write(str(self.mod))
diff --git a/frontends/PyCDE/src/testing.py b/frontends/PyCDE/src/testing.py
index e099613c7..bf265bc4b 100644
--- a/frontends/PyCDE/src/testing.py
+++ b/frontends/PyCDE/src/testing.py
@@ -1,4 +1,5 @@
-from pycde import System, Module
+from .system import System
+from .module import Module
 
 import builtins
 import inspect
diff --git a/frontends/PyCDE/src/types.py b/frontends/PyCDE/src/types.py
index 6cef44e85..7b41b0980 100644
--- a/frontends/PyCDE/src/types.py
+++ b/frontends/PyCDE/src/types.py
@@ -4,14 +4,11 @@
 
 from collections import OrderedDict
 
-from .value import (BitsSignal, ChannelValue, ClockSignal, ArraySignal,
-                    SIntValue, UIntValue, StructValue, UntypedSignal,
-                    InOutSignal, Value)
+from .support import get_user_loc
 
 from .circt import ir, support
 from .circt.dialects import esi, hw, sv
 
-from typing import Union
 import typing
 
 
@@ -22,12 +19,12 @@ class _Types:
     self.registered_aliases = OrderedDict()
 
   def __getattr__(self, name: str) -> ir.Type:
-    return self.wrap(ir.Type.parse(name))
+    return self.wrap(_FromCirctType(ir.Type.parse(name)))
 
   def int(self, width: int, name: str = None):
     return self.wrap(Bits(width), name)
 
-  def array(self, inner: ir.Type, size: int, name: str = None) -> hw.ArrayType:
+  def array(self, inner: ir.Type, size: int, name: str = None) -> "Array":
     return self.wrap(Array(inner, size), name)
 
   def inout(self, inner: ir.Type):
@@ -36,11 +33,8 @@ class _Types:
   def channel(self, inner):
     return self.wrap(Channel(inner))
 
-  def struct(self, members, name: str = None) -> hw.StructType:
-    s = Struct(members)
-    if name is None:
-      return s
-    return TypeAlias(s, name)
+  def struct(self, members, name: str = None) -> "StructType":
+    return self.wrap(StructType(members), name)
 
   @property
   def any(self):
@@ -49,7 +43,7 @@ class _Types:
   def wrap(self, type, name=None):
     if name is not None:
       type = TypeAlias(type, name)
-    return _FromCirctType(type)
+    return type
 
 
 types = _Types()
@@ -62,11 +56,15 @@ class Type:
   # Global Type cache.
   _cache: typing.Dict[typing.Tuple[type, ir.Type], "Type"] = {}
 
-  def __new__(cls, circt_type: ir.Type) -> "Type":
+  def __new__(cls, circt_type: ir.Type, incl_cls_in_key: bool = True) -> "Type":
     """Look up a type in the Type cache. If present, return it. If not, create
     it and put it in the cache."""
     assert isinstance(circt_type, ir.Type)
-    cache_key = (cls, circt_type)
+    if incl_cls_in_key:
+      cache_key = (cls, circt_type)
+    else:
+      cache_key = circt_type
+
     if cache_key not in Type._cache:
       t = super(Type, cls).__new__(cls)
       t._type = circt_type
@@ -84,32 +82,57 @@ class Type:
   def bitwidth(self):
     return hw.get_bitwidth(self._type)
 
-  def __call__(self, value_obj, name: str = None):
+  def __call__(self, obj, name: str = None) -> "Signal":
     """Create a Value of this type from a python object."""
-    from .support import _obj_to_value
-    v = _obj_to_value(value_obj, self, self)
+    assert not isinstance(obj, ir.Value)
+    v = self._from_obj_or_sig(obj)
     if name is not None:
       v.name = name
     return v
 
+  def _from_obj_or_sig(self,
+                       obj,
+                       alias: typing.Optional["TypeAlias"] = None) -> "Signal":
+    """Implement the object-signal conversion wherein 'obj' can be a Signal. If
+    'obj' is already a Signal, check its type and return it. Can be overriden by
+    subclasses, though calls _from_obj() to do the type-specific const
+    conversion so we recommend subclasses override that method."""
+
+    from .signals import Signal
+    if isinstance(obj, Signal):
+      if obj.type != self:
+        raise TypeError(f"Expected signal of type {self} but got {obj.type}")
+      return obj
+    return self._from_obj(obj, alias)
+
+  def _from_obj(self,
+                obj,
+                alias: typing.Optional["TypeAlias"] = None) -> "Signal":
+    """Do the type-specific object validity checks and return a Signal from the
+    object. Can assume the 'obj' is NOT a Signal. Any subclass which wants to be
+    created MUST override this method."""
+
+    assert False, "Subclass must override this method"
+
   def _get_value_class(self):
     """Return the class which should be instantiated to create a Value."""
+    from .signals import UntypedSignal
     return UntypedSignal
 
   def __repr__(self):
     return self._type.__repr__()
 
 
-def _FromCirctType(type: Union[ir.Type, Type]) -> Type:
+def _FromCirctType(type: typing.Union[ir.Type, Type]) -> Type:
   if isinstance(type, Type):
     return type
   type = support.type_to_pytype(type)
   if isinstance(type, hw.ArrayType):
     return Type.__new__(Array, type)
   if isinstance(type, hw.StructType):
-    return Type.__new__(Struct, type)
+    return Type.__new__(StructType, type)
   if isinstance(type, hw.TypeAliasType):
-    return Type.__new__(TypeAlias, type)
+    return Type.__new__(TypeAlias, type, incl_cls_in_key=False)
   if isinstance(type, hw.InOutType):
     return Type.__new__(InOut, type)
   if isinstance(type, ir.IntegerType):
@@ -136,8 +159,12 @@ class InOut(Type):
     return _FromCirctType(self._type.element_type)
 
   def _get_value_class(self):
+    from .signals import InOutSignal
     return InOutSignal
 
+  def __repr__(self):
+    return f"InOut<{repr(self.element_type)}"
+
 
 class TypeAlias(Type):
 
@@ -145,20 +172,21 @@ class TypeAlias(Type):
   RegisteredAliases: typing.Optional[OrderedDict] = None
 
   def __new__(cls, inner_type: Type, name: str):
-    if not TypeAlias.RegisteredAliases:
+    if TypeAlias.RegisteredAliases is None:
       TypeAlias.RegisteredAliases = OrderedDict()
-    alias = hw.TypeAliasType.get(TypeAlias.TYPE_SCOPE, name, inner_type._type)
 
     if name in TypeAlias.RegisteredAliases:
-      if alias != TypeAlias.RegisteredAliases[name]:
+      if inner_type._type != TypeAlias.RegisteredAliases[name].inner_type:
         raise RuntimeError(
             f"Re-defining type alias for {name}! "
             f"Given: {inner_type}, "
             f"existing: {TypeAlias.RegisteredAliases[name].inner_type}")
-      return TypeAlias.RegisteredAliases[name]
+      alias = TypeAlias.RegisteredAliases[name]
+    else:
+      alias = hw.TypeAliasType.get(TypeAlias.TYPE_SCOPE, name, inner_type._type)
+      TypeAlias.RegisteredAliases[name] = alias
 
-    TypeAlias.RegisteredAliases[name] = alias
-    return super(TypeAlias, cls).__new__(cls, alias)
+    return super(TypeAlias, cls).__new__(cls, alias, incl_cls_in_key=False)
 
   @staticmethod
   def declare_aliases(mod):
@@ -202,13 +230,16 @@ class TypeAlias(Type):
         hw.TypedeclOp.create(name, type.inner_type)
 
   @property
-  def name(self):
+  def name(self) -> str:
     return self._type.name
 
   @property
   def inner_type(self):
     return _FromCirctType(self._type.inner_type)
 
+  def __repr__(self):
+    return f"TypeAlias<'{self.name}', {repr(self.inner_type)}"
+
   def __str__(self):
     return self.name
 
@@ -222,6 +253,9 @@ class TypeAlias(Type):
   def wrap(self, value):
     return self(value)
 
+  def _from_obj(self, obj, alias: typing.Optional["TypeAlias"] = None):
+    return self.inner_type._from_obj_or_sig(obj, alias=self)
+
 
 class Array(Type):
 
@@ -254,13 +288,31 @@ class Array(Type):
     return self.size
 
   def _get_value_class(self):
+    from .signals import ArraySignal
     return ArraySignal
 
+  def __repr__(self) -> str:
+    return f"Array({self.size}, {self.element_type})"
+
   def __str__(self) -> str:
-    return f"[{self.size}]{self.element_type}"
+    return f"{self.element_type}[{self.size}]"
 
+  def _from_obj(self, obj, alias: typing.Optional[TypeAlias] = None):
+    from .dialects import hw
+    if not isinstance(obj, (list, tuple)):
+      raise ValueError(
+          f"Arrays can only be created from lists or tuples, not '{type(obj)}'")
+    if len(obj) != self.size:
+      raise ValueError("List must have same size as array "
+                       f"{len(obj)} vs {self.size}")
+    elemty = self.element_type
+    list_of_vals = list(map(lambda x: elemty._from_obj_or_sig(x), obj))
+    with get_user_loc():
+      # CIRCT's ArrayCreate op takes the array in reverse order.
+      return hw.ArrayCreateOp(reversed(list_of_vals))
 
-class Struct(Type):
+
+class StructType(Type):
 
   def __new__(cls, fields: typing.Union[typing.List[typing.Tuple[str, Type]],
                                         typing.Dict[str, Type]]):
@@ -268,7 +320,7 @@ class Struct(Type):
       fields = list(fields.items())
     if not isinstance(fields, list):
       raise TypeError("Expected either list or dict.")
-    return super(Struct, cls).__new__(
+    return super(StructType, cls).__new__(
         cls, hw.StructType.get([(n, t._type) for (n, t) in fields]))
 
   @property
@@ -282,9 +334,29 @@ class Struct(Type):
     return super().__getattribute__(attrname)
 
   def _get_value_class(self):
-    return StructValue
-
-  def __str__(self) -> str:
+    from .signals import StructSignal
+    return StructSignal
+
+  def _from_obj(self, x, alias: typing.Optional[TypeAlias] = None):
+    from .dialects import hw
+    if not isinstance(x, dict):
+      raise ValueError(
+          f"Structs can only be created from dicts, not '{type(x)}'")
+    elem_name_values = []
+    for (fname, ftype) in self.fields:
+      if fname not in x:
+        raise ValueError(f"Could not find expected field: {fname}")
+      v = ftype._from_obj_or_sig(x[fname])
+      elem_name_values.append((fname, v))
+      x.pop(fname)
+    if len(x) > 0:
+      raise ValueError(f"Extra fields specified: {x}")
+
+    result_type = self if alias is None else alias
+    with get_user_loc():
+      return hw.StructCreateOp(elem_name_values, result_type=result_type._type)
+
+  def __repr__(self) -> str:
     ret = "struct { "
     first = True
     for field in self.fields:
@@ -292,17 +364,47 @@ class Struct(Type):
         first = False
       else:
         ret += ", "
-      ret += f"{field[0]}: {_FromCirctType(field[1])}"
+      ret += f"{field[0]}: {field[1]}"
     ret += "}"
     return ret
 
 
+class RegisteredStruct(TypeAlias):
+  """Represents a named struct with a custom signal class. Primarily used by
+  `value.Struct`."""
+
+  def __new__(cls, fields: typing.List[typing.Tuple[str, Type]], name: str,
+              value_class):
+    inner_type = StructType(fields)
+    inst = super().__new__(cls, inner_type, name)
+    inst._value_class = value_class
+    return inst
+
+  def __call__(self, **kwargs):
+    return self._from_obj_or_sig(kwargs)
+
+  def _get_value_class(self):
+    return self._value_class
+
+
 class BitVectorType(Type):
 
   @property
   def width(self):
     return self._type.width
 
+  def _from_obj_check(self, x):
+    """This functionality can be shared by all the int types."""
+    if not isinstance(x, int):
+      raise ValueError(f"{type(self).__name__} can only be created from ints, "
+                       f"not {type(x).__name__}")
+    signed_bit = 1 if isinstance(self, SInt) else 0
+    if x.bit_length() + signed_bit > self.width:
+      raise ValueError(f"{x} overflows type {self}")
+
+  def __repr__(self) -> str:
+    return f"{type(self).__name__}<{self.width}>"
+
 
 class Bits(BitVectorType):
 
@@ -313,10 +415,14 @@ class Bits(BitVectorType):
     )
 
   def _get_value_class(self):
+    from .signals import BitsSignal
     return BitsSignal
 
-  def __repr__(self):
-    return f"bits{self.width}"
+  def _from_obj(self, x: int, alias: typing.Optional[TypeAlias] = None):
+    from .dialects import hw
+    self._from_obj_check(x)
+    circt_type = self if alias is None else alias
+    return hw.ConstantOp(circt_type, x)
 
 
 class SInt(BitVectorType):
@@ -328,10 +434,14 @@ class SInt(BitVectorType):
     )
 
   def _get_value_class(self):
-    return SIntValue
+    from .signals import SIntSignal
+    return SIntSignal
 
-  def __repr__(self):
-    return f"sint{self.width}"
+  def _from_obj(self, x: int, alias: typing.Optional[TypeAlias] = None):
+    from .dialects import hwarith
+    self._from_obj_check(x)
+    circt_type = self if alias is None else alias
+    return hwarith.ConstantOp(circt_type, x)
 
 
 class UInt(BitVectorType):
@@ -343,10 +453,16 @@ class UInt(BitVectorType):
     )
 
   def _get_value_class(self):
-    return UIntValue
+    from .signals import UIntSignal
+    return UIntSignal
 
-  def __repr__(self):
-    return f"uint{self.width}"
+  def _from_obj(self, x: int, alias: typing.Optional[TypeAlias] = None):
+    from .dialects import hwarith
+    self._from_obj_check(x)
+    if x < 0:
+      raise ValueError(f"UInt can only store positive numbers, not {x}")
+    circt_type = self if alias is None else alias
+    return hwarith.ConstantOp(circt_type, x)
 
 
 class ClockType(Bits):
@@ -358,13 +474,14 @@ class ClockType(Bits):
   # type.
 
   def __new__(cls):
-    super(ClockType, cls).__new__(cls, 1)
+    return super(ClockType, cls).__new__(cls, 1)
 
   def _get_value_class(self):
+    from .signals import ClockSignal
     return ClockSignal
 
   def __repr__(self):
-    return "clk"
+    return "Clk"
 
 
 class Any(Type):
@@ -385,23 +502,31 @@ class Channel(Type):
     return _FromCirctType(self._type.inner)
 
   def _get_value_class(self):
-    return ChannelValue
+    from .signals import ChannelSignal
+    return ChannelSignal
 
-  def __str__(self):
-    return f"channel<{self.inner_type}>"
+  def __repr__(self):
+    return f"Channel<{self.inner_type}>"
 
   @property
   def inner(self):
     return self.inner_type
 
-  def wrap(self, value, valid):
+  def wrap(self, value, valid) -> typing.Tuple["ChannelSignal", "BitsSignal"]:
+    """Wrap a data signal and valid signal into a data channel signal and a
+    ready signal."""
+
+    # Instead of implementing __call__(), we require users to call this method
+    # instead. In addition to being clearer, the type signature isn't the same
+    # -- this returns a tuple of Signals (data, ready) -- rather than a single
+    # one.
+
     from .dialects import esi
-    from .support import _obj_to_value
-    value = _obj_to_value(value, self._type.inner)
-    valid = _obj_to_value(valid, types.i1)
+    value = self.inner_type(value)
+    valid = types.i1(valid)
     wrap_op = esi.WrapValidReadyOp(self._type, types.i1, value.value,
                                    valid.value)
-    return Value(wrap_op[0]), BitsSignal(wrap_op[1], types.i1)
+    return wrap_op[0], wrap_op[1]
 
 
 def dim(inner_type_or_bitwidth: typing.Union[Type, int],
diff --git a/frontends/PyCDE/test/pycde_types.py b/frontends/PyCDE/test/pycde_types.py
deleted file mode 100644
index a112663c7..000000000
--- a/frontends/PyCDE/test/pycde_types.py
+++ /dev/null
@@ -1,40 +0,0 @@
-# RUN: %PYTHON% %s | FileCheck %s
-
-from pycde import dim, types
-from pycde.types import Bits, Struct, TypeAlias
-from pycde.circt.ir import Module
-
-# CHECK: [('foo', bits1), ('bar', bits13)]
-st1 = Struct({"foo": types.i1, "bar": types.i13})
-print(st1.fields)
-# CHECK: bits1
-print(st1.foo)
-
-array1 = dim(types.ui6)
-# CHECK: uint6
-print(array1)
-
-array2 = dim(6, 10, 12)
-# CHECK: [12][10]bits6
-print(array2)
-
-int_alias = TypeAlias(Bits(8), "myname1")
-# CHECK: myname1
-print(int_alias)
-assert int_alias == types.int(8, "myname1")
-
-# CHECK: struct { a: bits1, b: sint1}
-struct = types.struct({"a": types.i1, "b": types.si1})
-print(struct)
-
-dim_alias = dim(1, 8, name="myname5")
-
-# CHECK: hw.type_scope @pycde
-# CHECK: hw.typedecl @myname1 : i8
-# CHECK: hw.typedecl @myname5 : !hw.array<8xi1>
-# CHECK-NOT: hw.typedecl @myname1
-# CHECK-NOT: hw.typedecl @myname5
-m = Module.create()
-TypeAlias.declare_aliases(m)
-TypeAlias.declare_aliases(m)
-print(m)
diff --git a/frontends/PyCDE/test/behavioral.py b/frontends/PyCDE/test/test_behavioral.py
similarity index 100%
rename from frontends/PyCDE/test/behavioral.py
rename to frontends/PyCDE/test/test_behavioral.py
diff --git a/frontends/PyCDE/test/cocotb_testbench.py b/frontends/PyCDE/test/test_cocotb_testbench.py
similarity index 100%
rename from frontends/PyCDE/test/cocotb_testbench.py
rename to frontends/PyCDE/test/test_cocotb_testbench.py
diff --git a/frontends/PyCDE/test/compreg.py b/frontends/PyCDE/test/test_compreg.py
similarity index 100%
rename from frontends/PyCDE/test/compreg.py
rename to frontends/PyCDE/test/test_compreg.py
diff --git a/frontends/PyCDE/test/errors.py b/frontends/PyCDE/test/test_errors.py
similarity index 87%
rename from frontends/PyCDE/test/errors.py
rename to frontends/PyCDE/test/test_errors.py
index d76412504..2c1130699 100644
--- a/frontends/PyCDE/test/errors.py
+++ b/frontends/PyCDE/test/test_errors.py
@@ -75,7 +75,7 @@ class OperatorError(Module):
 
   @generator
   def build(ports):
-    # CHECK: Operator '+' is not supported on non-int or signless values. RHS operand should be cast .as_sint()/.as_uint() if possible.
+    # CHECK: Operator '+' is not supported on non-int or signless signals. RHS operand should be cast .as_sint()/.as_uint() if possible.
     ports.b + ports.a
 
 
@@ -89,5 +89,5 @@ class OperatorError2(Module):
 
   @generator
   def build(ports):
-    # CHECK: Comparisons of signed/unsigned integers to bits32 not supported. RHS operand should be cast .as_sint()/.as_uint() if possible.
+    # CHECK: Comparisons of signed/unsigned integers to Bits<32> not supported. RHS operand should be cast .as_sint()/.as_uint() if possible.
     ports.b == ports.a
diff --git a/frontends/PyCDE/test/esi.py b/frontends/PyCDE/test/test_esi.py
similarity index 93%
rename from frontends/PyCDE/test/esi.py
rename to frontends/PyCDE/test/test_esi.py
index 730f25e40..90cfd3e1d 100644
--- a/frontends/PyCDE/test/esi.py
+++ b/frontends/PyCDE/test/test_esi.py
@@ -8,7 +8,7 @@ from pycde.common import Output
 from pycde.constructs import Wire
 from pycde.types import Channel
 from pycde.testing import unittestmodule
-from pycde.value import BitVectorSignal, ChannelValue
+from pycde.signals import BitVectorSignal, ChannelSignal
 
 
 @esi.ServiceDecl
@@ -94,6 +94,17 @@ class LoopbackInOutTop(Module):
     loopback.assign(data_chan)
 
 
+# CHECK-LABEL:  esi.pure_module @LoopbackInOutPure {
+# CHECK:          [[r0:%.+]] = esi.service.req.to_client <@HostComms::@from_host>(["loopback_in"]) : !esi.channel<i16>
+# CHECK:          esi.service.req.to_server [[r0]] -> <@HostComms::@to_host>(["loopback"]) : !esi.channel<i16>
+@unittestmodule(print=True)
+class LoopbackInOutPure(esi.PureModule):
+
+  @generator
+  def construct(self):
+    HostComms.to_host(HostComms.from_host("loopback_in", types.i16), "loopback")
+
+
 class MultiplexerService(esi.ServiceImplementation):
   clk = Clock()
   rst = Input(types.i1)
@@ -130,7 +141,7 @@ class MultiplexerService(esi.ServiceImplementation):
     return channel_type.wrap(sliced, ports.trunk_in_valid)
 
   @staticmethod
-  def unwrap_and_pad(ports, input_channel: ChannelValue):
+  def unwrap_and_pad(ports, input_channel: ChannelSignal):
     """
     Unwrap the input channel and pad it to 256 bits.
     """
diff --git a/frontends/PyCDE/test/test_esi_errors.py b/frontends/PyCDE/test/test_esi_errors.py
index d4dd738ce..e287739f0 100644
--- a/frontends/PyCDE/test/test_esi_errors.py
+++ b/frontends/PyCDE/test/test_esi_errors.py
@@ -59,7 +59,7 @@ class MultiplexerService(esi.ServiceImplementation):
     v = types.i1(0)
     chan, rdy = types.channel(types.i128).wrap(c, v)
     try:
-      # CHECK: Channel type mismatch. Expected channel<bits32>, got channel<bits128>.
+      # CHECK: Channel type mismatch. Expected Channel<Bits<32>>, got Channel<Bits<128>>.
       channels.to_client_reqs[0].assign(chan)
     except Exception as e:
       print(e)
diff --git a/frontends/PyCDE/test/generator_options.py b/frontends/PyCDE/test/test_generator_options.py
similarity index 100%
rename from frontends/PyCDE/test/generator_options.py
rename to frontends/PyCDE/test/test_generator_options.py
diff --git a/frontends/PyCDE/test/good_example.py b/frontends/PyCDE/test/test_good_example.py
similarity index 100%
rename from frontends/PyCDE/test/good_example.py
rename to frontends/PyCDE/test/test_good_example.py
diff --git a/frontends/PyCDE/test/instances.py b/frontends/PyCDE/test/test_instances.py
similarity index 97%
rename from frontends/PyCDE/test/instances.py
rename to frontends/PyCDE/test/test_instances.py
index 594b7070d..aabf1e0e2 100644
--- a/frontends/PyCDE/test/instances.py
+++ b/frontends/PyCDE/test/test_instances.py
@@ -59,9 +59,9 @@ class Test(Module):
 t = pycde.System([Test], name="Test", output_directory=sys.argv[1])
 t.generate(["construct"])
 t.print()
-# CHECK: <pycde.Module: Test inputs: [('clk', bits1)] outputs: []>
+# CHECK: <pycde.Module: Test inputs: [('clk', Bits<1>)] outputs: []>
 Test.print()
-# CHECK: <pycde.Module: UnParameterized inputs: [('clk', bits1), ('x', bits1)] outputs: [('y', bits1)]>
+# CHECK: <pycde.Module: UnParameterized inputs: [('clk', Bits<1>), ('x', Bits<1>)] outputs: [('y', Bits<1>)]>
 UnParameterized.print()
 
 print(PhysLocation(PrimitiveType.DSP, 39, 25))
diff --git a/frontends/PyCDE/test/test_misc_errors.py b/frontends/PyCDE/test/test_misc_errors.py
index b169a6d9e..f47302f34 100644
--- a/frontends/PyCDE/test/test_misc_errors.py
+++ b/frontends/PyCDE/test/test_misc_errors.py
@@ -3,6 +3,7 @@
 from pycde import Input, generator, dim, Module
 from pycde.constructs import Mux
 from pycde.testing import unittestmodule
+from pycde.types import Bits, SInt, UInt
 
 
 @unittestmodule()
@@ -29,3 +30,44 @@ class Mux2(Module):
   def create(ports):
     # CHECK: ValueError: 'Mux' must have 1 or more data input
     Mux(ports.Sel)
+
+
+# -----
+
+
+@unittestmodule(print=False)
+class WrongInts(Module):
+
+  @generator
+  def construct(mod):
+    b4 = Bits(4)
+    si4 = SInt(4)
+    ui4 = UInt(4)
+
+    try:
+      # CHECK: Bits can only be created from ints, not str
+      b4("foo")
+      assert False
+    except ValueError as e:
+      print(e)
+
+    try:
+      # CHECK: 300 overflows type Bits<4>
+      b4(300)
+      assert False
+    except ValueError as e:
+      print(e)
+
+    try:
+      # CHECK: 15 overflows type SInt<4>
+      si4(15)
+      assert False
+    except ValueError as e:
+      print(e)
+
+    try:
+      # CHECK: UInt can only store positive numbers, not -1
+      ui4(-1)
+      assert False
+    except ValueError as e:
+      print(e)
diff --git a/frontends/PyCDE/test/module_naming.py b/frontends/PyCDE/test/test_module_naming.py
similarity index 100%
rename from frontends/PyCDE/test/module_naming.py
rename to frontends/PyCDE/test/test_module_naming.py
diff --git a/frontends/PyCDE/test/muxing.py b/frontends/PyCDE/test/test_muxing.py
similarity index 97%
rename from frontends/PyCDE/test/muxing.py
rename to frontends/PyCDE/test/test_muxing.py
index 157eaeaa6..38fca2b69 100644
--- a/frontends/PyCDE/test/muxing.py
+++ b/frontends/PyCDE/test/test_muxing.py
@@ -1,14 +1,10 @@
 # RUN: %PYTHON% py-split-input-file.py %s | FileCheck %s
 
-from pycde import generator, dim, Clock, Input, Output, Module, Value, types
+from pycde import generator, dim, Clock, Input, Output, Module, types
+from pycde.signals import Signal
 from pycde.constructs import Mux
 from pycde.testing import unittestmodule
 
-
-def array_from_tuple(*input):
-  return Value(input)
-
-
 # CHECK-LABEL: msft.module @ComplexMux {} (%Clk: i1, %In: !hw.array<5xarray<4xi3>>, %Sel: i1) -> (Out: !hw.array<4xi3>, OutArr: !hw.array<2xarray<4xi3>>, OutInt: i1, OutSlice: !hw.array<3xarray<4xi3>>)
 # CHECK:         %c3_i3 = hw.constant 3 : i3
 # CHECK:         %0 = hw.array_get %In[%c3_i3] {sv.namehint = "In__3"} : !hw.array<5xarray<4xi3>>
@@ -49,7 +45,7 @@ class ComplexMux(Module):
   def create(ports):
     ports.Out = Mux(ports.Sel, ports.In[3].reg().reg(cycles=2), ports.In[1])
 
-    ports.OutArr = array_from_tuple(ports.In[0], ports.In[1])
+    ports.OutArr = Signal.create([ports.In[0], ports.In[1]])
     ports.OutSlice = ports.In[0:3]
 
     ports.OutInt = ports.In[0][0][ports.Sel]
diff --git a/frontends/PyCDE/test/test_ndarray_errors.py b/frontends/PyCDE/test/test_ndarray_errors.py
index 66c7e085f..cba74663c 100644
--- a/frontends/PyCDE/test/test_ndarray_errors.py
+++ b/frontends/PyCDE/test/test_ndarray_errors.py
@@ -34,7 +34,7 @@ class M1(Module):
   @generator
   def build(ports):
     m = NDArray((32), dtype=types.i32, name='m1')
-    # CHECK: ValueError: Width mismatch between provided BitVectorValue (bits33) and target shape (bits32).
+    # CHECK: ValueError: Width mismatch between provided BitVectorValue (Bits<33>) and target shape (Bits<32>).
     m[0] = ports.in1
 
 
@@ -65,5 +65,5 @@ class M1(Module):
   @generator
   def build(ports):
     m = NDArray((32, 32), dtype=types.i1, name='m1')
-    # CHECK: ValueError: Width mismatch between provided BitVectorValue (bits31) and target shape ([32]bits1).
+    # CHECK: ValueError: Width mismatch between provided BitVectorValue (Bits<31>) and target shape (Bits<1>[32]).
     m[0] = ports.in1
diff --git a/frontends/PyCDE/test/polynomial.py b/frontends/PyCDE/test/test_polynomial.py
similarity index 99%
rename from frontends/PyCDE/test/polynomial.py
rename to frontends/PyCDE/test/test_polynomial.py
index 3a5742f05..e57957d71 100755
--- a/frontends/PyCDE/test/polynomial.py
+++ b/frontends/PyCDE/test/test_polynomial.py
@@ -163,4 +163,5 @@ poly.emit_outputs()
 
 # OUTPUT-LABEL:   module PolyComputeForCoeff__62__42__6_
 # OUTPUT:    input  [31:0] x,
-# OUTPUT:    output [31:0] y);
+# OUTPUT:    output [31:0] y
+# OUTPUT:    );
diff --git a/frontends/PyCDE/test/test_pycde_types.py b/frontends/PyCDE/test/test_pycde_types.py
new file mode 100644
index 000000000..cefa57367
--- /dev/null
+++ b/frontends/PyCDE/test/test_pycde_types.py
@@ -0,0 +1,77 @@
+# RUN: %PYTHON% %s | FileCheck %s
+
+from pycde import dim, types, Input, Output, generator, System, Module
+from pycde.types import Bits, StructType, TypeAlias, UInt
+from pycde.testing import unittestmodule
+from pycde.signals import Struct, UIntSignal
+
+# CHECK: [('foo', Bits<1>), ('bar', Bits<13>)]
+st1 = StructType({"foo": types.i1, "bar": types.i13})
+print(st1.fields)
+# CHECK: Bits<1>
+print(st1.foo)
+
+array1 = dim(types.ui6)
+# CHECK: UInt<6>
+print(array1)
+
+array2 = dim(6, 10, 12)
+# CHECK: Bits<6>[10][12]
+print(array2)
+
+int_alias = TypeAlias(Bits(8), "myname1")
+# CHECK: myname1
+print(int_alias)
+assert int_alias == types.int(8, "myname1")
+
+# CHECK: struct { a: Bits<1>, b: SInt<1>}
+struct = types.struct({"a": types.i1, "b": types.si1})
+print(struct)
+
+dim_alias = dim(1, 8, name="myname5")
+
+# CHECK: hw.type_scope @pycde
+# CHECK: hw.typedecl @myname1 : i8
+# CHECK: hw.typedecl @myname5 : !hw.array<8xi1>
+# CHECK-NOT: hw.typedecl @myname1
+# CHECK-NOT: hw.typedecl @myname5
+m = System([]).mod
+TypeAlias.declare_aliases(m)
+TypeAlias.declare_aliases(m)
+print(m)
+
+
+class ExStruct(Struct):
+  a: Bits(4)
+  b: UInt(32)
+
+  def get_b_plus1(self) -> UIntSignal:
+    return self.b + 1
+
+
+print(ExStruct)
+
+
+# CHECK-LABEL:  msft.module @TestStruct {} (%inp1: !hw.typealias<@pycde::@ExStruct, !hw.struct<a: i4, b: ui32>>) -> (out1: ui33, out2: !hw.typealias<@pycde::@ExStruct, !hw.struct<a: i4, b: ui32>>)
+# CHECK-NEXT:     %b = hw.struct_extract %inp1["b"] {sv.namehint = "inp1__b"} : !hw.typealias<@pycde::@ExStruct, !hw.struct<a: i4, b: ui32>>
+# CHECK-NEXT:     [[r0:%.+]] = hwarith.constant 1 : ui1
+# CHECK-NEXT:     [[r1:%.+]] = hwarith.add %b, [[r0]] : (ui32, ui1) -> ui33
+# CHECK-NEXT:     %a = hw.struct_extract %inp1["a"] {sv.namehint = "inp1__a"} : !hw.typealias<@pycde::@ExStruct, !hw.struct<a: i4, b: ui32>>
+# CHECK-NEXT:     %b_0 = hw.struct_extract %inp1["b"] {sv.namehint = "inp1__b"} : !hw.typealias<@pycde::@ExStruct, !hw.struct<a: i4, b: ui32>>
+# CHECK-NEXT:     [[r2:%.+]] = hwarith.constant 1 : ui1
+# CHECK-NEXT:     [[r3:%.+]] = hwarith.add %b_0, [[r2]] : (ui32, ui1) -> ui33
+# CHECK-NEXT:     [[r4:%.+]] = hwarith.cast [[r3]] : (ui33) -> ui32
+# CHECK-NEXT:     [[r5:%.+]] = hw.struct_create (%a, [[r4]]) : !hw.typealias<@pycde::@ExStruct, !hw.struct<a: i4, b: ui32>>
+# CHECK-NEXT:     msft.output [[r1]], [[r5]] : ui33, !hw.typealias<@pycde::@ExStruct, !hw.struct<a: i4, b: ui32>>
+@unittestmodule()
+class TestStruct(Module):
+  inp1 = Input(ExStruct)
+  out1 = Output(UInt(33))
+  out2 = Output(ExStruct)
+
+  @generator
+  def build(self):
+    self.out1 = self.inp1.get_b_plus1()
+    s = ExStruct(a=self.inp1.a, b=self.inp1.get_b_plus1().as_uint(32))
+    assert type(s) is ExStruct._get_value_class()
+    self.out2 = s
diff --git a/frontends/PyCDE/test/pycde_values.py b/frontends/PyCDE/test/test_pycde_values.py
similarity index 98%
rename from frontends/PyCDE/test/pycde_values.py
rename to frontends/PyCDE/test/test_pycde_values.py
index 40e0d7351..102730f65 100644
--- a/frontends/PyCDE/test/pycde_values.py
+++ b/frontends/PyCDE/test/test_pycde_values.py
@@ -2,7 +2,7 @@
 
 from pycde.dialects import comb, hw
 from pycde import dim, generator, types, Input, Output, Module
-from pycde.value import And, Or
+from pycde.signals import And, Or
 from pycde.testing import unittestmodule
 
 
diff --git a/frontends/PyCDE/test/syntactic_sugar.py b/frontends/PyCDE/test/test_syntactic_sugar.py
similarity index 100%
rename from frontends/PyCDE/test/syntactic_sugar.py
rename to frontends/PyCDE/test/test_syntactic_sugar.py
diff --git a/frontends/PyCDE/test/verilog_readablility.py b/frontends/PyCDE/test/test_verilog_readablility.py
similarity index 100%
rename from frontends/PyCDE/test/verilog_readablility.py
rename to frontends/PyCDE/test/test_verilog_readablility.py
diff --git a/frontends/PyCDE/test/test_xrt.py b/frontends/PyCDE/test/test_xrt.py
new file mode 100644
index 000000000..b370907d8
--- /dev/null
+++ b/frontends/PyCDE/test/test_xrt.py
@@ -0,0 +1,81 @@
+# RUN: rm -rf %t
+# RUN: %PYTHON% %s %t 2>&1
+# RUN: ls %t/hw/top.sv
+# RUN: ls %t/hw/Top.sv
+# RUN: ls %t/hw/services.json
+# RUN: ls %t/hw/ESILoopback.tcl
+# RUN: ls %t/hw/filelist.f
+# RUN: ls %t/hw/xsim.tcl
+# RUN: ls %t/hw/xrt_package.tcl
+# RUN: ls %t/runtime/ESILoopback/common.py
+# RUN: ls %t/runtime/ESILoopback/__init__.py
+# RUN: ls %t/runtime/ESILoopback/xrt.py
+# RUN: ls %t/Makefile.xrt
+# RUN: ls %t/xrt.ini
+# RUN: ls %t/xsim.tcl
+# RUN: ls %t/ESILoopback
+# RUN: ls %t/ESILoopback/EsiXrtPython.cpp
+
+# RUN: FileCheck %s --input-file %t/hw/top.sv --check-prefix=TOP
+
+import pycde
+from pycde import Clock, Input, Module, generator, types
+from pycde.bsp import XrtBSP
+
+import sys
+
+
+class Top(Module):
+  clk = Clock(types.i1)
+  rst = Input(types.i1)
+
+  @generator
+  def construct(ports):
+    pass
+
+
+gendir = sys.argv[1]
+s = pycde.System(XrtBSP(Top),
+                 name="ESILoopback",
+                 output_directory=gendir,
+                 sw_api_langs=["python"])
+s.run_passes(debug=True)
+s.compile()
+s.package()
+
+# TOP-LABEL: module top
+# TOP:         #(parameter __INST_HIER = "INSTANTIATE_WITH_INSTANCE_PATH") (
+# TOP:         input         ap_clk,
+# TOP:                       ap_resetn,
+# TOP:                       s_axi_control_AWVALID,
+# TOP:         input  [31:0] s_axi_control_AWADDR,
+# TOP:         input         s_axi_control_WVALID,
+# TOP:         input  [31:0] s_axi_control_WDATA,
+# TOP:         input  [3:0]  s_axi_control_WSTRB,
+# TOP:         input         s_axi_control_ARVALID,
+# TOP:         input  [23:0] s_axi_control_ARADDR,
+# TOP:         input         s_axi_control_RREADY,
+# TOP:                       s_axi_control_BREADY,
+# TOP:         output        s_axi_control_AWREADY,
+# TOP:                       s_axi_control_WREADY,
+# TOP:                       s_axi_control_ARREADY,
+# TOP:                       s_axi_control_RVALID,
+# TOP:         output [31:0] s_axi_control_RDATA,
+# TOP:         output [1:0]  s_axi_control_RRESP,
+# TOP:         output        s_axi_control_BVALID,
+# TOP:         output [1:0]  s_axi_control_BRESP
+# TOP:         Top #(
+# TOP:           .__INST_HIER({__INST_HIER, ".Top"})
+# TOP:         ) Top (
+# TOP:           .clk (ap_clk),
+# TOP:           .rst (~ap_resetn)
+# TOP:         );
+# TOP:         assign s_axi_control_AWREADY = 1'h0;
+# TOP:         assign s_axi_control_WREADY = 1'h0;
+# TOP:         assign s_axi_control_ARREADY = 1'h0;
+# TOP:         assign s_axi_control_RVALID = 1'h0;
+# TOP:         assign s_axi_control_RDATA = 32'h0;
+# TOP:         assign s_axi_control_RRESP = 2'h0;
+# TOP:         assign s_axi_control_BVALID = 1'h0;
+# TOP:         assign s_axi_control_BRESP = 2'h0;
+# TOP:       endmodule
diff --git a/include/circt/Dialect/Calyx/Calyx.td b/include/circt/Dialect/Calyx/Calyx.td
index bf2faca8a..947b53ad7 100644
--- a/include/circt/Dialect/Calyx/Calyx.td
+++ b/include/circt/Dialect/Calyx/Calyx.td
@@ -39,6 +39,7 @@ def CalyxDialect : Dialect {
   // Depends on the HWDialect to support external primitives using hw.module.extern
   let dependentDialects = ["circt::hw::HWDialect"];
   let cppNamespace = "::circt::calyx";
+  let useFoldAPI = kEmitFoldAdaptorFolder;
 }
 
 class SameTypeConstraint<string lhs, string rhs>
diff --git a/include/circt/Dialect/Calyx/CalyxLoweringUtils.h b/include/circt/Dialect/Calyx/CalyxLoweringUtils.h
index 8d72b86e4..b14cc6259 100644
--- a/include/circt/Dialect/Calyx/CalyxLoweringUtils.h
+++ b/include/circt/Dialect/Calyx/CalyxLoweringUtils.h
@@ -509,15 +509,9 @@ private:
   PatternApplicationState &patternState;
 };
 
-struct ModuleOpConversion : public OpRewritePattern<mlir::ModuleOp> {
-  ModuleOpConversion(MLIRContext *context, StringRef topLevelFunction);
-
-  LogicalResult matchAndRewrite(mlir::ModuleOp moduleOp,
-                                PatternRewriter &rewriter) const override;
-
-private:
-  StringRef topLevelFunction;
-};
+/// Helper to update the top-level ModuleOp to set the entrypoing function.
+LogicalResult applyModuleOpConversion(mlir::ModuleOp,
+                                      StringRef topLevelFunction);
 
 /// FuncOpPartialLoweringPatterns are patterns which intend to match on FuncOps
 /// and then perform their own walking of the IR.
diff --git a/include/circt/Dialect/Calyx/CalyxStructure.td b/include/circt/Dialect/Calyx/CalyxStructure.td
index 4a2e4e938..b8e39019e 100644
--- a/include/circt/Dialect/Calyx/CalyxStructure.td
+++ b/include/circt/Dialect/Calyx/CalyxStructure.td
@@ -339,7 +339,7 @@ def PrimitiveOp : CalyxCell<"primitive", [
   let results = (outs Variadic<AnyType>:$results);
 
   let assemblyFormat = [{
-    $sym_name `of` $primitiveName``custom<ParameterList>($parameters) attr-dict (`:` qualified(type($results))^)?
+    $sym_name `of` $primitiveName `` custom<ParameterList>($parameters) attr-dict (`:` qualified(type($results))^)?
   }];
 }
 
diff --git a/include/circt/Dialect/Comb/Comb.td b/include/circt/Dialect/Comb/Comb.td
index 8f4d1d6f1..c6a21eb86 100644
--- a/include/circt/Dialect/Comb/Comb.td
+++ b/include/circt/Dialect/Comb/Comb.td
@@ -27,6 +27,7 @@ def CombDialect : Dialect {
     representation of combinational logic outside of a particular use-case.
   }];
   let hasConstantMaterializer = 1;
+  let useFoldAPI = kEmitFoldAdaptorFolder;
   let cppNamespace = "::circt::comb";
 }
 
diff --git a/include/circt/Dialect/ESI/ESI.td b/include/circt/Dialect/ESI/ESI.td
index 335e33fe8..6a3fb8dad 100644
--- a/include/circt/Dialect/ESI/ESI.td
+++ b/include/circt/Dialect/ESI/ESI.td
@@ -25,6 +25,7 @@ def ESI_Dialect : Dialect {
 
   let hasConstantMaterializer = 1;
   let useDefaultTypePrinterParser = 1;
+  let useFoldAPI = kEmitFoldAdaptorFolder;
 
   let extraClassDeclaration = [{
     /// Register all ESI types.
@@ -54,5 +55,6 @@ include "circt/Dialect/ESI/ESIOps.td"
 include "circt/Dialect/ESI/ESIServices.td"
 include "circt/Dialect/ESI/ESIStdServices.td"
 include "circt/Dialect/ESI/ESIPasses.td"
+include "circt/Dialect/ESI/ESIStructure.td"
 
 #endif // ESI_TD
diff --git a/include/circt/Dialect/ESI/ESIStructure.td b/include/circt/Dialect/ESI/ESIStructure.td
new file mode 100644
index 000000000..0d71340dd
--- /dev/null
+++ b/include/circt/Dialect/ESI/ESIStructure.td
@@ -0,0 +1,38 @@
+//===- ESIStructure.td - ESI modules ---------------------*- tablegen -*---===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// ESI system and other ESI structural components.
+//
+//===----------------------------------------------------------------------===//
+
+include "mlir/IR/OpBase.td"
+
+def ESIPureModuleOp : ESI_Op<"pure_module",
+      [Symbol, NoTerminator, RegionKindInterface, NoRegionArguments,
+       SingleBlock, HasParent<"mlir::ModuleOp">]> {
+  let summary = "ESI pure module";
+  let description = [{
+    A module containing only ESI channels and modules with only ESI ports. All
+    non-local connectivity is done through ESI services. If this module is the
+    top level in the design, then the design's actual top level ports are
+    defined by a BSP.
+
+    Useful on its own for simulation and BSPs which don't define a top-level.
+  }];
+  let arguments = (ins SymbolNameAttr:$sym_name);
+  let results = (outs); 
+  let regions = (region SizedRegion<1>:$body);
+
+  let assemblyFormat = [{ $sym_name attr-dict-with-keyword $body }];
+  let hasVerifier = 1;
+
+  let extraClassDeclaration = [{
+    // Implement RegionKindInterface.
+    static RegionKind getRegionKind(unsigned index) { return RegionKind::Graph;}
+  }];
+}
diff --git a/include/circt/Dialect/FIRRTL/AnnotationDetails.h b/include/circt/Dialect/FIRRTL/AnnotationDetails.h
index 68bc46a63..af7e2e12a 100644
--- a/include/circt/Dialect/FIRRTL/AnnotationDetails.h
+++ b/include/circt/Dialect/FIRRTL/AnnotationDetails.h
@@ -197,6 +197,18 @@ constexpr const char *addSeqMemPortAnnoClass =
 constexpr const char *addSeqMemPortsFileAnnoClass =
     "sifive.enterprise.firrtl.AddSeqMemPortsFileAnnotation";
 
+// Memory file loading annotations.
+constexpr const char *loadMemoryFromFileAnnoClass =
+    "firrtl.annotations.LoadMemoryAnnotation";
+constexpr const char *loadMemoryFromFileInlineAnnoClass =
+    "firrtl.annotations.MemoryFileInlineAnnotation";
+
+// WiringTransform Annotations
+constexpr const char *wiringSinkAnnoClass =
+    "firrtl.passes.wiring.SinkAnnotation";
+constexpr const char *wiringSourceAnnoClass =
+    "firrtl.passes.wiring.SourceAnnotation";
+
 } // namespace firrtl
 } // namespace circt
 
diff --git a/include/circt/Dialect/FIRRTL/CHIRRTL.td b/include/circt/Dialect/FIRRTL/CHIRRTL.td
index 34cf7bcb1..a8af58811 100644
--- a/include/circt/Dialect/FIRRTL/CHIRRTL.td
+++ b/include/circt/Dialect/FIRRTL/CHIRRTL.td
@@ -37,6 +37,7 @@ def CHIRRTLDialect : Dialect {
   let dependentDialects = ["circt::firrtl::FIRRTLDialect"];
 
   let useDefaultTypePrinterParser = 1;
+  let useFoldAPI = kEmitFoldAdaptorFolder;
 }
 
 //===----------------------------------------------------------------------===//
@@ -109,14 +110,18 @@ def CombMemOp : CHIRRTLOp<"combmem", [HasCustomSSAName, FNamableOp]> {
     write latency of 1 and a read latency of 0.
   }];
   let arguments = (ins StrAttr:$name, NameKindAttr:$nameKind,
-                       AnnotationArrayAttr:$annotations, OptionalAttr<InnerSymAttr>:$inner_sym);
+                       AnnotationArrayAttr:$annotations,
+                       OptionalAttr<InnerSymAttr>:$inner_sym,
+                       OptionalAttr<MemoryInitAttr>:$init);
   let results = (outs CMemoryType:$result);
-  let assemblyFormat = [{(`sym` $inner_sym^)? custom<NameKind>($nameKind)
-                         custom<CombMemOp>(attr-dict) `:` qualified(type($result))}];
+  let assemblyFormat = [{(`sym` $inner_sym^)? `` custom<NameKind>($nameKind)
+                         `` custom<CombMemOp>(attr-dict) `:` qualified(type($result))}];
   let builders = [
     OpBuilder<(ins "firrtl::FIRRTLBaseType":$elementType, "uint64_t":$numElements,
                    "mlir::StringRef":$name, "firrtl::NameKindEnum":$nameKind,
-                   "ArrayAttr":$annotations, CArg<"StringAttr", "StringAttr()">:$inner_sym)>
+                   "ArrayAttr":$annotations,
+                   CArg<"StringAttr", "StringAttr()">:$inner_sym,
+                   CArg<"firrtl::MemoryInitAttr", "firrtl::MemoryInitAttr{}">:$init)>
   ];
 }
 
@@ -128,15 +133,17 @@ def SeqMemOp : CHIRRTLOp<"seqmem", [HasCustomSSAName, FNamableOp]> {
   }];
   let arguments = (ins RUWAttr:$ruw, StrAttr:$name, NameKindAttr:$nameKind,
                        AnnotationArrayAttr:$annotations,
-                       OptionalAttr<InnerSymAttr>:$inner_sym);
+                       OptionalAttr<InnerSymAttr>:$inner_sym,
+                       OptionalAttr<MemoryInitAttr>:$init);
   let results = (outs CMemoryType:$result);
-  let assemblyFormat = [{(`sym` $inner_sym^)? custom<NameKind>($nameKind) $ruw
+  let assemblyFormat = [{(`sym` $inner_sym^)? `` custom<NameKind>($nameKind) $ruw
                          custom<SeqMemOp>(attr-dict) `:` qualified(type($result))}];
   let builders = [
     OpBuilder<(ins "firrtl::FIRRTLBaseType":$elementType, "uint64_t":$numElements,
                    "RUWAttr":$ruw, "mlir::StringRef":$name,
                    "firrtl::NameKindEnum":$nameKind, "ArrayAttr":$annotations,
-                   CArg<"StringAttr", "StringAttr()">:$inner_sym)>
+                   CArg<"StringAttr", "StringAttr()">:$inner_sym,
+                   CArg<"firrtl::MemoryInitAttr", "firrtl::MemoryInitAttr{}">:$init)>
   ];
 }
 
@@ -161,7 +168,7 @@ def MemoryPortOp : CHIRRTLOp<"memoryport", [InferTypeOpInterface,
   let results = (outs FIRRTLBaseType:$data, CMemoryPortType:$port);
 
   let assemblyFormat = [{
-    $direction $memory custom<MemoryPortOp>(attr-dict) `:`
+    $direction $memory `` custom<MemoryPortOp>(attr-dict) `:`
        functional-type(operands, results)
   }];
 
diff --git a/include/circt/Dialect/FIRRTL/FIRRTLAnnotationHelper.h b/include/circt/Dialect/FIRRTL/FIRRTLAnnotationHelper.h
index 58b8a46d1..9301752a8 100644
--- a/include/circt/Dialect/FIRRTL/FIRRTLAnnotationHelper.h
+++ b/include/circt/Dialect/FIRRTL/FIRRTLAnnotationHelper.h
@@ -196,6 +196,7 @@ bool isAnnoClassLowered(StringRef className);
 /// A representation of a deferred Wiring problem consisting of a source that
 /// should be connected to a sink.
 struct WiringProblem {
+  enum class RefTypeUsage { Prefer, Never };
 
   /// A source to wire from.
   Value source;
@@ -206,6 +207,19 @@ struct WiringProblem {
   /// A base name to use when generating new signals associated with this wiring
   /// problem.
   std::string newNameHint;
+
+  /// The usage of ref type ports when solving this problem.
+  RefTypeUsage refTypeUsage;
+};
+
+/// A representation of a legacy Wiring problem consisting of a signal source
+/// that should be connected to one or many sinks.
+struct LegacyWiringProblem {
+  /// A source to wire from.
+  Value source;
+
+  /// Sink(s) to wire to.
+  SmallVector<Value> sinks;
 };
 
 /// A store of pending modifications to a FIRRTL module associated with solving
@@ -247,6 +261,9 @@ struct ApplyState {
   InstancePathCache &instancePathCache;
   DenseMap<Attribute, FlatSymbolRefAttr> instPathToNLAMap;
   size_t numReusedHierPaths = 0;
+
+  DenseSet<InstanceOp> wiringProblemInstRefs;
+  DenseMap<StringAttr, LegacyWiringProblem> legacyWiringProblems;
   SmallVector<WiringProblem> wiringProblems;
 
   ModuleNamespace &getNamespace(FModuleLike module) {
@@ -281,6 +298,9 @@ LogicalResult applyOMIR(const AnnoPathValue &target, DictionaryAttr anno,
 LogicalResult applyTraceName(const AnnoPathValue &target, DictionaryAttr anno,
                              ApplyState &state);
 
+LogicalResult applyWiring(const AnnoPathValue &target, DictionaryAttr anno,
+                          ApplyState &state);
+
 /// Implements the same behavior as DictionaryAttr::getAs<A> to return the
 /// value of a specific type associated with a key in a dictionary. However,
 /// this is specialized to print a useful error message, specific to custom
@@ -332,25 +352,6 @@ InstanceOp addPortsToModule(
     llvm::function_ref<ModuleNamespace &(FModuleLike)> getNamespace,
     CircuitTargetCache *targetCaches = nullptr);
 
-/// Add a port to each instance on the path `instancePath` and forward the
-/// `fromVal` through them. It returns the port added to the last module on the
-/// given path. The module referenced by the first instance on the path must
-/// contain `fromVal`.
-Value borePortsOnPath(
-    SmallVector<InstanceOp> &instancePath, FModuleOp lcaModule, Value fromVal,
-    StringRef newNameHint, InstancePathCache &instancePathcache,
-    llvm::function_ref<ModuleNamespace &(FModuleLike)> getNamespace,
-    CircuitTargetCache *targetCachesInstancePathCache);
-
-/// Find the lowest-common-ancestor `lcaModule`, between `srcTarget` and
-/// `dstTarget`, and set `pathFromSrcToWire` with the path between them through
-/// the `lcaModule`. The assumption here is that the srcTarget and dstTarget can
-/// be uniquely identified. Either the instnaces field of their AnnoPathValue is
-/// set or there exists a single path from Top.
-LogicalResult findLCAandSetPath(AnnoPathValue &srcTarget,
-                                AnnoPathValue &dstTarget,
-                                SmallVector<InstanceOp> &pathFromSrcToWire,
-                                FModuleOp &lcaModule, ApplyState &state);
 } // namespace firrtl
 } // namespace circt
 
diff --git a/include/circt/Dialect/FIRRTL/FIRRTLAttributes.td b/include/circt/Dialect/FIRRTL/FIRRTLAttributes.td
index b033ea1b7..e22db58e9 100644
--- a/include/circt/Dialect/FIRRTL/FIRRTLAttributes.td
+++ b/include/circt/Dialect/FIRRTL/FIRRTLAttributes.td
@@ -171,4 +171,22 @@ def ParamDeclAttr : AttrDef<FIRRTLDialect, "ParamDecl", [TypedAttrInterface]> {
 def ParamDeclArrayAttr
   : TypedArrayAttrBase<ParamDeclAttr, "parameter array attribute">;
 
+/// An attribute holding information about memory initialization.
+def MemoryInitAttr : AttrDef<FIRRTLDialect, "MemoryInit"> {
+  let mnemonic = "meminit";
+  let summary = "Information about the initial state of a memory";
+  let description = [{
+    This attribute captures information about the external initialization of a
+    memory.  This is the FIRRTL Dialect representation of both
+    "firrtl.annotations.LoadMemoryFromFile" and
+    "firrtl.annotations.MemoryFileInlineAnnotation".
+  }];
+  let parameters = (
+    ins "::mlir::StringAttr":$filename,
+        "::mlir::BoolAttr":$isBinary,
+        "::mlir::BoolAttr":$isInline
+  );
+ let assemblyFormat = "`<` $filename `,` $isBinary `,` $isInline `>`";
+}
+
 #endif // CIRCT_DIALECT_FIRRTL_FIRRTLATTRIBUTES_TD
diff --git a/include/circt/Dialect/FIRRTL/FIRRTLDeclarations.td b/include/circt/Dialect/FIRRTL/FIRRTLDeclarations.td
index 4be2ba2e9..a7c10f09a 100644
--- a/include/circt/Dialect/FIRRTL/FIRRTLDeclarations.td
+++ b/include/circt/Dialect/FIRRTL/FIRRTLDeclarations.td
@@ -130,12 +130,13 @@ def MemOp : ReferableDeclOp<"mem"> {
          AnnotationArrayAttr:$annotations,
          PortAnnotationsAttr:$portAnnotations,
          OptionalAttr<InnerSymAttr>:$inner_sym,
-         OptionalAttr<UI32Attr>:$groupID);
+         OptionalAttr<UI32Attr>:$groupID,
+         OptionalAttr<MemoryInitAttr>:$init);
   let results = (outs Variadic<FIRRTLType>:$results);
 
   let assemblyFormat = [{
-    (`sym` $inner_sym^)? custom<NameKind>($nameKind)
-    $ruw custom<MemOp>(attr-dict) `:` qualified(type($results))
+    (`sym` $inner_sym^)? `` custom<NameKind>($nameKind)
+    $ruw `` custom<MemOp>(attr-dict) `:` qualified(type($results))
   }];
 
   let builders = [
@@ -254,8 +255,8 @@ def NodeOp : ReferableDeclOp<"node",
   ];
 
   let assemblyFormat = [{
-    (`sym` $inner_sym^)? custom<NameKind>($nameKind)
-    $input custom<ImplicitSSAName>(attr-dict) `:` qualified(type($input))
+    (`sym` $inner_sym^)? `` custom<NameKind>($nameKind)
+    $input `` custom<ImplicitSSAName>(attr-dict) `:` qualified(type($input))
   }];
 
   let hasCanonicalizer = true;
@@ -298,8 +299,8 @@ def RegOp : ReferableDeclOp<"reg"> {
   ];
 
   let assemblyFormat = [{
-    (`sym` $inner_sym^)? custom<NameKind>($nameKind)
-    operands custom<ImplicitSSAName>(attr-dict) `:` qualified(type($result))
+    (`sym` $inner_sym^)? `` custom<NameKind>($nameKind)
+    operands `` custom<ImplicitSSAName>(attr-dict) `:` qualified(type($result))
   }];
   let hasCanonicalizeMethod = true;
 }
@@ -344,8 +345,8 @@ def RegResetOp : ReferableDeclOp<"regreset"> {
   ];
 
   let assemblyFormat = [{
-    (`sym` $inner_sym^)? custom<NameKind>($nameKind)
-    operands custom<ImplicitSSAName>(attr-dict)
+    (`sym` $inner_sym^)? `` custom<NameKind>($nameKind)
+    operands `` custom<ImplicitSSAName>(attr-dict)
     `:` qualified(type($resetSignal)) `,` qualified(type($resetValue)) `,` qualified(type($result))
   }];
 
@@ -388,8 +389,9 @@ def WireOp : ReferableDeclOp<"wire"> {
   ];
 
   let assemblyFormat = [{
-    (`sym` $inner_sym^)? custom<NameKind>($nameKind)
-    custom<ImplicitSSAName>(attr-dict) `:` qualified(type($result))
+    (`sym` $inner_sym^)? `` custom<NameKind>($nameKind) ``
+    custom<ImplicitSSAName>(attr-dict) `:`
+    qualified(type($result))
   }];
 }
 
diff --git a/include/circt/Dialect/FIRRTL/FIRRTLDialect.td b/include/circt/Dialect/FIRRTL/FIRRTLDialect.td
index 650d416ba..c62765dc9 100644
--- a/include/circt/Dialect/FIRRTL/FIRRTLDialect.td
+++ b/include/circt/Dialect/FIRRTL/FIRRTLDialect.td
@@ -33,6 +33,7 @@ def FIRRTLDialect : Dialect {
   let hasConstantMaterializer = 1;
   let useDefaultTypePrinterParser = 0;
   let useDefaultAttributePrinterParser = 1;
+  let useFoldAPI = kEmitFoldAdaptorFolder;
 
   let dependentDialects = [
     "circt::hw::HWDialect"
diff --git a/include/circt/Dialect/FIRRTL/FIRRTLOpInterfaces.td b/include/circt/Dialect/FIRRTL/FIRRTLOpInterfaces.td
index 8f0a521b9..5401e8021 100644
--- a/include/circt/Dialect/FIRRTL/FIRRTLOpInterfaces.td
+++ b/include/circt/Dialect/FIRRTL/FIRRTLOpInterfaces.td
@@ -213,6 +213,36 @@ def FModuleLike : OpInterface<"FModuleLike"> {
         symbol));
     }]>,
 
+    //===------------------------------------------------------------------===//
+    // Port Locations
+    //===------------------------------------------------------------------===//
+
+    InterfaceMethod<"Get the port locations attribute",
+    "ArrayAttr", "getPortLocationsAttr", (ins), [{}],
+    /*defaultImplementation=*/[{
+      return $_op->template
+        getAttrOfType<ArrayAttr>(FModuleLike::getPortLocationsAttrName());
+    }]>,
+
+    InterfaceMethod<"Get the port locations attribute",
+    "ArrayRef<Attribute>", "getPortLocations", (ins), [{}],
+    /*defaultImplementation=*/[{
+      return $_op.getPortLocationsAttr().getValue();
+    }]>,
+
+    InterfaceMethod<"Get a port's location attribute",
+    "LocationAttr", "getPortLocationAttr", (ins "size_t":$portIndex), [{}],
+    /*defaultImplementation=*/[{
+      return $_op.getPortLocationsAttr()[portIndex].
+        template cast<LocationAttr>();
+    }]>,
+
+    InterfaceMethod<"Get a port's location",
+    "Location", "getPortLocation", (ins "size_t":$portIndex), [{}],
+    /*defaultImplementation=*/[{
+      return $_op.getPortLocationAttr(portIndex);
+    }]>,
+
     //===------------------------------------------------------------------===//
     // All Port Information
     //===------------------------------------------------------------------===//
@@ -255,6 +285,11 @@ def FModuleLike : OpInterface<"FModuleLike"> {
       return "portSyms";
     }
 
+    /// Get the attribute name for port locations.
+    static StringRef getPortLocationsAttrName() {
+      return "portLocations";
+    }
+
     /// Replace NULL entries with invalid sym and clear array if all elements
     /// are invalid.
     static void fixupPortSymsArray(SmallVectorImpl<Attribute> &syms,
diff --git a/include/circt/Dialect/FIRRTL/FIRRTLOps.h b/include/circt/Dialect/FIRRTL/FIRRTLOps.h
index 5d98b5d7d..7b964c587 100644
--- a/include/circt/Dialect/FIRRTL/FIRRTLOps.h
+++ b/include/circt/Dialect/FIRRTL/FIRRTLOps.h
@@ -188,6 +188,7 @@ struct FirMemory {
   StringAttr modName;
   bool isMasked;
   uint32_t groupID;
+  MemoryInitAttr init;
 
   // Location is carried along but not considered part of the identity of this.
   Location loc;
@@ -198,11 +199,15 @@ struct FirMemory {
   Operation *op = nullptr;
 
   std::tuple<size_t, size_t, size_t, size_t, size_t, size_t, size_t, size_t,
-             size_t, hw::WUW, SmallVector<int32_t>, uint32_t>
+             size_t, hw::WUW, SmallVector<int32_t>, uint32_t, StringRef, bool,
+             bool>
   getTuple() const {
-    return std::tie(numReadPorts, numWritePorts, numReadWritePorts, dataWidth,
-                    depth, readLatency, writeLatency, maskBits, readUnderWrite,
-                    writeUnderWrite, writeClockIDs, groupID);
+    return std::make_tuple(
+        numReadPorts, numWritePorts, numReadWritePorts, dataWidth, depth,
+        readLatency, writeLatency, maskBits, readUnderWrite, writeUnderWrite,
+        writeClockIDs, groupID, init ? init.getFilename().getValue() : "",
+        init ? init.getIsBinary().getValue() : false,
+        init ? init.getIsInline().getValue() : false);
   }
   bool operator<(const FirMemory &rhs) const {
     return getTuple() < rhs.getTuple();
diff --git a/include/circt/Dialect/FIRRTL/FIRRTLStatements.td b/include/circt/Dialect/FIRRTL/FIRRTLStatements.td
index 369a27d3b..1330470f2 100644
--- a/include/circt/Dialect/FIRRTL/FIRRTLStatements.td
+++ b/include/circt/Dialect/FIRRTL/FIRRTLStatements.td
@@ -77,7 +77,7 @@ def PrintFOp : FIRRTLOp<"printf"> {
   let results = (outs);
 
   let assemblyFormat = [{
-    $clock `,` $cond `,` $formatString custom<PrintfAttrs>(attr-dict)
+    $clock `,` $cond `,` $formatString `` custom<PrintfAttrs>(attr-dict) ` `
     (`(` $substitutions^ `)` `:` qualified(type($substitutions)))?
   }];
 }
@@ -106,7 +106,7 @@ def StopOp : FIRRTLOp<"stop"> {
                        StrAttr:$name);
   let results = (outs);
 
-  let assemblyFormat = "$clock `,` $cond `,` $exitCode custom<StopAttrs>(attr-dict)";
+  let assemblyFormat = "$clock `,` $cond `,` $exitCode `` custom<StopAttrs>(attr-dict)";
 }
 
 class VerifOp<string mnemonic, list<Trait> traits = []> :
diff --git a/include/circt/Dialect/FIRRTL/FIRRTLStructure.td b/include/circt/Dialect/FIRRTL/FIRRTLStructure.td
index 2e21bf610..cb4b547e6 100644
--- a/include/circt/Dialect/FIRRTL/FIRRTLStructure.td
+++ b/include/circt/Dialect/FIRRTL/FIRRTLStructure.td
@@ -56,7 +56,7 @@ def CircuitOp : FIRRTLOp<"circuit",
     FModuleLike getMainModule(mlir::SymbolTable* symtbl = nullptr);
   }];
 
-  let assemblyFormat = "$name custom<CircuitOpAttrs>(attr-dict) $body";
+  let assemblyFormat = "$name `` custom<CircuitOpAttrs>(attr-dict) $body";
   let hasRegionVerifier = 1;
 }
 
@@ -102,6 +102,7 @@ def FModuleOp : FIRRTLModuleLike<"module", [SingleBlock, NoTerminator]> {
 
   let skipDefaultBuilders = 1;
   let hasCustomAssemblyFormat = 1;
+  let hasVerifier = 1;
   let builders = [
     OpBuilder<(ins "StringAttr":$name, "ArrayRef<PortInfo>":$ports,
                CArg<"ArrayAttr","ArrayAttr()">:$annotations)>
diff --git a/include/circt/Dialect/FSM/FSM.td b/include/circt/Dialect/FSM/FSM.td
index f288fa4bb..de3a70891 100644
--- a/include/circt/Dialect/FSM/FSM.td
+++ b/include/circt/Dialect/FSM/FSM.td
@@ -24,6 +24,7 @@ def FSMDialect : Dialect {
   }];
 
   let useDefaultTypePrinterParser = 1;
+  let useFoldAPI = kEmitFoldAdaptorFolder;
 }
 
 // Base class for the types in this dialect.
diff --git a/include/circt/Dialect/HW/HWAttributesNaming.td b/include/circt/Dialect/HW/HWAttributesNaming.td
index 32d0e1150..e54de58c9 100644
--- a/include/circt/Dialect/HW/HWAttributesNaming.td
+++ b/include/circt/Dialect/HW/HWAttributesNaming.td
@@ -15,9 +15,8 @@
 
 include "circt/Dialect/HW/HWDialect.td"
 include "mlir/IR/AttrTypeBase.td"
-include "mlir/IR/SubElementInterfaces.td"
 
-def InnerRefAttr : AttrDef<HWDialect, "InnerRef", [SubElementAttrInterface]> {
+def InnerRefAttr : AttrDef<HWDialect, "InnerRef"> {
   let summary = "Refer to a name inside a module";
   let description = [{
     This works like a symbol reference, but to a name inside a module.
@@ -42,14 +41,6 @@ def InnerRefAttr : AttrDef<HWDialect, "InnerRef", [SubElementAttrInterface]> {
                                          mlir::StringAttr symName,
                                          mlir::StringAttr moduleName);
 
-    /// Recursively traverse the sub-attribute.
-    void walkImmediateSubElements(
-        llvm::function_ref<void(mlir::Attribute)> walkAttrsFn,
-        llvm::function_ref<void(mlir::Type)> walkTypesFn) {
-      walkAttrsFn(getModuleRef());
-      walkAttrsFn(getName());
-    }
-
     /// Return the name of the referenced module.
     mlir::StringAttr getModule() const { return getModuleRef().getAttr(); }
   }];
diff --git a/include/circt/Dialect/HW/HWDialect.td b/include/circt/Dialect/HW/HWDialect.td
index 37f724fb0..dc5162cbd 100644
--- a/include/circt/Dialect/HW/HWDialect.td
+++ b/include/circt/Dialect/HW/HWDialect.td
@@ -27,6 +27,7 @@ def HWDialect : Dialect {
 
   let hasConstantMaterializer = 1;
   let useDefaultTypePrinterParser = 1;
+  let useFoldAPI = kEmitFoldAdaptorFolder;
 
   let extraClassDeclaration = [{
     /// Register all HW types.
diff --git a/include/circt/Dialect/HW/HWOpInterfaces.td b/include/circt/Dialect/HW/HWOpInterfaces.td
index c1d6096a0..39b41a5e8 100644
--- a/include/circt/Dialect/HW/HWOpInterfaces.td
+++ b/include/circt/Dialect/HW/HWOpInterfaces.td
@@ -71,7 +71,7 @@ def HWMutableModuleLike : OpInterface<"HWMutableModuleLike"> {
       return $_op->template getAttrOfType<ArrayAttr>("resultNames").size();
     }]>,
 
-    InterfaceMethod<"Return the names of the inputs this module",
+    InterfaceMethod<"Return the names of the inputs to this module",
     "mlir::ArrayAttr", "getArgNames", (ins),
     /*methodBody=*/[{}],
     /*defaultImplementation=*/[{
@@ -85,6 +85,20 @@ def HWMutableModuleLike : OpInterface<"HWMutableModuleLike"> {
       return $_op->template getAttrOfType<ArrayAttr>("resultNames");
     }]>,
 
+    InterfaceMethod<"Return the locations of the inputs to this module",
+    "mlir::ArrayAttr", "getArgLocs", (ins),
+    /*methodBody=*/[{}],
+    /*defaultImplementation=*/[{
+      return $_op->template getAttrOfType<ArrayAttr>("argLocs");
+    }]>,
+
+    InterfaceMethod<"Return the locations of the outputs of this module",
+    "mlir::ArrayAttr", "getResultLocs", (ins),
+    /*methodBody=*/[{}],
+    /*defaultImplementation=*/[{
+      return $_op->template getAttrOfType<ArrayAttr>("resultLocs");
+    }]>,
+
     /// Insert and remove input and output ports of this module. Does not modify
     /// the block arguments of the module body. The insertion and removal
     /// indices must be in ascending order. The indices refer to the port
diff --git a/include/circt/Dialect/HW/HWOps.h b/include/circt/Dialect/HW/HWOps.h
index de715d838..89aa08cd8 100644
--- a/include/circt/Dialect/HW/HWOps.h
+++ b/include/circt/Dialect/HW/HWOps.h
@@ -54,6 +54,7 @@ struct PortInfo {
 
   /// The optional symbol for this port.
   InnerSymAttr sym = {};
+  LocationAttr loc = {};
 
   StringRef getName() const { return name.getValue(); }
   bool isInput() const { return direction == PortDirection::INPUT; }
@@ -152,7 +153,7 @@ inline StringRef getVerilogModuleName(Operation *module) {
 /// Return the port name for the specified argument or result.  These can only
 /// return a null StringAttr when the IR is invalid.
 StringAttr getModuleArgumentNameAttr(Operation *module, size_t argNo);
-StringAttr getModuleResultNameAttr(Operation *module, size_t argNo);
+StringAttr getModuleResultNameAttr(Operation *module, size_t resultNo);
 
 static inline StringRef getModuleArgumentName(Operation *module, size_t argNo) {
   auto attr = getModuleArgumentNameAttr(module, argNo);
@@ -164,12 +165,19 @@ static inline StringRef getModuleResultName(Operation *module,
   return attr ? attr.getValue() : StringRef();
 }
 
+/// Return the port location for the specified argument or result.  These can
+/// only return a null LocationAttr when the IR is invalid.
+LocationAttr getModuleArgumentLocAttr(Operation *module, size_t argNo);
+LocationAttr getModuleResultLocAttr(Operation *module, size_t resultNo);
+
 // Index width should be exactly clog2 (size of array), or either 0 or 1 if the
 // array is a singleton.
 bool isValidIndexBitWidth(Value index, Value array);
 
 void setModuleArgumentNames(Operation *module, ArrayRef<Attribute> names);
 void setModuleResultNames(Operation *module, ArrayRef<Attribute> names);
+void setModuleArgumentLocs(Operation *module, ArrayRef<Attribute> locs);
+void setModuleResultLocs(Operation *module, ArrayRef<Attribute> locs);
 
 /// Return true if the specified operation is a combinational logic op.
 bool isCombinational(Operation *op);
diff --git a/include/circt/Dialect/HW/HWStructure.td b/include/circt/Dialect/HW/HWStructure.td
index 0ba22415d..a944cde47 100644
--- a/include/circt/Dialect/HW/HWStructure.td
+++ b/include/circt/Dialect/HW/HWStructure.td
@@ -82,7 +82,10 @@ def HWModuleOp : HWModuleOpBase<"module",
   let arguments = (ins TypeAttrOf<FunctionType>:$function_type,
                        OptionalAttr<DictArrayAttr>:$arg_attrs,
                        OptionalAttr<DictArrayAttr>:$res_attrs,
-                       StrArrayAttr:$argNames, StrArrayAttr:$resultNames,
+                       StrArrayAttr:$argNames,
+                       StrArrayAttr:$resultNames,
+                       LocationArrayAttr:$argLocs,
+                       LocationArrayAttr:$resultLocs,
                        ParamDeclArrayAttr:$parameters,
                        StrAttr:$comment);
   let results = (outs);
diff --git a/include/circt/Dialect/HW/ModuleImplementation.h b/include/circt/Dialect/HW/ModuleImplementation.h
index aa44ab4b1..267231238 100644
--- a/include/circt/Dialect/HW/ModuleImplementation.h
+++ b/include/circt/Dialect/HW/ModuleImplementation.h
@@ -30,16 +30,12 @@ StringAttr getPortNameAttr(MLIRContext *context, StringRef name);
 /// This is a variant of mlir::parseFunctionSignature that allows names on
 /// result arguments.
 ParseResult parseModuleFunctionSignature(
-    OpAsmParser &parser, SmallVectorImpl<OpAsmParser::Argument> &args,
-    bool &isVariadic, SmallVectorImpl<Type> &resultTypes,
+    OpAsmParser &parser, bool &isVariadic,
+    SmallVectorImpl<OpAsmParser::Argument> &args,
+    SmallVectorImpl<Attribute> &argNames, SmallVectorImpl<Attribute> &argLocs,
+    SmallVectorImpl<Attribute> &resultNames,
     SmallVectorImpl<DictionaryAttr> &resultAttrs,
-    SmallVectorImpl<Attribute> &resultNames);
-
-/// Parse a function result list with named results.
-ParseResult
-parseFunctionResultList(OpAsmParser &parser, SmallVectorImpl<Type> &resultTypes,
-                        SmallVectorImpl<DictionaryAttr> &resultAttrs,
-                        SmallVectorImpl<Attribute> &resultNames);
+    SmallVectorImpl<Attribute> &resultLocs, TypeAttr &type);
 
 /// Print a module signature with named results.
 void printModuleSignature(OpAsmPrinter &p, Operation *op,
diff --git a/include/circt/Dialect/HWArith/HWArithDialect.td b/include/circt/Dialect/HWArith/HWArithDialect.td
index 111e64525..cea2d39fd 100644
--- a/include/circt/Dialect/HWArith/HWArithDialect.td
+++ b/include/circt/Dialect/HWArith/HWArithDialect.td
@@ -22,6 +22,7 @@ def HWArithDialect : Dialect {
     This dialect defines the `HWArith` dialect, modeling bit-width aware
     arithmetic operations.
   }];
+  let useFoldAPI = kEmitFoldAdaptorFolder;
 }
 
 #endif // HWARITHDIALECT_TD
diff --git a/include/circt/Dialect/Handshake/Handshake.td b/include/circt/Dialect/Handshake/Handshake.td
index d5966d973..97e2e0940 100644
--- a/include/circt/Dialect/Handshake/Handshake.td
+++ b/include/circt/Dialect/Handshake/Handshake.td
@@ -34,6 +34,7 @@ def Handshake_Dialect : Dialect {
   }];
 
   let useDefaultAttributePrinterParser = 1;
+  let useFoldAPI = kEmitFoldAdaptorFolder;
 }
 
 // Base class for Handshake dialect ops.
diff --git a/include/circt/Dialect/Interop/Interop.td b/include/circt/Dialect/Interop/Interop.td
index 82f0ae2dd..fbf3aa088 100644
--- a/include/circt/Dialect/Interop/Interop.td
+++ b/include/circt/Dialect/Interop/Interop.td
@@ -32,6 +32,7 @@ def InteropDialect : Dialect {
     solutions.
   }];
   let cppNamespace = "::circt::interop";
+  let useFoldAPI = kEmitFoldAdaptorFolder;
 }
 
 //===----------------------------------------------------------------------===//
diff --git a/include/circt/Dialect/LLHD/IR/LLHD.td b/include/circt/Dialect/LLHD/IR/LLHD.td
index 86ab3c60e..0a70c3dff 100644
--- a/include/circt/Dialect/LLHD/IR/LLHD.td
+++ b/include/circt/Dialect/LLHD/IR/LLHD.td
@@ -38,6 +38,7 @@ def LLHD_Dialect : Dialect {
   let hasConstantMaterializer = 1;
   let useDefaultTypePrinterParser = 1;
   let useDefaultAttributePrinterParser = 1;
+  let useFoldAPI = kEmitFoldAdaptorFolder;
 
   let extraClassDeclaration = [{
     /// Register all LLHD types.
diff --git a/include/circt/Dialect/MSFT/MSFT.td b/include/circt/Dialect/MSFT/MSFT.td
index 287472eb0..4bdd9e3f6 100644
--- a/include/circt/Dialect/MSFT/MSFT.td
+++ b/include/circt/Dialect/MSFT/MSFT.td
@@ -36,6 +36,7 @@ def MSFTDialect : Dialect {
 
   let hasConstantMaterializer = 1;
   let useDefaultAttributePrinterParser = 1;
+  let useFoldAPI = kEmitFoldAdaptorFolder;
 
   let extraClassDeclaration = [{
     /// Register all MSFT attributes.
diff --git a/include/circt/Dialect/MSFT/MSFTOps.td b/include/circt/Dialect/MSFT/MSFTOps.td
index 11f202d4b..ccba8bc60 100644
--- a/include/circt/Dialect/MSFT/MSFTOps.td
+++ b/include/circt/Dialect/MSFT/MSFTOps.td
@@ -10,7 +10,6 @@ include "circt/Dialect/HW/HWOpInterfaces.td"
 
 def InstanceOp : MSFTOp<"instance", [
         Symbol,
-        ParentOneOf<["MSFTModuleOp"]>,
         DeclareOpInterfaceMethods<OpAsmOpInterface, ["getAsmResultNames"]>,
         DeclareOpInterfaceMethods<SymbolUserOpInterface>,
         DeclareOpInterfaceMethods<HWInstanceLike>
@@ -133,7 +132,10 @@ def MSFTModuleOp : MSFTModuleOpBase<"module",
       TypeAttrOf<FunctionType>:$function_type,
       OptionalAttr<DictArrayAttr>:$arg_attrs,
       OptionalAttr<DictArrayAttr>:$res_attrs,
-      StrArrayAttr:$argNames, StrArrayAttr:$resultNames,
+      StrArrayAttr:$argNames,
+      StrArrayAttr:$resultNames,
+      LocationArrayAttr:$argLocs,
+      LocationArrayAttr:$resultLocs,
       DictionaryAttr:$parameters,
       OptionalAttr<StrAttr>:$fileName,
       OptionalAttr<StrArrayAttr>:$childAppIDBases);
@@ -191,6 +193,7 @@ def MSFTModuleOp : MSFTModuleOpBase<"module",
   }];
 
   let hasCustomAssemblyFormat = 1;
+  let hasVerifier = 1;
 }
 
 def MSFTModuleExternOp : MSFTOp<"module.extern",
diff --git a/include/circt/Dialect/Moore/MooreDialect.td b/include/circt/Dialect/Moore/MooreDialect.td
index 2139a7c11..bd8f68806 100644
--- a/include/circt/Dialect/Moore/MooreDialect.td
+++ b/include/circt/Dialect/Moore/MooreDialect.td
@@ -32,6 +32,7 @@ def MooreDialect : Dialect {
     void printType(Type, DialectAsmPrinter &) const override;
   }];
   let useDefaultTypePrinterParser = 0;
+  let useFoldAPI = kEmitFoldAdaptorFolder;
 }
 
 #endif // CIRCT_DIALECT_MOORE_MOOREDIALECT
diff --git a/include/circt/Dialect/Pipeline/Pipeline.td b/include/circt/Dialect/Pipeline/Pipeline.td
index ebd5b8bda..b2f5362a4 100644
--- a/include/circt/Dialect/Pipeline/Pipeline.td
+++ b/include/circt/Dialect/Pipeline/Pipeline.td
@@ -26,6 +26,7 @@ include "mlir/IR/EnumAttr.td"
 def Pipeline_Dialect : Dialect {
   let name = "pipeline";
   let cppNamespace = "::circt::pipeline";
+  let useFoldAPI = kEmitFoldAdaptorFolder;
 }
 
 def PipelineOp : Op<Pipeline_Dialect, "pipeline", [
diff --git a/include/circt/Dialect/SSP/SSP.td b/include/circt/Dialect/SSP/SSP.td
index 7d37f48f4..97ebc596b 100644
--- a/include/circt/Dialect/SSP/SSP.td
+++ b/include/circt/Dialect/SSP/SSP.td
@@ -30,6 +30,7 @@ def SSPDialect : Dialect {
 
   let cppNamespace = "::circt::ssp";
 
+  let useFoldAPI = kEmitFoldAdaptorFolder;
   let useDefaultAttributePrinterParser = true;
   let extraClassDeclaration = [{
     /// Register all SSP attributes.
diff --git a/include/circt/Dialect/SV/SV.td b/include/circt/Dialect/SV/SV.td
index bc300d0f7..1a781fb96 100644
--- a/include/circt/Dialect/SV/SV.td
+++ b/include/circt/Dialect/SV/SV.td
@@ -16,7 +16,6 @@
 include "mlir/IR/AttrTypeBase.td"
 include "mlir/IR/OpBase.td"
 include "mlir/IR/OpAsmInterface.td"
-include "mlir/IR/SubElementInterfaces.td"
 include "mlir/IR/SymbolInterfaces.td"
 include "mlir/Interfaces/SideEffectInterfaces.td"
 
diff --git a/include/circt/Dialect/SV/SVDialect.td b/include/circt/Dialect/SV/SVDialect.td
index d7283c1e8..a1f585e01 100644
--- a/include/circt/Dialect/SV/SVDialect.td
+++ b/include/circt/Dialect/SV/SVDialect.td
@@ -26,6 +26,7 @@ def SVDialect : Dialect {
 
   let useDefaultTypePrinterParser = 1;
   let useDefaultAttributePrinterParser = 1;
+  let useFoldAPI = kEmitFoldAdaptorFolder;
 
   let extraClassDeclaration = [{
     /// Register all SV types.
diff --git a/include/circt/Dialect/SV/SVExpressions.td b/include/circt/Dialect/SV/SVExpressions.td
index 7ebf560d7..14870b6b9 100644
--- a/include/circt/Dialect/SV/SVExpressions.td
+++ b/include/circt/Dialect/SV/SVExpressions.td
@@ -204,7 +204,7 @@ def LocalParamOp : SVOp<"localparam",
   let results = (outs HWValueType:$result);
 
   let assemblyFormat = [{
-    `:` qualified(type($result)) custom<ImplicitSSAName>(attr-dict)
+    `:` qualified(type($result)) `` custom<ImplicitSSAName>(attr-dict)
   }];
 
   let hasVerifier = 1;
diff --git a/include/circt/Dialect/SV/SVInOutOps.td b/include/circt/Dialect/SV/SVInOutOps.td
index 44e6222df..53dcd4a9a 100644
--- a/include/circt/Dialect/SV/SVInOutOps.td
+++ b/include/circt/Dialect/SV/SVInOutOps.td
@@ -38,7 +38,7 @@ def WireOp : SVOp<"wire", [NonProceduralOp,
   ];
 
   let assemblyFormat = [{
-    (`sym` $inner_sym^)? custom<ImplicitSSAName>(attr-dict) `:` qualified(type($result))
+    (`sym` $inner_sym^)? `` custom<ImplicitSSAName>(attr-dict) `:` qualified(type($result))
   }];
   let hasCanonicalizeMethod = true;
 
@@ -68,7 +68,7 @@ def RegOp : SVOp<"reg", [
 
   // We handle the name in a custom way, so we use a customer parser/printer.
   let assemblyFormat = [{
-    (`sym` $inner_sym^)? custom<ImplicitSSAName>(attr-dict)
+    (`sym` $inner_sym^)? `` custom<ImplicitSSAName>(attr-dict)
      `:` qualified(type($result))
   }];
   let hasCanonicalizeMethod = true;
@@ -236,7 +236,7 @@ def LogicOp : SVOp<"logic", [DeclareOpInterfaceMethods<OpAsmOpInterface,
   ];
 
   let assemblyFormat = [{
-    (`sym` $inner_sym^)? custom<ImplicitSSAName>(attr-dict) `:`
+    (`sym` $inner_sym^)? `` custom<ImplicitSSAName>(attr-dict) `:`
                                                 qualified(type($result))
   }];
 
diff --git a/include/circt/Dialect/SV/SVStatements.td b/include/circt/Dialect/SV/SVStatements.td
index 5b3593073..8c54775db 100644
--- a/include/circt/Dialect/SV/SVStatements.td
+++ b/include/circt/Dialect/SV/SVStatements.td
@@ -743,7 +743,8 @@ def ReadMemOp : SVOp<"readmem", [ProceduralOp]> {
     See Section 21.4 of IEEE 1800-2017 for more information.
   }];
   let arguments =
-    (ins SymbolNameAttr:$inner_sym, StrAttr:$filename, MemBaseTypeAttr:$base);
+    (ins InOutType:$dest, StrAttr:$filename, MemBaseTypeAttr:$base);
   let results = (outs);
-  let assemblyFormat = "$inner_sym `,` $filename `,` $base attr-dict";
+  let assemblyFormat =
+    "$dest `,` $filename `,` $base attr-dict `:` qualified(type($dest))";
 }
diff --git a/include/circt/Dialect/SV/SVTypeDecl.td b/include/circt/Dialect/SV/SVTypeDecl.td
index 4fd8282a8..9aea643e0 100644
--- a/include/circt/Dialect/SV/SVTypeDecl.td
+++ b/include/circt/Dialect/SV/SVTypeDecl.td
@@ -223,7 +223,7 @@ def InterfaceInstanceOp : SVOp<"interface.instance", [HasCustomSSAName]> {
   let results = (outs InterfaceType : $result);
 
   let assemblyFormat = [{
-    (`sym` $inner_sym^)? custom<ImplicitSSAName>(attr-dict)
+    (`sym` $inner_sym^)? `` custom<ImplicitSSAName>(attr-dict)
     `:` qualified(type($result))
   }];
 
diff --git a/include/circt/Dialect/Seq/SeqDialect.td b/include/circt/Dialect/Seq/SeqDialect.td
index 008801882..87bc61f35 100644
--- a/include/circt/Dialect/Seq/SeqDialect.td
+++ b/include/circt/Dialect/Seq/SeqDialect.td
@@ -23,6 +23,7 @@ def SeqDialect : Dialect {
 
   let hasConstantMaterializer = 1;
   let useDefaultTypePrinterParser = 1;
+  let useFoldAPI = kEmitFoldAdaptorFolder;
   let cppNamespace = "::circt::seq";
 
   let extraClassDeclaration = [{
diff --git a/include/circt/Dialect/SystemC/SystemCDialect.td b/include/circt/Dialect/SystemC/SystemCDialect.td
index 88092a625..6d22701d7 100644
--- a/include/circt/Dialect/SystemC/SystemCDialect.td
+++ b/include/circt/Dialect/SystemC/SystemCDialect.td
@@ -35,6 +35,7 @@ def SystemCDialect : Dialect {
   }];
 
   let useDefaultTypePrinterParser = 0;
+  let useFoldAPI = kEmitFoldAdaptorFolder;
 }
 
 #endif // CIRCT_DIALECT_SYSTEMC_SYSTEMCDIALECT
diff --git a/include/circt/Support/LLVM.h b/include/circt/Support/LLVM.h
index 626c23abd..10bae5ed0 100644
--- a/include/circt/Support/LLVM.h
+++ b/include/circt/Support/LLVM.h
@@ -113,6 +113,7 @@ class InFlightDiagnostic;
 class IntegerAttr;
 class IntegerType;
 class Location;
+class LocationAttr;
 class MemRefType;
 class MLIRContext;
 class ModuleOp;
@@ -220,6 +221,7 @@ using mlir::IntegerAttr;               // NOLINT(misc-unused-using-decls)
 using mlir::IntegerType;               // NOLINT(misc-unused-using-decls)
 using mlir::IRMapping;                 // NOLINT(misc-unused-using-decls)
 using mlir::Location;                  // NOLINT(misc-unused-using-decls)
+using mlir::LocationAttr;              // NOLINT(misc-unused-using-decls)
 using mlir::LogicalResult;             // NOLINT(misc-unused-using-decls)
 using mlir::MemRefAccess;              // NOLINT(misc-unused-using-decls)
 using mlir::MemRefType;                // NOLINT(misc-unused-using-decls)
diff --git a/integration_test/Bindings/Python/export_verilog.py b/integration_test/Bindings/Python/export_verilog.py
index 2534f74f7..aab0c5727 100644
--- a/integration_test/Bindings/Python/export_verilog.py
+++ b/integration_test/Bindings/Python/export_verilog.py
@@ -25,13 +25,15 @@ with Context() as ctx, Location.unknown():
   circt.export_verilog(m, buffer)
   print(buffer.getvalue())
   # INMEMORY: module test(
-  # INMEMORY:   output out);
+  # INMEMORY:   output out
+  # INMEMORY: );
   # INMEMORY:   assign out = 1'h1;
   # INMEMORY: endmodule
 
   cwd = os.getcwd()
   circt.export_split_verilog(m, cwd)
   # DIRECTORY: module test(
-  # DIRECTORY:   output out);
+  # DIRECTORY:   output out
+  # DIRECTORY: );
   # DIRECTORY:   assign out = 1'h1;
   # DIRECTORY: endmodule
diff --git a/integration_test/ESI/cosim/loopback.mlir b/integration_test/ESI/cosim/loopback.mlir
index c0e69b6af..aa15f58df 100644
--- a/integration_test/ESI/cosim/loopback.mlir
+++ b/integration_test/ESI/cosim/loopback.mlir
@@ -4,13 +4,8 @@
 // RUN: circt-opt %t4.mlir --lower-esi-to-physical --lower-esi-ports --lower-esi-to-hw --export-split-verilog -o %t3.mlir
 // RUN: circt-translate %t4.mlir -export-esi-capnp -verify-diagnostics > %t2.capnp
 // RUN: cd ..
-// RUN: esi-cosim-runner.py --schema %t2.capnp %s %t6/*.sv
-// PY: import loopback as test
-// PY: rpc = test.LoopbackTester(rpcschemapath, simhostport)
-// PY: print(rpc.list())
-// PY: rpc.test_two_chan_loopback(25)
-// PY: rpc.test_i32(25)
-// PY: rpc.test_keytext(25)
+// RUN: esi-cosim-runner.py --schema %t2.capnp --exec %S/loopback.py %t6/*.sv
+
 
 hw.module @intLoopback(%clk:i1, %rst:i1) -> () {
   %cosimRecv = esi.cosim %clk, %rst, %bufferedResp, "IntTestEP" {name_ext="loopback"} : !esi.channel<i32> -> !esi.channel<i32>
diff --git a/integration_test/ESI/cosim/loopback.py b/integration_test/ESI/cosim/loopback.py
index a7d6cdac3..dfe7cf7a3 100755
--- a/integration_test/ESI/cosim/loopback.py
+++ b/integration_test/ESI/cosim/loopback.py
@@ -92,3 +92,13 @@ class LoopbackTester(esi_cosim.CosimBase):
       print(f"got:      {kt}")
       assert list(kt.key) == list(kts[i].key)
       assert list(kt.text) == list(kts[i].text)
+
+
+if __name__ == "__main__":
+  import os
+  import sys
+  rpc = LoopbackTester(sys.argv[2], f"{os.uname()[1]}:{sys.argv[1]}")
+  print(rpc.list())
+  rpc.test_two_chan_loopback(25)
+  rpc.test_i32(25)
+  rpc.test_keytext(25)
diff --git a/lib/Bindings/Python/dialects/_esi_ops_ext.py b/lib/Bindings/Python/dialects/_esi_ops_ext.py
index d0bebc541..4ab88eb43 100644
--- a/lib/Bindings/Python/dialects/_esi_ops_ext.py
+++ b/lib/Bindings/Python/dialects/_esi_ops_ext.py
@@ -33,3 +33,12 @@ class RandomAccessMemoryDeclOp:
   @property
   def innerType(self):
     return ir.TypeAttr(self.attributes["innerType"])
+
+
+class ESIPureModuleOp:
+
+  def add_entry_block(self):
+    if len(self.body.blocks) > 0:
+      raise IndexError('The module already has an entry block')
+    self.body.blocks.append()
+    return self.body.blocks[0]
diff --git a/lib/Bindings/Python/dialects/_hw_ops_ext.py b/lib/Bindings/Python/dialects/_hw_ops_ext.py
index 06e54543e..6ae741fc8 100644
--- a/lib/Bindings/Python/dialects/_hw_ops_ext.py
+++ b/lib/Bindings/Python/dialects/_hw_ops_ext.py
@@ -143,17 +143,24 @@ class ModuleLike:
 
     input_types = []
     input_names = []
+    input_locs = []
+    unknownLoc = Location.unknown().attr
     for (i, (port_name, port_type)) in enumerate(input_ports):
       input_types.append(port_type)
       input_names.append(StringAttr.get(str(port_name)))
+      input_locs.append(unknownLoc)
     attributes["argNames"] = ArrayAttr.get(input_names)
+    attributes["argLocs"] = ArrayAttr.get(input_locs)
 
     output_types = []
     output_names = []
+    output_locs = []
     for (i, (port_name, port_type)) in enumerate(output_ports):
       output_types.append(port_type)
       output_names.append(StringAttr.get(str(port_name)))
+      output_locs.append(unknownLoc)
     attributes["resultNames"] = ArrayAttr.get(output_names)
+    attributes["resultLocs"] = ArrayAttr.get(output_locs)
 
     if len(parameters) > 0 or "parameters" not in attributes:
       attributes["parameters"] = ArrayAttr.get(parameters)
diff --git a/lib/Conversion/AffineToPipeline/AffineToPipeline.cpp b/lib/Conversion/AffineToPipeline/AffineToPipeline.cpp
index 2cdf1ed38..98354d75f 100644
--- a/lib/Conversion/AffineToPipeline/AffineToPipeline.cpp
+++ b/lib/Conversion/AffineToPipeline/AffineToPipeline.cpp
@@ -33,6 +33,8 @@
 #include "llvm/ADT/STLExtras.h"
 #include "llvm/ADT/TypeSwitch.h"
 #include "llvm/Support/Debug.h"
+#include <cassert>
+#include <limits>
 
 #define DEBUG_TYPE "affine-to-pipeline"
 
@@ -52,17 +54,50 @@ struct AffineToPipeline : public AffineToPipelineBase<AffineToPipeline> {
   void runOnOperation() override;
 
 private:
+  ModuloProblem getModuloProblem(CyclicProblem &prob);
   LogicalResult
   lowerAffineStructures(MemoryDependenceAnalysis &dependenceAnalysis);
-  LogicalResult populateOperatorTypes(SmallVectorImpl<AffineForOp> &loopNest);
-  LogicalResult solveSchedulingProblem(SmallVectorImpl<AffineForOp> &loopNest);
-  LogicalResult createPipelinePipeline(SmallVectorImpl<AffineForOp> &loopNest);
+  LogicalResult populateOperatorTypes(SmallVectorImpl<AffineForOp> &loopNest,
+                                      ModuloProblem &problem);
+  LogicalResult solveSchedulingProblem(SmallVectorImpl<AffineForOp> &loopNest,
+                                       ModuloProblem &problem);
+  LogicalResult createPipelinePipeline(SmallVectorImpl<AffineForOp> &loopNest,
+                                       ModuloProblem &problem);
 
   CyclicSchedulingAnalysis *schedulingAnalysis;
 };
 
 } // namespace
 
+ModuloProblem AffineToPipeline::getModuloProblem(CyclicProblem &prob) {
+  auto modProb = ModuloProblem::get(prob.getContainingOp());
+  for (auto *op : prob.getOperations()) {
+    auto opr = prob.getLinkedOperatorType(op);
+    if (opr.has_value()) {
+      modProb.setLinkedOperatorType(op, opr.value());
+      auto latency = prob.getLatency(opr.value());
+      if (latency.has_value())
+        modProb.setLatency(opr.value(), latency.value());
+    }
+    modProb.insertOperation(op);
+  }
+
+  for (auto *op : prob.getOperations()) {
+    for (auto dep : prob.getDependences(op)) {
+      if (dep.isAuxiliary()) {
+        auto depInserted = modProb.insertDependence(dep);
+        assert(succeeded(depInserted));
+        (void)depInserted;
+      }
+      auto distance = prob.getDistance(dep);
+      if (distance.has_value())
+        modProb.setDistance(dep, distance.value());
+    }
+  }
+
+  return modProb;
+}
+
 void AffineToPipeline::runOnOperation() {
   // Get dependence analysis for the whole function.
   auto dependenceAnalysis = getAnalysis<MemoryDependenceAnalysis>();
@@ -84,16 +119,19 @@ void AffineToPipeline::runOnOperation() {
     if (nestedLoops.size() != 1)
       continue;
 
+    ModuloProblem moduloProblem =
+        getModuloProblem(schedulingAnalysis->getProblem(nestedLoops.back()));
+
     // Populate the target operator types.
-    if (failed(populateOperatorTypes(nestedLoops)))
+    if (failed(populateOperatorTypes(nestedLoops, moduloProblem)))
       return signalPassFailure();
 
     // Solve the scheduling problem computed by the analysis.
-    if (failed(solveSchedulingProblem(nestedLoops)))
+    if (failed(solveSchedulingProblem(nestedLoops, moduloProblem)))
       return signalPassFailure();
 
     // Convert the IR.
-    if (failed(createPipelinePipeline(nestedLoops)))
+    if (failed(createPipelinePipeline(nestedLoops, moduloProblem)))
       return signalPassFailure();
   }
 }
@@ -237,14 +275,12 @@ LogicalResult AffineToPipeline::lowerAffineStructures(
 /// targetting. Right now, we assume Calyx, which has a standard library with
 /// well-defined operator latencies. Ultimately, we should move this to a
 /// dialect interface in the Scheduling dialect.
-LogicalResult AffineToPipeline::populateOperatorTypes(
-    SmallVectorImpl<AffineForOp> &loopNest) {
+LogicalResult
+AffineToPipeline::populateOperatorTypes(SmallVectorImpl<AffineForOp> &loopNest,
+                                        ModuloProblem &problem) {
   // Scheduling analyis only considers the innermost loop nest for now.
   auto forOp = loopNest.back();
 
-  // Retrieve the cyclic scheduling problem for this loop.
-  CyclicProblem &problem = schedulingAnalysis->getProblem(forOp);
-
   // Load the Calyx operator library into the problem. This is a very minimal
   // set of arithmetic and memory operators for now. This should ultimately be
   // pulled out into some sort of dialect interface.
@@ -264,14 +300,40 @@ LogicalResult AffineToPipeline::populateOperatorTypes(
           problem.setLinkedOperatorType(combOp, combOpr);
           return WalkResult::advance();
         })
-        .Case<AffineLoadOp, AffineStoreOp, memref::LoadOp, memref::StoreOp>(
-            [&](Operation *seqOp) {
-              // Some known sequential ops. In certain cases, reads may be
-              // combinational in Calyx, but taking advantage of that is left as
-              // a future enhancement.
-              problem.setLinkedOperatorType(seqOp, seqOpr);
-              return WalkResult::advance();
-            })
+        .Case<AddIOp, CmpIOp>([&](Operation *seqOp) {
+          // These ops need to be sequential for now because we do not
+          // have enough information to chain them together yet.
+          problem.setLinkedOperatorType(seqOp, seqOpr);
+          return WalkResult::advance();
+        })
+        .Case<AffineStoreOp, memref::StoreOp>([&](Operation *memOp) {
+          // Some known sequential ops. In certain cases, reads may be
+          // combinational in Calyx, but taking advantage of that is left as
+          // a future enhancement.
+          Value memRef = isa<AffineStoreOp>(*memOp)
+                             ? cast<AffineStoreOp>(*memOp).getMemRef()
+                             : cast<memref::StoreOp>(*memOp).getMemRef();
+          Problem::OperatorType memOpr = problem.getOrInsertOperatorType(
+              "mem_" + std::to_string(hash_value(memRef)));
+          problem.setLatency(memOpr, 1);
+          problem.setLimit(memOpr, 1);
+          problem.setLinkedOperatorType(memOp, memOpr);
+          return WalkResult::advance();
+        })
+        .Case<AffineLoadOp, memref::LoadOp>([&](Operation *memOp) {
+          // Some known sequential ops. In certain cases, reads may be
+          // combinational in Calyx, but taking advantage of that is left as
+          // a future enhancement.
+          Value memRef = isa<AffineLoadOp>(*memOp)
+                             ? cast<AffineLoadOp>(*memOp).getMemRef()
+                             : cast<memref::LoadOp>(*memOp).getMemRef();
+          Problem::OperatorType memOpr = problem.getOrInsertOperatorType(
+              "mem_" + std::to_string(hash_value(memRef)));
+          problem.setLatency(memOpr, 1);
+          problem.setLimit(memOpr, 1);
+          problem.setLinkedOperatorType(memOp, memOpr);
+          return WalkResult::advance();
+        })
         .Case<MulIOp>([&](Operation *mcOp) {
           // Some known multi-cycle ops.
           problem.setLinkedOperatorType(mcOp, mcOpr);
@@ -290,14 +352,12 @@ LogicalResult AffineToPipeline::populateOperatorTypes(
 }
 
 /// Solve the pre-computed scheduling problem.
-LogicalResult AffineToPipeline::solveSchedulingProblem(
-    SmallVectorImpl<AffineForOp> &loopNest) {
+LogicalResult
+AffineToPipeline::solveSchedulingProblem(SmallVectorImpl<AffineForOp> &loopNest,
+                                         ModuloProblem &problem) {
   // Scheduling analyis only considers the innermost loop nest for now.
   auto forOp = loopNest.back();
 
-  // Retrieve the cyclic scheduling problem for this loop.
-  CyclicProblem &problem = schedulingAnalysis->getProblem(forOp);
-
   // Optionally debug problem inputs.
   LLVM_DEBUG(forOp.getBody()->walk<WalkOrder::PreOrder>([&](Operation *op) {
     llvm::dbgs() << "Scheduling inputs for " << *op;
@@ -338,14 +398,12 @@ LogicalResult AffineToPipeline::solveSchedulingProblem(
 }
 
 /// Create the pipeline op for a loop nest.
-LogicalResult AffineToPipeline::createPipelinePipeline(
-    SmallVectorImpl<AffineForOp> &loopNest) {
+LogicalResult
+AffineToPipeline::createPipelinePipeline(SmallVectorImpl<AffineForOp> &loopNest,
+                                         ModuloProblem &problem) {
   // Scheduling analyis only considers the innermost loop nest for now.
   auto forOp = loopNest.back();
 
-  // Retrieve the cyclic scheduling problem for this loop.
-  CyclicProblem &problem = schedulingAnalysis->getProblem(forOp);
-
   auto outerLoop = loopNest.front();
   auto innerLoop = loopNest.back();
   ImplicitLocOpBuilder builder(outerLoop.getLoc(), outerLoop);
@@ -361,7 +419,7 @@ LogicalResult AffineToPipeline::createPipelinePipeline(
   // iter arg is created for the induction variable.
   TypeRange resultTypes = innerLoop.getResultTypes();
 
-  auto ii = builder.getI64IntegerAttr(*problem.getInitiationInterval());
+  auto ii = builder.getI64IntegerAttr(problem.getInitiationInterval().value());
 
   SmallVector<Value> iterArgs;
   iterArgs.push_back(lowerBound);
@@ -398,6 +456,8 @@ LogicalResult AffineToPipeline::createPipelinePipeline(
   // Maintain mappings of values in the loop body and results of stages,
   // initially populated with the iter args.
   IRMapping valueMap;
+  // Nested loops are not supported yet.
+  assert(iterArgs.size() == forOp.getBody()->getNumArguments());
   for (size_t i = 0; i < iterArgs.size(); ++i)
     valueMap.map(forOp.getBody()->getArgument(i),
                  pipeline.getStagesBlock().getArgument(i));
@@ -408,37 +468,97 @@ LogicalResult AffineToPipeline::createPipelinePipeline(
 
   // Iterate in order of the start times.
   SmallVector<unsigned> startTimes;
-  for (auto group : startGroups)
+  for (const auto &group : startGroups)
     startTimes.push_back(group.first);
   llvm::sort(startTimes);
 
   DominanceInfo dom(getOperation());
+
+  // Keys for translating values in each stage
+  SmallVector<SmallVector<Value>> registerValues;
+  SmallVector<SmallVector<Type>> registerTypes;
+
+  // The maps that ensure a stage uses the correct version of a value
+  SmallVector<IRMapping> stageValueMaps;
+
+  // For storing the range of stages an operation's results need to be valid for
+  DenseMap<Operation *, std::pair<unsigned, unsigned>> pipeTimes;
+
   for (auto startTime : startTimes) {
     auto group = startGroups[startTime];
-    OpBuilder::InsertionGuard g(builder);
 
     // Collect the return types for this stage. Operations whose results are not
     // used within this stage are returned.
     auto isLoopTerminator = [forOp](Operation *op) {
       return isa<AffineYieldOp>(op) && op->getParentOp() == forOp;
     };
-    SmallVector<Type> stageTypes;
-    DenseSet<Operation *> opsWithReturns;
+
+    // Initialize set of registers up until this point in time
+    for (unsigned i = registerValues.size(); i <= startTime; ++i)
+      registerValues.emplace_back(SmallVector<Value>());
+
+    // Check each operation to see if its results need plumbing
     for (auto *op : group) {
+      if (op->getUsers().empty())
+        continue;
+
+      unsigned pipeEndTime = 0;
       for (auto *user : op->getUsers()) {
-        if (*problem.getStartTime(user) > startTime || isLoopTerminator(user)) {
-          opsWithReturns.insert(op);
-          stageTypes.append(op->getResultTypes().begin(),
-                            op->getResultTypes().end());
-        }
+        unsigned userStartTime = *problem.getStartTime(user);
+        if (*problem.getStartTime(user) > startTime)
+          pipeEndTime = std::max(pipeEndTime, userStartTime);
+        else if (isLoopTerminator(user))
+          // Manually forward the value into the terminator's valueMap
+          pipeEndTime = std::max(pipeEndTime, userStartTime + 1);
+      }
+
+      // Insert the range of pipeline stages the value needs to be valid for
+      pipeTimes[op] = std::pair(startTime, pipeEndTime);
+
+      // Add register stages for each time slice we need to pipe to
+      for (unsigned i = registerValues.size(); i <= pipeEndTime; ++i)
+        registerValues.push_back(SmallVector<Value>());
+
+      // Keep a collection of this stages results as keys to our valueMaps
+      for (auto result : op->getResults())
+        registerValues[startTime].push_back(result);
+
+      // Other stages that use the value will need these values as keys too
+      unsigned firstUse = std::max(
+          startTime + 1,
+          startTime + *problem.getLatency(*problem.getLinkedOperatorType(op)));
+      for (unsigned i = firstUse; i < pipeEndTime; ++i) {
+        for (auto result : op->getResults())
+          registerValues[i].push_back(result);
       }
     }
+  }
+
+  // Now make register Types and stageValueMaps
+  for (unsigned i = 0; i < registerValues.size(); ++i) {
+    SmallVector<mlir::Type> types;
+    for (auto val : registerValues[i])
+      types.push_back(val.getType());
+
+    registerTypes.push_back(types);
+    stageValueMaps.push_back(valueMap);
+  }
+
+  // One more map is needed for the pipeline stages terminator
+  stageValueMaps.push_back(valueMap);
 
+  // Create stages along with maps
+  for (auto startTime : startTimes) {
+    auto group = startGroups[startTime];
+    llvm::sort(group,
+               [&](Operation *a, Operation *b) { return dom.dominates(a, b); });
+    auto stageTypes = registerTypes[startTime];
     // Add the induction variable increment in the first stage.
     if (startTime == 0)
       stageTypes.push_back(lowerBound.getType());
 
     // Create the stage itself.
+    builder.setInsertionPoint(stagesBlock.getTerminator());
     auto startTimeAttr = builder.getIntegerAttr(
         builder.getIntegerType(64, /*isSigned=*/true), startTime);
     auto stage =
@@ -447,32 +567,36 @@ LogicalResult AffineToPipeline::createPipelinePipeline(
     auto *stageTerminator = stageBlock.getTerminator();
     builder.setInsertionPointToStart(&stageBlock);
 
-    // Sort the group according to original dominance.
-    llvm::sort(group,
-               [&](Operation *a, Operation *b) { return dom.dominates(a, b); });
-
-    // Move over the operations and add their results to the terminator.
-    SmallVector<std::tuple<Operation *, Operation *, unsigned>> movedOps;
     for (auto *op : group) {
-      unsigned resultIndex = stageTerminator->getNumOperands();
-      auto *newOp = builder.clone(*op, valueMap);
-      if (opsWithReturns.contains(op)) {
-        stageTerminator->insertOperands(resultIndex, newOp->getResults());
-        movedOps.emplace_back(op, newOp, resultIndex);
-      }
+      auto *newOp = builder.clone(*op, stageValueMaps[startTime]);
+
+      // All further uses in this stage should used the cloned-version of values
+      // So we update the mapping in this stage
+      for (auto result : op->getResults())
+        stageValueMaps[startTime].map(
+            result, newOp->getResult(result.getResultNumber()));
     }
 
-    // Add the stage results to the value map for the original op.
-    for (auto tuple : movedOps) {
-      Operation *op = std::get<0>(tuple);
-      Operation *newOp = std::get<1>(tuple);
-      unsigned resultIndex = std::get<2>(tuple);
-      for (size_t i = 0; i < newOp->getNumResults(); ++i) {
-        auto newValue = stage->getResult(resultIndex + i);
-        auto oldValue = op->getResult(i);
-        valueMap.map(oldValue, newValue);
-      }
+    // Register all values in the terminator, using their mapped value
+    SmallVector<Value> stageOperands;
+    unsigned resIndex = 0;
+    for (auto res : registerValues[startTime]) {
+      stageOperands.push_back(stageValueMaps[startTime].lookup(res));
+      // Additionally, update the map of the stage that will consume the
+      // registered value
+      unsigned destTime = startTime + 1;
+      unsigned latency = *problem.getLatency(
+          *problem.getLinkedOperatorType(res.getDefiningOp()));
+      // Multi-cycle case
+      if (*problem.getStartTime(res.getDefiningOp()) == startTime &&
+          latency > 1)
+        destTime = startTime + latency;
+      destTime = std::min((unsigned)(stageValueMaps.size() - 1), destTime);
+      stageValueMaps[destTime].map(res, stage.getResult(resIndex++));
     }
+    // Add these mapped values to pipeline.register
+    stageTerminator->insertOperands(stageTerminator->getNumOperands(),
+                                    stageOperands);
 
     // Add the induction variable increment to the first stage.
     if (startTime == 0) {
@@ -493,9 +617,13 @@ LogicalResult AffineToPipeline::createPipelinePipeline(
   SmallVector<Value> termResults;
   termIterArgs.push_back(
       stagesBlock.front().getResult(stagesBlock.front().getNumResults() - 1));
+
   for (auto value : forOp.getBody()->getTerminator()->getOperands()) {
-    termIterArgs.push_back(valueMap.lookup(value));
-    termResults.push_back(valueMap.lookup(value));
+    unsigned lookupTime = std::min((unsigned)(stageValueMaps.size() - 1),
+                                   pipeTimes[value.getDefiningOp()].second);
+
+    termIterArgs.push_back(stageValueMaps[lookupTime].lookup(value));
+    termResults.push_back(stageValueMaps[lookupTime].lookup(value));
   }
 
   stagesTerminator.getIterArgsMutable().append(termIterArgs);
diff --git a/lib/Conversion/ExportVerilog/ExportVerilog.cpp b/lib/Conversion/ExportVerilog/ExportVerilog.cpp
index 1569d2a95..2a3a8a996 100644
--- a/lib/Conversion/ExportVerilog/ExportVerilog.cpp
+++ b/lib/Conversion/ExportVerilog/ExportVerilog.cpp
@@ -437,16 +437,10 @@ static void collectFileLineColLocs(Location loc,
 
 /// Return the location information as a (potentially empty) string.
 static std::string
-getLocationInfoAsStringImpl(const SmallPtrSetImpl<Operation *> &ops) {
+getLocationInfoAsStringImpl(const SmallPtrSetImpl<Attribute> &locationSet) {
   std::string resultStr;
   llvm::raw_string_ostream sstr(resultStr);
 
-  // Multiple operations may come from the same location or may not have useful
-  // location info.  Unique it now.
-  SmallPtrSet<Attribute, 8> locationSet;
-  for (auto *op : ops)
-    collectFileLineColLocs(op->getLoc(), locationSet);
-
   auto printLoc = [&](FileLineColLoc loc) {
     sstr << loc.getFilename().getValue();
     if (auto line = loc.getLine()) {
@@ -527,29 +521,39 @@ getLocationInfoAsStringImpl(const SmallPtrSetImpl<Operation *> &ops) {
   return sstr.str();
 }
 
-/// Return the location information in the specified style.
 static std::string
-getLocationInfoAsString(const SmallPtrSetImpl<Operation *> &ops,
-                        LoweringOptions::LocationInfoStyle style) {
+getLocationInfoAsStringImpl(const SmallPtrSetImpl<Attribute> &locationSet,
+                            LoweringOptions::LocationInfoStyle style) {
+
   if (style == LoweringOptions::LocationInfoStyle::None)
     return "";
-  auto str = getLocationInfoAsStringImpl(ops);
-  // If the location information is empty, just return an empty string.
-  if (str.empty())
-    return str;
-  switch (style) {
-  case LoweringOptions::LocationInfoStyle::Plain:
+  auto str = getLocationInfoAsStringImpl(locationSet);
+  if (str.empty() || style == LoweringOptions::LocationInfoStyle::Plain)
     return str;
-  case LoweringOptions::LocationInfoStyle::WrapInAtSquareBracket:
-    return "@[" + str + ']';
-  // NOTE: We need this case to avoid a compiler warning regarding an unhandled
-  // switch case. Because we early return in the `None` case, this should be
-  // unreachable.
-  case LoweringOptions::LocationInfoStyle::None:
-    llvm_unreachable("`None` case handled in early return");
-  }
+  assert(style == LoweringOptions::LocationInfoStyle::WrapInAtSquareBracket &&
+         "other styles must be already handled");
+  return "@[" + str + "]";
+}
+
+/// Return the location information in the specified style.
+static std::string
+getLocationInfoAsString(Location loc,
+                        LoweringOptions::LocationInfoStyle style) {
+  SmallPtrSet<Attribute, 8> locationSet;
+  collectFileLineColLocs(loc, locationSet);
+  return getLocationInfoAsStringImpl(locationSet, style);
+}
 
-  llvm_unreachable("all styles must be handled");
+/// Return the location information in the specified style.
+static std::string
+getLocationInfoAsString(const SmallPtrSetImpl<Operation *> &ops,
+                        LoweringOptions::LocationInfoStyle style) {
+  // Multiple operations may come from the same location or may not have useful
+  // location info.  Unique it now.
+  SmallPtrSet<Attribute, 8> locationSet;
+  for (auto *op : ops)
+    collectFileLineColLocs(op->getLoc(), locationSet);
+  return getLocationInfoAsStringImpl(locationSet, style);
 }
 
 /// Most expressions are invalid to bit-select from in Verilog, but some
@@ -581,7 +585,8 @@ static bool isOkToBitSelectFrom(Value v) {
 /// happens because not all Verilog expressions are composable, notably you
 /// can only use bit selects like x[4:6] on simple expressions, you cannot use
 /// expressions in the sensitivity list of always blocks, etc.
-static bool isExpressionUnableToInline(Operation *op) {
+static bool isExpressionUnableToInline(Operation *op,
+                                       const LoweringOptions &options) {
   if (auto cast = dyn_cast<BitcastOp>(op))
     if (!haveMatchingDims(cast.getInput().getType(), cast.getResult().getType(),
                           op->getLoc())) {
@@ -625,7 +630,7 @@ static bool isExpressionUnableToInline(Operation *op) {
         return true;
 
     // Always blocks must have a name in their sensitivity list, not an expr.
-    if (isa<AlwaysOp>(user) || isa<AlwaysFFOp>(user)) {
+    if (!options.allowExprInEventControl && isa<AlwaysOp, AlwaysFFOp>(user)) {
       // Anything other than a read of a wire must be out of line.
       if (auto read = dyn_cast<ReadInOutOp>(op))
         if (read.getInput().getDefiningOp<WireOp>() ||
@@ -711,7 +716,7 @@ bool ExportVerilog::isExpressionEmittedInline(Operation *op,
 
   // If it isn't structurally possible to inline this expression, emit it out
   // of line.
-  return !isExpressionUnableToInline(op);
+  return !isExpressionUnableToInline(op, options);
 }
 
 /// Find a nested IfOp in an else block that can be printed as `else if`
@@ -851,18 +856,25 @@ public:
     return op->emitOpError(message);
   }
 
-  /// If we have location information for any of the specified operations,
-  /// aggregate it together and print a pretty comment specifying where the
-  /// operations came from.  In any case, print a newline.
-  void emitLocationInfoAndNewLine(const SmallPtrSetImpl<Operation *> &ops) {
-    auto locInfo =
-        getLocationInfoAsString(ops, state.options.locationInfoStyle);
+  void emitLocationImpl(const std::string &location) {
     // Break so previous content is not impacted by following,
     // but use a 'neverbreak' so it always fits.
     ps << PP::neverbreak;
+    if (!location.empty())
+      ps << "\t// " << location; // (don't use tabs in normal pretty-printing)
+  }
+
+  void emitLocationInfo(Location loc) {
+    emitLocationImpl(
+        getLocationInfoAsString(loc, state.options.locationInfoStyle));
+  }
 
-    if (!locInfo.empty())
-      ps << "\t// " << locInfo; // (don't use tabs in normal pretty-printing)
+  /// If we have location information for any of the specified operations,
+  /// aggregate it together and print a pretty comment specifying where the
+  /// operations came from.  In any case, print a newline.
+  void emitLocationInfoAndNewLine(const SmallPtrSetImpl<Operation *> &ops) {
+    emitLocationImpl(
+        getLocationInfoAsString(ops, state.options.locationInfoStyle));
     setPendingNewline();
   }
 
@@ -3387,13 +3399,7 @@ LogicalResult StmtEmitter::visitSV(ReadMemOp op) {
   ps.scopedBox(PP::ibox0, [&]() {
     ps.writeQuotedEscaped(op.getFilename());
     ps << "," << PP::space;
-
-    auto *reg =
-        state.symbolCache
-            .getInnerDefinition(op->getParentOfType<HWModuleOp>().getNameAttr(),
-                                op.getInnerSymAttr())
-            .getOp();
-    ps << PPExtString(getSymOpName(reg));
+    emitExpression(op.getDest(), ops);
   });
 
   ps << ");";
@@ -4717,7 +4723,7 @@ void ModuleEmitter::emitHWModule(HWModuleOp module) {
 
   ps << "(";
   if (!portInfo.empty())
-    emitLocationInfoAndNewLine(moduleOpSet);
+    emitLocationInfo(module->getLoc());
 
   // Determine the width of the widest type we have to print so everything
   // lines up nicely.
@@ -4746,12 +4752,16 @@ void ModuleEmitter::emitHWModule(HWModuleOp module) {
   if (maxTypeWidth > 0) // add a space if any type exists
     maxTypeWidth += 1;
 
+  // Emit the port list.
   ps.scopedBox(PP::bbox2, [&]() {
     for (size_t portIdx = 0, e = portInfo.size(); portIdx != e;) {
-      startStatement();
+      auto lastPort = e - 1;
 
-      // Emit the arguments.
+      ps << PP::newline;
       auto portType = portInfo[portIdx].type;
+
+      // If this is a zero width type, emit the port as a comment and create a
+      // neverbox to ensure we don't insert a line break.
       bool isZeroWidth = false;
       if (hasZeroWidth) {
         isZeroWidth = isZeroBitType(portType);
@@ -4760,6 +4770,7 @@ void ModuleEmitter::emitHWModule(HWModuleOp module) {
         ps << (isZeroWidth ? "// " : "   ");
       }
 
+      // Emit the port direction.
       PortDirection thisPortDirection = portInfo[portIdx].direction;
       switch (thisPortDirection) {
       case PortDirection::OUTPUT:
@@ -4779,25 +4790,35 @@ void ModuleEmitter::emitHWModule(HWModuleOp module) {
       if (portTypeStrings[portIdx].size() < maxTypeWidth)
         ps.nbsp(maxTypeWidth - portTypeStrings[portIdx].size());
 
-      size_t startOfNamePos =
-          (hasZeroWidth ? 3 : 0) + (hasOutputs ? 7 : 6) + maxTypeWidth;
+      size_t startOfNamePos = (hasOutputs ? 7 : 6) + maxTypeWidth;
 
       // Emit the name.
       ps << PPExtString(getPortVerilogName(module, portInfo[portIdx]));
+
+      // Emit array dimensions.
       ps.invokeWithStringOS(
           [&](auto &os) { printUnpackedTypePostfix(portType, os); });
 
+      // Emit the symbol.
       if (state.options.printDebugInfo && portInfo[portIdx].sym &&
           !portInfo[portIdx].sym.empty())
         ps << " /* inner_sym: "
            << PPExtString(portInfo[portIdx].sym.getSymName().getValue())
            << " */";
 
-      ++portIdx;
+      // Emit the comma if this is not the last real port.
+      if (portIdx != lastNonZeroPort && portIdx != lastPort)
+        ps << ",";
+
+      // Emit the location.
+      if (auto loc = portInfo[portIdx].loc)
+        emitLocationInfo(loc);
 
       if (isZeroWidth)
         ps << PP::end; // Close never-break group.
 
+      ++portIdx;
+
       // If we have any more ports with the same types and the same
       // direction, emit them in a list one per line. Optionally skip this
       // behavior when requested by user.
@@ -4806,42 +4827,61 @@ void ModuleEmitter::emitHWModule(HWModuleOp module) {
                portInfo[portIdx].direction == thisPortDirection &&
                stripUnpackedTypes(portType) ==
                    stripUnpackedTypes(portInfo[portIdx].type)) {
-          StringRef name = getPortVerilogName(module, portInfo[portIdx]);
           // Append this to the running port decl.
-          ps << ",";
           ps << PP::newline;
+
+          bool isZeroWidth = false;
+          if (hasZeroWidth) {
+            isZeroWidth = isZeroBitType(portType);
+            if (isZeroWidth)
+              ps << PP::neverbox;
+            ps << (isZeroWidth ? "// " : "   ");
+          }
+
           ps.nbsp(startOfNamePos);
+
+          // Emit the name.
+          StringRef name = getPortVerilogName(module, portInfo[portIdx]);
           ps << PPExtString(name);
+
+          // Emit array dimensions.
           ps.invokeWithStringOS([&](auto &os) {
             printUnpackedTypePostfix(portInfo[portIdx].type, os);
           });
 
+          // Emit the symbol.
           if (state.options.printDebugInfo && portInfo[portIdx].sym &&
               !portInfo[portIdx].sym.empty())
             ps << " /* inner_sym: "
                << PPExtString(portInfo[portIdx].sym.getSymName().getValue())
                << " */";
 
+          // Emit the comma if this is not the last real port.
+          if (portIdx != lastNonZeroPort && portIdx != lastPort)
+            ps << ",";
+
+          // Emit the location.
+          if (auto loc = portInfo[portIdx].loc)
+            emitLocationInfo(loc);
+
+          if (isZeroWidth)
+            ps << PP::end; // Close never-break group.
+
           ++portIdx;
         }
       }
-
-      if (portIdx != e) {
-        if (portIdx <= lastNonZeroPort)
-          ps << ",";
-      } else if (isZeroWidth) {
-        ps << PP::newline << ");" << PP::newline;
-      } else {
-        ps << ");" << PP::newline;
-      }
-      setPendingNewline();
     }
   });
 
   if (portInfo.empty()) {
     ps << ");";
     emitLocationInfoAndNewLine(moduleOpSet);
+  } else {
+    ps << PP::newline;
+    ps << ");" << PP::newline;
+    setPendingNewline();
   }
+
   assert(state.pendingNewline);
 
   // Emit the body of the module.
@@ -5019,7 +5059,7 @@ void SharedEmitterState::gatherFiles(bool separateModules) {
         })
         .Case<BindOp, BindInterfaceOp>([&](auto op) {
           if (!attr) {
-            separateFile(op, "bindfile");
+            separateFile(op, "bindfile.sv");
           } else {
             separateFile(op);
           }
diff --git a/lib/Conversion/ExportVerilog/PrepareForEmission.cpp b/lib/Conversion/ExportVerilog/PrepareForEmission.cpp
index fb7669259..940ff4adb 100644
--- a/lib/Conversion/ExportVerilog/PrepareForEmission.cpp
+++ b/lib/Conversion/ExportVerilog/PrepareForEmission.cpp
@@ -723,42 +723,6 @@ static LogicalResult legalizeHWModule(Block &block,
       }
     }
 
-    // Force any expression used in the event control of an always process to be
-    // a trivial wire, if the corresponding option is set.
-    if (!options.allowExprInEventControl) {
-      auto enforceWire = [&](Value expr) {
-        // Direct port uses are fine.
-        if (isSimpleReadOrPort(expr))
-          return;
-        if (auto inst = expr.getDefiningOp<InstanceOp>())
-          return;
-        auto builder = ImplicitLocOpBuilder::atBlockBegin(
-            op.getLoc(), &op.getParentOfType<HWModuleOp>().front());
-        auto newWire = builder.create<WireOp>(expr.getType());
-        builder.setInsertionPoint(&op);
-        auto newWireRead = builder.create<ReadInOutOp>(newWire);
-        // For simplicity, replace all uses with the read first.  This lets us
-        // recursive root out all uses of the expression.
-        expr.replaceAllUsesWith(newWireRead);
-        builder.setInsertionPoint(&op);
-        builder.create<AssignOp>(newWire, expr);
-        // To get the output correct, given that reads are always inline,
-        // duplicate them for each use.
-        lowerAlwaysInlineOperation(newWireRead);
-      };
-      if (auto always = dyn_cast<AlwaysOp>(op)) {
-        for (auto clock : always.getClocks())
-          enforceWire(clock);
-        continue;
-      }
-      if (auto always = dyn_cast<AlwaysFFOp>(op)) {
-        enforceWire(always.getClock());
-        if (auto reset = always.getReset())
-          enforceWire(reset);
-        continue;
-      }
-    }
-
     // If the target doesn't support local variables, hoist all the expressions
     // out to the nearest non-procedural region.
     if (options.disallowLocalVariables && isVerilogExpression(&op) &&
diff --git a/lib/Conversion/FIRRTLToHW/LowerToHW.cpp b/lib/Conversion/FIRRTLToHW/LowerToHW.cpp
index 01a3fa7e1..4c3942c0f 100644
--- a/lib/Conversion/FIRRTLToHW/LowerToHW.cpp
+++ b/lib/Conversion/FIRRTLToHW/LowerToHW.cpp
@@ -661,10 +661,11 @@ void FIRRTLModuleLowering::lowerMemoryDecls(ArrayRef<FirMemory> mems,
   // Insert memories at the bottom of the file.
   OpBuilder b(state.circuitOp);
   b.setInsertionPointAfter(state.circuitOp);
-  std::array<StringRef, 11> schemaFields = {
+  std::array<StringRef, 14> schemaFields = {
       "depth",          "numReadPorts",    "numWritePorts", "numReadWritePorts",
       "readLatency",    "writeLatency",    "width",         "maskGran",
-      "readUnderWrite", "writeUnderWrite", "writeClockIDs"};
+      "readUnderWrite", "writeUnderWrite", "writeClockIDs", "initFilename",
+      "initIsBinary",   "initIsInline"};
   auto schemaFieldsAttr = b.getStrArrayAttr(schemaFields);
   auto schema = b.create<hw::HWGeneratorSchemaOp>(
       mems.front().loc, "FIRRTLMem", "FIRRTL_Memory", schemaFieldsAttr);
@@ -742,7 +743,13 @@ void FIRRTLModuleLowering::lowerMemoryDecls(ArrayRef<FirMemory> mems,
                        b.getUI32IntegerAttr(mem.readUnderWrite)),
         b.getNamedAttr("writeUnderWrite",
                        hw::WUWAttr::get(b.getContext(), mem.writeUnderWrite)),
-        b.getNamedAttr("writeClockIDs", b.getI32ArrayAttr(mem.writeClockIDs))};
+        b.getNamedAttr("writeClockIDs", b.getI32ArrayAttr(mem.writeClockIDs)),
+        b.getNamedAttr("initFilename",
+                       mem.init ? mem.init.getFilename() : b.getStringAttr("")),
+        b.getNamedAttr("initIsBinary", mem.init ? mem.init.getIsBinary()
+                                                : b.getBoolAttr(false)),
+        b.getNamedAttr("initIsInline", mem.init ? mem.init.getIsInline()
+                                                : b.getBoolAttr(false))};
 
     // Make the global module for the memory
     // Set a name for the memory wrapper module, the combMem is an arbitrary
@@ -969,6 +976,7 @@ LogicalResult FIRRTLModuleLowering::lowerPorts(
       hwPort.direction = hw::PortDirection::INOUT;
       hwPort.argNum = numArgs++;
     }
+    hwPort.loc = firrtlPort.loc;
     ports.push_back(hwPort);
     loweringState.processRemainingAnnotations(moduleOp, firrtlPort.annotations);
   }
@@ -1441,6 +1449,7 @@ struct FIRRTLLowering : public FIRRTLVisitor<FIRRTLLowering, LogicalResult> {
                                bool isSigned = false) {
     return getOrCreateIntConstant(APInt(numBits, val, isSigned));
   }
+  Attribute getOrCreateAggregateConstantAttribute(Attribute value, Type type);
   Value getOrCreateXConstant(unsigned numBits);
   Value getPossiblyInoutLoweredValue(Value value);
   Value getLoweredValue(Value value);
@@ -1653,6 +1662,7 @@ private:
   /// This keeps track of constants that we have created so we can reuse them.
   /// This is populated by the getOrCreateIntConstant method.
   DenseMap<Attribute, Value> hwConstantMap;
+  DenseMap<std::pair<Attribute, Type>, Attribute> hwAggregateConstantMap;
 
   /// This keeps track of constant X that we have created so we can reuse them.
   /// This is populated by the getOrCreateXConstant method.
@@ -1842,6 +1852,41 @@ Value FIRRTLLowering::getOrCreateIntConstant(const APInt &value) {
   return entry;
 }
 
+/// Check to see if we've already created the specified aggregate constant
+/// attribute. If so, return it.  Otherwise create it.
+Attribute FIRRTLLowering::getOrCreateAggregateConstantAttribute(Attribute value,
+                                                                Type type) {
+  // Base case.
+  if (hw::type_isa<IntegerType>(type))
+    return builder.getIntegerAttr(type, cast<IntegerAttr>(value).getValue());
+
+  auto cache = hwAggregateConstantMap.lookup({value, type});
+  if (cache)
+    return cache;
+
+  // Recursively construct elements.
+  SmallVector<Attribute> values;
+  for (auto &e : llvm::enumerate(value.cast<ArrayAttr>())) {
+    Type subType;
+    if (auto array = hw::type_dyn_cast<hw::ArrayType>(type))
+      subType = array.getElementType();
+    else if (auto structType = hw::type_dyn_cast<hw::StructType>(type))
+      subType = structType.getElements()[e.index()].type;
+    else
+      assert(false && "type must be either array or struct");
+
+    values.push_back(getOrCreateAggregateConstantAttribute(e.value(), subType));
+  }
+
+  // FIRRTL and HW have a different operand ordering for arrays.
+  if (hw::type_isa<hw::ArrayType>(type))
+    std::reverse(values.begin(), values.end());
+
+  auto &entry = hwAggregateConstantMap[{value, type}];
+  entry = builder.getArrayAttr(values);
+  return entry;
+}
+
 /// Zero bit operands end up looking like failures from getLoweredValue.  This
 /// helper function invokes the closure specified if the operand was actually
 /// zero bit, or returns failure() if it was some other kind of failure.
@@ -2551,22 +2596,11 @@ LogicalResult FIRRTLLowering::visitExpr(BundleCreateOp op) {
 
 LogicalResult FIRRTLLowering::visitExpr(AggregateConstantOp op) {
   auto resultType = lowerType(op.getResult().getType());
-  auto vec = op.getType().dyn_cast<FVectorType>();
-  // Currently we only support 1d vector types.
-  if (!vec || !vec.getElementType().isa<IntType>()) {
-    op.emitError()
-        << "has an unsupported type; currently we only support 1d vectors";
-    return failure();
-  }
+  auto attr =
+      getOrCreateAggregateConstantAttribute(op.getFieldsAttr(), resultType);
 
-  // TODO: Use hw aggregate constant
-  SmallVector<Value> operands;
-  // Make sure to reverse the operands.
-  for (auto elem : llvm::reverse(op.getFields()))
-    operands.push_back(
-        getOrCreateIntConstant(elem.cast<IntegerAttr>().getValue()));
-
-  return setLoweringTo<hw::ArrayCreateOp>(op, resultType, operands);
+  return setLoweringTo<hw::AggregateConstantOp>(op, resultType,
+                                                attr.cast<ArrayAttr>());
 }
 
 //===----------------------------------------------------------------------===//
diff --git a/lib/Conversion/HWArithToHW/HWArithToHW.cpp b/lib/Conversion/HWArithToHW/HWArithToHW.cpp
index 07598e137..3e99d96e8 100644
--- a/lib/Conversion/HWArithToHW/HWArithToHW.cpp
+++ b/lib/Conversion/HWArithToHW/HWArithToHW.cpp
@@ -539,6 +539,17 @@ public:
 
     if (failed(applyPartialConversion(module, target, std::move(patterns))))
       return signalPassFailure();
+
+    // Fix up block argument locations since the signature converter drops
+    // all locations.
+    for (auto &op : module.getOps()) {
+      auto argLocs = op.getAttrOfType<ArrayAttr>("argLocs");
+      if (argLocs && op.getNumRegions() == 1 && op.getRegion(0).hasOneBlock()) {
+        auto *block = &op.getRegion(0).front();
+        for (auto [arg, loc] : llvm::zip(block->getArguments(), argLocs))
+          arg.setLoc(loc.cast<LocationAttr>());
+      }
+    }
   }
 };
 } // namespace
diff --git a/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp b/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp
index ee8e9e0dd..2a84479d4 100644
--- a/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp
+++ b/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp
@@ -1446,11 +1446,7 @@ public:
       return failure();
 
     // Program conversion
-    RewritePatternSet conversionPatterns(&getContext());
-    conversionPatterns.add<calyx::ModuleOpConversion>(&getContext(),
-                                                      topLevelFunction);
-    return applyOpPatternsAndFold(getOperation(),
-                                  std::move(conversionPatterns));
+    return calyx::applyModuleOpConversion(getOperation(), topLevelFunction);
   }
 
   /// 'Once' patterns are expected to take an additional LogicalResult&
diff --git a/lib/Conversion/SCFToCalyx/SCFToCalyx.cpp b/lib/Conversion/SCFToCalyx/SCFToCalyx.cpp
index 0da7ce8e6..50af96397 100644
--- a/lib/Conversion/SCFToCalyx/SCFToCalyx.cpp
+++ b/lib/Conversion/SCFToCalyx/SCFToCalyx.cpp
@@ -1227,11 +1227,7 @@ public:
       return failure();
 
     // Program conversion
-    RewritePatternSet conversionPatterns(&getContext());
-    conversionPatterns.add<calyx::ModuleOpConversion>(&getContext(),
-                                                      topLevelFunction);
-    return applyOpPatternsAndFold(getOperation(),
-                                  std::move(conversionPatterns));
+    return calyx::applyModuleOpConversion(getOperation(), topLevelFunction);
   }
 
   /// 'Once' patterns are expected to take an additional LogicalResult&
diff --git a/lib/Dialect/Calyx/Transforms/CalyxLoweringUtils.cpp b/lib/Dialect/Calyx/Transforms/CalyxLoweringUtils.cpp
index 28ef6bb8b..77aec3231 100644
--- a/lib/Dialect/Calyx/Transforms/CalyxLoweringUtils.cpp
+++ b/lib/Dialect/Calyx/Transforms/CalyxLoweringUtils.cpp
@@ -347,19 +347,15 @@ std::string CalyxLoweringState::blockName(Block *b) {
 // ModuleOpConversion
 //===----------------------------------------------------------------------===//
 
-ModuleOpConversion::ModuleOpConversion(MLIRContext *context,
-                                       StringRef topLevelFunction)
-    : OpRewritePattern<mlir::ModuleOp>(context),
-      topLevelFunction(topLevelFunction) {}
+/// Helper to update the top-level ModuleOp to set the entrypoing function.
+LogicalResult applyModuleOpConversion(mlir::ModuleOp moduleOp,
+                                      StringRef topLevelFunction) {
 
-LogicalResult
-ModuleOpConversion::matchAndRewrite(mlir::ModuleOp moduleOp,
-                                    PatternRewriter &rewriter) const {
   if (moduleOp->hasAttr("calyx.entrypoint"))
     return failure();
 
   moduleOp->setAttr("calyx.entrypoint",
-                    rewriter.getStringAttr(topLevelFunction));
+                    StringAttr::get(moduleOp.getContext(), topLevelFunction));
   return success();
 }
 
diff --git a/lib/Dialect/Comb/CombFolds.cpp b/lib/Dialect/Comb/CombFolds.cpp
index 3eac9f673..ba3116b2a 100644
--- a/lib/Dialect/Comb/CombFolds.cpp
+++ b/lib/Dialect/Comb/CombFolds.cpp
@@ -244,14 +244,14 @@ static bool narrowOperationWidth(OpTy op, bool narrowTrailingBits,
 // Unary Operations
 //===----------------------------------------------------------------------===//
 
-OpFoldResult ReplicateOp::fold(ArrayRef<Attribute> constants) {
+OpFoldResult ReplicateOp::fold(FoldAdaptor adaptor) {
   // Replicate one time -> noop.
   if (getType().cast<IntegerType>().getWidth() ==
       getInput().getType().getIntOrFloatBitWidth())
     return getInput();
 
   // Constant fold.
-  if (auto input = constants[0].dyn_cast_or_null<IntegerAttr>()) {
+  if (auto input = adaptor.getInput().dyn_cast_or_null<IntegerAttr>()) {
     if (input.getValue().getBitWidth() == 1) {
       if (input.getValue().isZero())
         return getIntAttr(
@@ -271,9 +271,9 @@ OpFoldResult ReplicateOp::fold(ArrayRef<Attribute> constants) {
   return {};
 }
 
-OpFoldResult ParityOp::fold(ArrayRef<Attribute> constants) {
+OpFoldResult ParityOp::fold(FoldAdaptor adaptor) {
   // Constant fold.
-  if (auto input = constants[0].dyn_cast_or_null<IntegerAttr>())
+  if (auto input = adaptor.getInput().dyn_cast_or_null<IntegerAttr>())
     return getIntAttr(APInt(1, input.getValue().countPopulation() & 1),
                       getContext());
 
@@ -297,8 +297,8 @@ static Attribute constFoldBinaryOp(ArrayRef<Attribute> operands,
   return hw::ParamExprAttr::get(paramOpcode, operands[0], operands[1]);
 }
 
-OpFoldResult ShlOp::fold(ArrayRef<Attribute> operands) {
-  if (auto rhs = operands[1].dyn_cast_or_null<IntegerAttr>()) {
+OpFoldResult ShlOp::fold(FoldAdaptor adaptor) {
+  if (auto rhs = adaptor.getRhs().dyn_cast_or_null<IntegerAttr>()) {
     unsigned shift = rhs.getValue().getZExtValue();
     unsigned width = getType().getIntOrFloatBitWidth();
     if (shift == 0)
@@ -307,7 +307,7 @@ OpFoldResult ShlOp::fold(ArrayRef<Attribute> operands) {
       return getIntAttr(APInt::getZero(width), getContext());
   }
 
-  return constFoldBinaryOp(operands, hw::PEO::Shl);
+  return constFoldBinaryOp(adaptor.getOperands(), hw::PEO::Shl);
 }
 
 LogicalResult ShlOp::canonicalize(ShlOp op, PatternRewriter &rewriter) {
@@ -334,8 +334,8 @@ LogicalResult ShlOp::canonicalize(ShlOp op, PatternRewriter &rewriter) {
   return success();
 }
 
-OpFoldResult ShrUOp::fold(ArrayRef<Attribute> operands) {
-  if (auto rhs = operands[1].dyn_cast_or_null<IntegerAttr>()) {
+OpFoldResult ShrUOp::fold(FoldAdaptor adaptor) {
+  if (auto rhs = adaptor.getRhs().dyn_cast_or_null<IntegerAttr>()) {
     unsigned shift = rhs.getValue().getZExtValue();
     if (shift == 0)
       return getOperand(0);
@@ -344,7 +344,7 @@ OpFoldResult ShrUOp::fold(ArrayRef<Attribute> operands) {
     if (width <= shift)
       return getIntAttr(APInt::getZero(width), getContext());
   }
-  return constFoldBinaryOp(operands, hw::PEO::ShrU);
+  return constFoldBinaryOp(adaptor.getOperands(), hw::PEO::ShrU);
 }
 
 LogicalResult ShrUOp::canonicalize(ShrUOp op, PatternRewriter &rewriter) {
@@ -371,12 +371,12 @@ LogicalResult ShrUOp::canonicalize(ShrUOp op, PatternRewriter &rewriter) {
   return success();
 }
 
-OpFoldResult ShrSOp::fold(ArrayRef<Attribute> operands) {
-  if (auto rhs = operands[1].dyn_cast_or_null<IntegerAttr>()) {
+OpFoldResult ShrSOp::fold(FoldAdaptor adaptor) {
+  if (auto rhs = adaptor.getRhs().dyn_cast_or_null<IntegerAttr>()) {
     if (rhs.getValue().getZExtValue() == 0)
       return getOperand(0);
   }
-  return constFoldBinaryOp(operands, hw::PEO::ShrS);
+  return constFoldBinaryOp(adaptor.getOperands(), hw::PEO::ShrS);
 }
 
 LogicalResult ShrSOp::canonicalize(ShrSOp op, PatternRewriter &rewriter) {
@@ -408,13 +408,13 @@ LogicalResult ShrSOp::canonicalize(ShrSOp op, PatternRewriter &rewriter) {
 // Other Operations
 //===----------------------------------------------------------------------===//
 
-OpFoldResult ExtractOp::fold(ArrayRef<Attribute> constants) {
+OpFoldResult ExtractOp::fold(FoldAdaptor adaptor) {
   // If we are extracting the entire input, then return it.
   if (getInput().getType() == getType())
     return getInput();
 
   // Constant fold.
-  if (auto input = constants[0].dyn_cast_or_null<IntegerAttr>()) {
+  if (auto input = adaptor.getInput().dyn_cast_or_null<IntegerAttr>()) {
     unsigned dstWidth = getType().cast<IntegerType>().getWidth();
     return getIntAttr(input.getValue().lshr(getLowBit()).trunc(dstWidth),
                       getContext());
@@ -742,11 +742,13 @@ static bool canonicalizeLogicalCstWithConcat(Operation *logicalOp,
   return true;
 }
 
-OpFoldResult AndOp::fold(ArrayRef<Attribute> constants) {
+OpFoldResult AndOp::fold(FoldAdaptor adaptor) {
   APInt value = APInt::getAllOnes(getType().cast<IntegerType>().getWidth());
 
+  auto inputs = adaptor.getInputs();
+
   // and(x, 01, 10) -> 00 -- annulment.
-  for (auto operand : constants) {
+  for (auto operand : inputs) {
     if (!operand)
       continue;
     value &= operand.cast<IntegerAttr>().getValue();
@@ -755,8 +757,8 @@ OpFoldResult AndOp::fold(ArrayRef<Attribute> constants) {
   }
 
   // and(x, -1) -> x.
-  if (constants.size() == 2 && constants[1] &&
-      constants[1].cast<IntegerAttr>().getValue().isAllOnes())
+  if (inputs.size() == 2 && inputs[1] &&
+      inputs[1].cast<IntegerAttr>().getValue().isAllOnes())
     return getInputs()[0];
 
   // and(x, x, x) -> x.  This also handles and(x) -> x.
@@ -777,7 +779,7 @@ OpFoldResult AndOp::fold(ArrayRef<Attribute> constants) {
   }
 
   // Constant fold
-  return constFoldAssociativeOp(constants, hw::PEO::And);
+  return constFoldAssociativeOp(inputs, hw::PEO::And);
 }
 
 /// Returns a single common operand that all inputs of the operation `op` can
@@ -970,11 +972,11 @@ LogicalResult AndOp::canonicalize(AndOp op, PatternRewriter &rewriter) {
   return failure();
 }
 
-OpFoldResult OrOp::fold(ArrayRef<Attribute> constants) {
+OpFoldResult OrOp::fold(FoldAdaptor adaptor) {
   auto value = APInt::getZero(getType().cast<IntegerType>().getWidth());
-
+  auto inputs = adaptor.getInputs();
   // or(x, 10, 01) -> 11
-  for (auto operand : constants) {
+  for (auto operand : inputs) {
     if (!operand)
       continue;
     value |= operand.cast<IntegerAttr>().getValue();
@@ -983,8 +985,8 @@ OpFoldResult OrOp::fold(ArrayRef<Attribute> constants) {
   }
 
   // or(x, 0) -> x
-  if (constants.size() == 2 && constants[1] &&
-      constants[1].cast<IntegerAttr>().getValue().isZero())
+  if (inputs.size() == 2 && inputs[1] &&
+      inputs[1].cast<IntegerAttr>().getValue().isZero())
     return getInputs()[0];
 
   // or(x, x, x) -> x.  This also handles or(x) -> x
@@ -1005,7 +1007,7 @@ OpFoldResult OrOp::fold(ArrayRef<Attribute> constants) {
   }
 
   // Constant fold
-  return constFoldAssociativeOp(constants, hw::PEO::Or);
+  return constFoldAssociativeOp(inputs, hw::PEO::Or);
 }
 
 /// Simplify concat ops in an or op when a constant operand is present in either
@@ -1181,8 +1183,9 @@ LogicalResult OrOp::canonicalize(OrOp op, PatternRewriter &rewriter) {
   return failure();
 }
 
-OpFoldResult XorOp::fold(ArrayRef<Attribute> constants) {
+OpFoldResult XorOp::fold(FoldAdaptor adaptor) {
   auto size = getInputs().size();
+  auto inputs = adaptor.getInputs();
 
   // xor(x) -> x -- noop
   if (size == 1)
@@ -1193,8 +1196,8 @@ OpFoldResult XorOp::fold(ArrayRef<Attribute> constants) {
     return IntegerAttr::get(getType(), 0);
 
   // xor(x, 0) -> x
-  if (constants.size() == 2 && constants[1] &&
-      constants[1].cast<IntegerAttr>().getValue().isZero())
+  if (inputs.size() == 2 && inputs[1] &&
+      inputs[1].cast<IntegerAttr>().getValue().isZero())
     return getInputs()[0];
 
   // xor(xor(x,1),1) -> x
@@ -1207,7 +1210,7 @@ OpFoldResult XorOp::fold(ArrayRef<Attribute> constants) {
   }
 
   // Constant fold
-  return constFoldAssociativeOp(constants, hw::PEO::Xor);
+  return constFoldAssociativeOp(inputs, hw::PEO::Xor);
 }
 
 // xor(icmp, a, b, 1) -> xor(icmp, a, b) if icmp has one user.
@@ -1307,26 +1310,27 @@ LogicalResult XorOp::canonicalize(XorOp op, PatternRewriter &rewriter) {
   return failure();
 }
 
-OpFoldResult SubOp::fold(ArrayRef<Attribute> constants) {
+OpFoldResult SubOp::fold(FoldAdaptor adaptor) {
   // sub(x - x) -> 0
   if (getRhs() == getLhs())
     return getIntAttr(
         APInt::getZero(getLhs().getType().getIntOrFloatBitWidth()),
         getContext());
 
-  if (constants[1]) {
+  if (adaptor.getRhs()) {
     // If both are constants, we can unconditionally fold.
-    if (constants[0]) {
+    if (adaptor.getLhs()) {
       // Constant fold (c1 - c2) => (c1 + -1*c2).
       auto negOne = getIntAttr(
           APInt::getAllOnes(getLhs().getType().getIntOrFloatBitWidth()),
           getContext());
-      auto rhsNeg = hw::ParamExprAttr::get(hw::PEO::Mul, constants[1], negOne);
-      return hw::ParamExprAttr::get(hw::PEO::Add, constants[0], rhsNeg);
+      auto rhsNeg =
+          hw::ParamExprAttr::get(hw::PEO::Mul, adaptor.getRhs(), negOne);
+      return hw::ParamExprAttr::get(hw::PEO::Add, adaptor.getLhs(), rhsNeg);
     }
 
     // sub(x - 0) -> x
-    if (auto rhsC = constants[1].dyn_cast<IntegerAttr>()) {
+    if (auto rhsC = adaptor.getRhs().dyn_cast<IntegerAttr>()) {
       if (rhsC.getValue().isZero())
         return getLhs();
     }
@@ -1352,7 +1356,7 @@ LogicalResult SubOp::canonicalize(SubOp op, PatternRewriter &rewriter) {
   return failure();
 }
 
-OpFoldResult AddOp::fold(ArrayRef<Attribute> constants) {
+OpFoldResult AddOp::fold(FoldAdaptor adaptor) {
   auto size = getInputs().size();
 
   // add(x) -> x -- noop
@@ -1360,7 +1364,7 @@ OpFoldResult AddOp::fold(ArrayRef<Attribute> constants) {
     return getInputs()[0];
 
   // Constant fold constant operands.
-  return constFoldAssociativeOp(constants, hw::PEO::Add);
+  return constFoldAssociativeOp(adaptor.getOperands(), hw::PEO::Add);
 }
 
 LogicalResult AddOp::canonicalize(AddOp op, PatternRewriter &rewriter) {
@@ -1450,8 +1454,9 @@ LogicalResult AddOp::canonicalize(AddOp op, PatternRewriter &rewriter) {
   return failure();
 }
 
-OpFoldResult MulOp::fold(ArrayRef<Attribute> constants) {
+OpFoldResult MulOp::fold(FoldAdaptor adaptor) {
   auto size = getInputs().size();
+  auto inputs = adaptor.getInputs();
 
   // mul(x) -> x -- noop
   if (size == 1u)
@@ -1461,7 +1466,7 @@ OpFoldResult MulOp::fold(ArrayRef<Attribute> constants) {
   APInt value(/*numBits=*/width, 1, /*isSigned=*/false);
 
   // mul(x, 0, 1) -> 0 -- annulment
-  for (auto operand : constants) {
+  for (auto operand : inputs) {
     if (!operand)
       continue;
     value *= operand.cast<IntegerAttr>().getValue();
@@ -1470,7 +1475,7 @@ OpFoldResult MulOp::fold(ArrayRef<Attribute> constants) {
   }
 
   // Constant fold
-  return constFoldAssociativeOp(constants, hw::PEO::Mul);
+  return constFoldAssociativeOp(inputs, hw::PEO::Mul);
 }
 
 LogicalResult MulOp::canonicalize(MulOp op, PatternRewriter &rewriter) {
@@ -1537,12 +1542,12 @@ static OpFoldResult foldDiv(Op op, ArrayRef<Attribute> constants) {
   return constFoldBinaryOp(constants, isSigned ? hw::PEO::DivS : hw::PEO::DivU);
 }
 
-OpFoldResult DivUOp::fold(ArrayRef<Attribute> constants) {
-  return foldDiv<DivUOp, /*isSigned=*/false>(*this, constants);
+OpFoldResult DivUOp::fold(FoldAdaptor adaptor) {
+  return foldDiv<DivUOp, /*isSigned=*/false>(*this, adaptor.getOperands());
 }
 
-OpFoldResult DivSOp::fold(ArrayRef<Attribute> constants) {
-  return foldDiv<DivSOp, /*isSigned=*/true>(*this, constants);
+OpFoldResult DivSOp::fold(FoldAdaptor adaptor) {
+  return foldDiv<DivSOp, /*isSigned=*/true>(*this, adaptor.getOperands());
 }
 
 template <class Op, bool isSigned>
@@ -1568,24 +1573,24 @@ static OpFoldResult foldMod(Op op, ArrayRef<Attribute> constants) {
   return constFoldBinaryOp(constants, isSigned ? hw::PEO::ModS : hw::PEO::ModU);
 }
 
-OpFoldResult ModUOp::fold(ArrayRef<Attribute> constants) {
-  return foldMod<ModUOp, /*isSigned=*/false>(*this, constants);
+OpFoldResult ModUOp::fold(FoldAdaptor adaptor) {
+  return foldMod<ModUOp, /*isSigned=*/false>(*this, adaptor.getOperands());
 }
 
-OpFoldResult ModSOp::fold(ArrayRef<Attribute> constants) {
-  return foldMod<ModSOp, /*isSigned=*/true>(*this, constants);
+OpFoldResult ModSOp::fold(FoldAdaptor adaptor) {
+  return foldMod<ModSOp, /*isSigned=*/true>(*this, adaptor.getOperands());
 }
 //===----------------------------------------------------------------------===//
 // ConcatOp
 //===----------------------------------------------------------------------===//
 
 // Constant folding
-OpFoldResult ConcatOp::fold(ArrayRef<Attribute> constants) {
+OpFoldResult ConcatOp::fold(FoldAdaptor adaptor) {
   if (getNumOperands() == 1)
     return getOperand(0);
 
   // If all the operands are constant, we can fold.
-  for (auto attr : constants)
+  for (auto attr : adaptor.getInputs())
     if (!attr || !attr.isa<IntegerAttr>())
       return {};
 
@@ -1595,7 +1600,7 @@ OpFoldResult ConcatOp::fold(ArrayRef<Attribute> constants) {
 
   unsigned nextInsertion = resultWidth;
   // Insert each chunk into the result.
-  for (auto attr : constants) {
+  for (auto attr : adaptor.getInputs()) {
     auto chunk = attr.cast<IntegerAttr>().getValue();
     nextInsertion -= chunk.getBitWidth();
     result.insertBits(chunk, nextInsertion);
@@ -1766,22 +1771,22 @@ LogicalResult ConcatOp::canonicalize(ConcatOp op, PatternRewriter &rewriter) {
 // MuxOp
 //===----------------------------------------------------------------------===//
 
-OpFoldResult MuxOp::fold(ArrayRef<Attribute> constants) {
+OpFoldResult MuxOp::fold(FoldAdaptor adaptor) {
   // mux (c, b, b) -> b
   if (getTrueValue() == getFalseValue())
     return getTrueValue();
 
   // mux(0, a, b) -> b
   // mux(1, a, b) -> a
-  if (auto pred = constants[0].dyn_cast_or_null<IntegerAttr>()) {
+  if (auto pred = adaptor.getCond().dyn_cast_or_null<IntegerAttr>()) {
     if (pred.getValue().isZero())
       return getFalseValue();
     return getTrueValue();
   }
 
   // mux(cond, 1, 0) -> cond
-  if (auto tv = constants[1].dyn_cast_or_null<IntegerAttr>())
-    if (auto fv = constants[2].dyn_cast_or_null<IntegerAttr>())
+  if (auto tv = adaptor.getTrueValue().dyn_cast_or_null<IntegerAttr>())
+    if (auto fv = adaptor.getFalseValue().dyn_cast_or_null<IntegerAttr>())
       if (tv.getValue().isOne() && fv.getValue().isZero() &&
           hw::getBitWidth(getType()) == 1)
         return getCond();
@@ -2581,7 +2586,7 @@ static bool applyCmpPredicateToEqualOperands(ICmpPredicate predicate) {
   llvm_unreachable("unknown comparison predicate");
 }
 
-OpFoldResult ICmpOp::fold(ArrayRef<Attribute> constants) {
+OpFoldResult ICmpOp::fold(FoldAdaptor adaptor) {
   // gt a, a -> false
   // gte a, a -> true
   if (getLhs() == getRhs()) {
@@ -2590,8 +2595,8 @@ OpFoldResult ICmpOp::fold(ArrayRef<Attribute> constants) {
   }
 
   // gt 1, 2 -> false
-  if (auto lhs = constants[0].dyn_cast_or_null<IntegerAttr>()) {
-    if (auto rhs = constants[1].dyn_cast_or_null<IntegerAttr>()) {
+  if (auto lhs = adaptor.getLhs().dyn_cast_or_null<IntegerAttr>()) {
+    if (auto rhs = adaptor.getRhs().dyn_cast_or_null<IntegerAttr>()) {
       auto val =
           applyCmpPredicate(getPredicate(), lhs.getValue(), rhs.getValue());
       return IntegerAttr::get(getType(), val);
diff --git a/lib/Dialect/ESI/ESIFolds.cpp b/lib/Dialect/ESI/ESIFolds.cpp
index 49f4940e8..9ed82f0f6 100644
--- a/lib/Dialect/ESI/ESIFolds.cpp
+++ b/lib/Dialect/ESI/ESIFolds.cpp
@@ -14,7 +14,7 @@
 using namespace circt;
 using namespace circt::esi;
 
-LogicalResult WrapValidReadyOp::fold(ArrayRef<Attribute> operands,
+LogicalResult WrapValidReadyOp::fold(FoldAdaptor,
                                      SmallVectorImpl<OpFoldResult> &results) {
   if (!getChanOutput().getUsers().empty())
     return failure();
diff --git a/lib/Dialect/ESI/ESIOps.cpp b/lib/Dialect/ESI/ESIOps.cpp
index f94db5727..d64f96a66 100644
--- a/lib/Dialect/ESI/ESIOps.cpp
+++ b/lib/Dialect/ESI/ESIOps.cpp
@@ -11,10 +11,12 @@
 //===----------------------------------------------------------------------===//
 
 #include "circt/Dialect/ESI/ESIOps.h"
+#include "circt/Dialect/HW/HWOpInterfaces.h"
 #include "circt/Dialect/HW/HWTypes.h"
 #include "circt/Dialect/SV/SVOps.h"
 #include "circt/Dialect/SV/SVTypes.h"
 #include "circt/Support/LLVM.h"
+
 #include "mlir/IR/Builders.h"
 #include "mlir/IR/BuiltinTypes.h"
 #include "mlir/IR/SymbolTable.h"
@@ -51,7 +53,7 @@ ParseResult ChannelBufferOp::parse(OpAsmParser &parser,
 }
 
 void ChannelBufferOp::print(OpAsmPrinter &p) {
-  p << " " << getClk() << ", " << getRst() << ", " << getInput() << " ";
+  p << " " << getClk() << ", " << getRst() << ", " << getInput();
   p.printOptionalAttrDict((*this)->getAttrs());
   p << " : " << innerType();
 }
@@ -86,7 +88,7 @@ ParseResult PipelineStageOp::parse(OpAsmParser &parser,
 }
 
 void PipelineStageOp::print(OpAsmPrinter &p) {
-  p << " " << getClk() << ", " << getRst() << ", " << getInput() << " ";
+  p << " " << getClk() << ", " << getRst() << ", " << getInput();
   p.printOptionalAttrDict((*this)->getAttrs());
   p << " : " << innerType();
 }
@@ -422,6 +424,33 @@ void ServiceImplementReqOp::gatherPairedReqs(
   }
 }
 
+//===----------------------------------------------------------------------===//
+// Structural ops.
+//===----------------------------------------------------------------------===//
+
+LogicalResult ESIPureModuleOp::verify() {
+  ESIDialect *esiDialect = getContext()->getLoadedDialect<ESIDialect>();
+
+  Block &body = getBody().front();
+  for (Operation &op : body.getOperations()) {
+    if (hw::HWInstanceLike inst = dyn_cast<hw::HWInstanceLike>(op)) {
+      if (llvm::any_of(op.getOperands(),
+                       [](Value v) { return !v.getType().isa<ChannelType>(); }))
+        return inst.emitOpError(
+            "instances in ESI pure modules can only contain channel ports");
+      if (llvm::any_of(op.getResultTypes(),
+                       [](Type t) { return !t.isa<ChannelType>(); }))
+        return inst.emitOpError(
+            "instances in ESI pure modules can only contain channel ports");
+    } else {
+      // Pure modules can only contain instance ops and ESI ops.
+      if (op.getDialect() != esiDialect)
+        return op.emitOpError("operation not allowed in ESI pure modules");
+    }
+  }
+  return success();
+}
+
 #define GET_OP_CLASSES
 #include "circt/Dialect/ESI/ESI.cpp.inc"
 
diff --git a/lib/Dialect/ESI/ESIPasses.cpp b/lib/Dialect/ESI/ESIPasses.cpp
index ba4b9764f..5ef987081 100644
--- a/lib/Dialect/ESI/ESIPasses.cpp
+++ b/lib/Dialect/ESI/ESIPasses.cpp
@@ -438,33 +438,37 @@ bool ESIPortsPass::updateFunc(HWModuleOp mod) {
 
   // 'Ready' signals are outputs. Remember them for later when we deal with the
   // returns.
-  SmallVector<std::pair<Value, StringAttr>, 8> newReadySignals;
+  SmallVector<std::tuple<Value, StringAttr, Location>, 8> newReadySignals;
   SmallVector<Attribute> newArgNames;
+  SmallVector<Attribute> newArgLocs;
 
   for (size_t argNum = 0, blockArgNum = 0, e = mod.getNumArguments();
        argNum < e; ++argNum, ++blockArgNum) {
     Type argTy = funcType.getInput(argNum);
     auto argNameAttr = getModuleArgumentNameAttr(mod, argNum);
+    auto argLocAttr = getModuleArgumentLocAttr(mod, argNum);
 
     auto chanTy = argTy.dyn_cast<ChannelType>();
     if (!chanTy) {
       // If not ESI, pass through.
       newArgTypes.push_back(argTy);
       newArgNames.push_back(argNameAttr);
+      newArgLocs.push_back(argLocAttr);
       continue;
     }
     // When we find one, add a data and valid signal to the new args.
     Value data;
     newArgTypes.push_back(chanTy.getInner());
     newArgNames.push_back(argNameAttr);
-    data = mod.front().insertArgument(blockArgNum, chanTy.getInner(),
-                                      mod.getArgument(argNum).getLoc());
+    newArgLocs.push_back(argLocAttr);
+    data =
+        mod.front().insertArgument(blockArgNum, chanTy.getInner(), argLocAttr);
     ++blockArgNum;
 
     newArgTypes.push_back(i1);
     newArgNames.push_back(appendToRtlName(argNameAttr, "_valid"));
-    Value valid = mod.front().insertArgument(blockArgNum, i1,
-                                             mod.getArgument(argNum).getLoc());
+    newArgLocs.push_back(argLocAttr);
+    Value valid = mod.front().insertArgument(blockArgNum, i1, argLocAttr);
     ++blockArgNum;
     // Build the ESI wrap operation to translate the lowered signals to what
     // they were. (A later pass takes care of eliminating the ESI ops.)
@@ -476,8 +480,8 @@ bool ESIPortsPass::updateFunc(HWModuleOp mod) {
     // Delete the ESI port block argument.
     mod.front().eraseArgument(blockArgNum);
     --blockArgNum;
-    newReadySignals.push_back(std::make_pair(
-        wrap.getReady(), appendToRtlName(argNameAttr, "_ready")));
+    newReadySignals.emplace_back(
+        wrap.getReady(), appendToRtlName(argNameAttr, "_ready"), argLocAttr);
     updated = true;
   }
 
@@ -486,6 +490,7 @@ bool ESIPortsPass::updateFunc(HWModuleOp mod) {
   SmallVector<Type, 8> newResultTypes;
   SmallVector<Value, 8> newOutputOperands;
   SmallVector<Attribute> newResultNames;
+  SmallVector<Attribute> newResultLocs;
 
   modBuilder.setInsertionPointToEnd(mod.getBodyBlock());
   for (size_t resNum = 0, numRes = funcType.getNumResults(); resNum < numRes;
@@ -494,36 +499,41 @@ bool ESIPortsPass::updateFunc(HWModuleOp mod) {
     auto chanTy = resTy.dyn_cast<ChannelType>();
     Value oldOutputValue = outOp.getOperand(resNum);
     auto oldResultName = getModuleResultNameAttr(mod, resNum);
+    auto oldResultLoc = getModuleResultLocAttr(mod, resNum);
     if (!chanTy) {
       // If not ESI, pass through.
       newResultTypes.push_back(resTy);
       newResultNames.push_back(oldResultName);
+      newResultLocs.push_back(oldResultLoc);
       newOutputOperands.push_back(oldOutputValue);
       continue;
     }
 
     // Lower the output, adding ready signals directly to the arg list.
-    Value ready = mod.front().addArgument(
-        i1, modBuilder.getUnknownLoc()); // Ready block arg.
+    Value ready = mod.front().addArgument(i1, oldResultLoc); // Ready block arg.
     auto unwrap = modBuilder.create<UnwrapValidReadyOp>(oldOutputValue, ready);
     newOutputOperands.push_back(unwrap.getRawOutput());
     newResultTypes.push_back(chanTy.getInner()); // Raw data.
     newResultNames.push_back(oldResultName);
+    newResultLocs.push_back(oldResultLoc);
 
     newResultTypes.push_back(i1); // Valid.
     newOutputOperands.push_back(unwrap.getValid());
     newResultNames.push_back(appendToRtlName(oldResultName, "_valid"));
+    newResultLocs.push_back(oldResultLoc);
 
     newArgTypes.push_back(i1); // Ready func arg.
     newArgNames.push_back(appendToRtlName(oldResultName, "_ready"));
+    newArgLocs.push_back(oldResultLoc);
     updated = true;
   }
 
   // Append the ready list signals we remembered above.
-  for (const auto &readySig : newReadySignals) {
+  for (auto [value, name, location] : newReadySignals) {
     newResultTypes.push_back(i1);
-    newResultNames.push_back(readySig.second);
-    newOutputOperands.push_back(readySig.first);
+    newOutputOperands.push_back(value);
+    newResultNames.push_back(name);
+    newResultLocs.push_back(location);
   }
 
   if (!updated)
@@ -537,7 +547,9 @@ bool ESIPortsPass::updateFunc(HWModuleOp mod) {
   auto newFuncType = modBuilder.getFunctionType(newArgTypes, newResultTypes);
   mod.setType(newFuncType);
   setModuleArgumentNames(mod, newArgNames);
+  setModuleArgumentLocs(mod, newArgLocs);
   setModuleResultNames(mod, newResultNames);
+  setModuleResultLocs(mod, newResultLocs);
   return true;
 }
 
@@ -639,7 +651,7 @@ bool ESIPortsPass::updateFunc(HWModuleExternOp mod) {
 
   bool updated = false;
 
-  SmallVector<Attribute> newArgNames, newResultNames;
+  SmallVector<Attribute> newArgNames, newArgLocs, newResultNames, newResultLocs;
 
   // Reconstruct the list of operand types, changing the type whenever an ESI
   // port is found.
@@ -647,7 +659,9 @@ bool ESIPortsPass::updateFunc(HWModuleExternOp mod) {
   size_t nextArgNo = 0;
   for (auto argTy : mod.getArgumentTypes()) {
     auto chanTy = argTy.dyn_cast<ChannelType>();
-    newArgNames.push_back(getModuleArgumentNameAttr(mod, nextArgNo++));
+    newArgNames.push_back(getModuleArgumentNameAttr(mod, nextArgNo));
+    newArgLocs.push_back(getModuleArgumentLocAttr(mod, nextArgNo));
+    nextArgNo++;
 
     if (!chanTy) {
       newArgTypes.push_back(argTy);
@@ -672,9 +686,11 @@ bool ESIPortsPass::updateFunc(HWModuleExternOp mod) {
     Type resTy = funcType.getResult(resNum);
     auto chanTy = resTy.dyn_cast<ChannelType>();
     auto resNameAttr = getModuleResultNameAttr(mod, resNum);
+    auto resLocAttr = getModuleResultLocAttr(mod, resNum);
     if (!chanTy) {
       newResultTypes.push_back(resTy);
       newResultNames.push_back(resNameAttr);
+      newResultLocs.push_back(resLocAttr);
       continue;
     }
 
@@ -684,6 +700,7 @@ bool ESIPortsPass::updateFunc(HWModuleExternOp mod) {
     ModportType sinkPort = iface.getModportType(ESIHWBuilder::sinkStr);
     newArgTypes.push_back(sinkPort);
     newArgNames.push_back(resNameAttr);
+    newArgLocs.push_back(resLocAttr);
     updated = true;
   }
 
@@ -694,7 +711,9 @@ bool ESIPortsPass::updateFunc(HWModuleExternOp mod) {
   auto newFuncType = FunctionType::get(ctxt, newArgTypes, newResultTypes);
   mod.setType(newFuncType);
   setModuleArgumentNames(mod, newArgNames);
+  setModuleArgumentLocs(mod, newArgLocs);
   setModuleResultNames(mod, newResultNames);
+  setModuleResultLocs(mod, newResultLocs);
   return true;
 }
 
diff --git a/lib/Dialect/FIRRTL/CHIRRTLDialect.cpp b/lib/Dialect/FIRRTL/CHIRRTLDialect.cpp
index c1043c6a4..08c27fe57 100644
--- a/lib/Dialect/FIRRTL/CHIRRTLDialect.cpp
+++ b/lib/Dialect/FIRRTL/CHIRRTLDialect.cpp
@@ -104,7 +104,7 @@ static void printNameKind(OpAsmPrinter &p, Operation *op,
                           firrtl::NameKindEnumAttr attr,
                           ArrayRef<StringRef> extraElides = {}) {
   if (attr.getValue() != NameKindEnum::DroppableName)
-    p << stringifyNameKindEnum(attr.getValue());
+    p << " " << stringifyNameKindEnum(attr.getValue());
 }
 
 //===----------------------------------------------------------------------===//
@@ -253,11 +253,12 @@ static void printCombMemOp(OpAsmPrinter &p, Operation *op,
 void CombMemOp::build(OpBuilder &builder, OperationState &result,
                       FIRRTLBaseType elementType, uint64_t numElements,
                       StringRef name, NameKindEnum nameKind,
-                      ArrayAttr annotations, StringAttr innerSym) {
+                      ArrayAttr annotations, StringAttr innerSym,
+                      MemoryInitAttr init) {
   build(builder, result,
         CMemoryType::get(builder.getContext(), elementType, numElements), name,
         nameKind, annotations,
-        innerSym ? hw::InnerSymAttr::get(innerSym) : hw::InnerSymAttr());
+        innerSym ? hw::InnerSymAttr::get(innerSym) : hw::InnerSymAttr(), init);
 }
 
 void CombMemOp::getAsmResultNames(OpAsmSetValueNameFn setNameFn) {
@@ -281,11 +282,12 @@ static void printSeqMemOp(OpAsmPrinter &p, Operation *op, DictionaryAttr attr) {
 void SeqMemOp::build(OpBuilder &builder, OperationState &result,
                      FIRRTLBaseType elementType, uint64_t numElements,
                      RUWAttr ruw, StringRef name, NameKindEnum nameKind,
-                     ArrayAttr annotations, StringAttr innerSym) {
+                     ArrayAttr annotations, StringAttr innerSym,
+                     MemoryInitAttr init) {
   build(builder, result,
         CMemoryType::get(builder.getContext(), elementType, numElements), ruw,
         name, nameKind, annotations,
-        innerSym ? hw::InnerSymAttr::get(innerSym) : hw::InnerSymAttr());
+        innerSym ? hw::InnerSymAttr::get(innerSym) : hw::InnerSymAttr(), init);
 }
 
 void SeqMemOp::getAsmResultNames(OpAsmSetValueNameFn setNameFn) {
diff --git a/lib/Dialect/FIRRTL/FIRRTLAnnotationHelper.cpp b/lib/Dialect/FIRRTL/FIRRTLAnnotationHelper.cpp
index ebcd5d86e..21c7101a5 100644
--- a/lib/Dialect/FIRRTL/FIRRTLAnnotationHelper.cpp
+++ b/lib/Dialect/FIRRTL/FIRRTLAnnotationHelper.cpp
@@ -353,76 +353,6 @@ InstanceOp firrtl::addPortsToModule(
   return clonedInstOnPath;
 }
 
-Value firrtl::borePortsOnPath(
-    SmallVector<InstanceOp> &instancePath, FModuleOp lcaModule, Value fromVal,
-    StringRef newNameHint, InstancePathCache &instancePathcache,
-    llvm::function_ref<ModuleNamespace &(FModuleLike)> getNamespace,
-    CircuitTargetCache *targetCachesInstancePathCache) {
-  // Create connections of the `fromVal` by adding ports through all the
-  // instances of `instancePath`. `instancePath` specifies a path from a source
-  // module through the lcaModule till a target module. source module is the
-  // parent module of `fromval` and target module is the referenced target
-  // module of the last instance in the instancePath.
-
-  // If instancePath empty then just return the `fromVal`.
-  if (instancePath.empty())
-    return fromVal;
-
-  FModuleOp srcModule;
-  if (auto block = fromVal.dyn_cast<BlockArgument>())
-    srcModule = cast<FModuleOp>(block.getOwner()->getParentOp());
-  else
-    srcModule = fromVal.getDefiningOp()->getParentOfType<FModuleOp>();
-
-  // If the `srcModule` is the `lcaModule`, then we only need to drill input
-  // ports starting from the `lcaModule` till the end of `instancePath`. For all
-  // other cases, we start to drill output ports from the `srcModule` till the
-  // `lcaModule`, and then input ports from `lcaModule` till the end of
-  // `instancePath`.
-  Direction dir = Direction::Out;
-  if (srcModule == lcaModule)
-    dir = Direction::In;
-
-  auto valType = fromVal.getType().cast<FIRRTLType>();
-  auto forwardVal = fromVal;
-  for (auto instOnPath : instancePath) {
-    auto referencedModule = cast<FModuleOp>(
-        instancePathcache.instanceGraph.getReferencedModule(instOnPath));
-    unsigned portNo = referencedModule.getNumPorts();
-    // Add a new port to referencedModule, and all its uses/instances.
-    InstanceOp clonedInst = addPortsToModule(
-        referencedModule, instOnPath, valType, dir, newNameHint,
-        instancePathcache, getNamespace, targetCachesInstancePathCache);
-    //  `instOnPath` will be erased and replaced with `clonedInst`. So, there
-    //  should be no more use of `instOnPath`.
-    auto clonedInstRes = clonedInst.getResult(portNo);
-    auto referencedModNewPort = referencedModule.getArgument(portNo);
-    // If out direction, then connect `forwardVal` to the `referencedModNewPort`
-    // (the new port of referenced module) else set the new input port of the
-    // cloned instance with `forwardVal`. If out direction, then set the
-    // `forwardVal` to the result of the cloned instance, else set the
-    // `forwardVal` to the new port of the referenced module.
-    if (dir == Direction::Out) {
-      auto builder = ImplicitLocOpBuilder::atBlockEnd(
-          forwardVal.getLoc(), forwardVal.isa<BlockArgument>()
-                                   ? referencedModule.getBodyBlock()
-                                   : forwardVal.getDefiningOp()->getBlock());
-      builder.create<ConnectOp>(referencedModNewPort, forwardVal);
-      forwardVal = clonedInstRes;
-    } else {
-      auto builder = ImplicitLocOpBuilder::atBlockEnd(clonedInst.getLoc(),
-                                                      clonedInst->getBlock());
-      builder.create<ConnectOp>(clonedInstRes, forwardVal);
-      forwardVal = referencedModNewPort;
-    }
-
-    // Switch direction of reached the `lcaModule`.
-    if (clonedInst->getParentOfType<FModuleOp>() == lcaModule)
-      dir = Direction::In;
-  }
-  return forwardVal;
-}
-
 //===----------------------------------------------------------------------===//
 // AnnoTargetCache
 //===----------------------------------------------------------------------===//
@@ -436,72 +366,6 @@ void AnnoTargetCache::gatherTargets(FModuleLike mod) {
   mod.walk([&](Operation *op) { insertOp(op); });
 }
 
-LogicalResult
-firrtl::findLCAandSetPath(AnnoPathValue &srcTarget, AnnoPathValue &dstTarget,
-                          SmallVector<InstanceOp> &pathFromSrcToDst,
-                          FModuleOp &lcaModule, ApplyState &state) {
-
-  auto srcModule = cast<FModuleOp>(srcTarget.ref.getModule().getOperation());
-  auto dstModule = cast<FModuleOp>(dstTarget.ref.getModule().getOperation());
-  // Get the path from top to `srcModule` and `dstModule`, and then compare the
-  // path to find the lca. Then use that to get the path from `srcModule` to the
-  // `dstModule`.
-  pathFromSrcToDst.clear();
-  if (srcModule == dstModule) {
-    lcaModule = srcModule;
-    return success();
-  }
-  auto *top = state.instancePathCache.instanceGraph.getTopLevelNode();
-  lcaModule = cast<FModuleOp>(top->getModule().getOperation());
-  auto initializeInstances = [&](SmallVector<InstanceOp> &instances,
-                                 FModuleLike targetModule) -> LogicalResult {
-    if (!instances.empty())
-      return success();
-    auto instancePathsFromTop = state.instancePathCache.getAbsolutePaths(
-        cast<hw::HWModuleLike>(*targetModule));
-    if (instancePathsFromTop.size() > 1)
-      return targetModule->emitError("cannot handle multiple paths to target");
-
-    // Get the path from top to dst
-    for (auto inst : instancePathsFromTop.back())
-      instances.push_back(cast<InstanceOp>(inst));
-    return success();
-  };
-  if (initializeInstances(dstTarget.instances, dstModule).failed() ||
-      initializeInstances(srcTarget.instances, srcModule).failed())
-    return failure();
-
-  auto &dstPathFromTop = dstTarget.instances;
-  // A map of the modules in the path from top to dst to its index into the
-  // `dstPathFromTop`.
-  DenseMap<FModuleOp, size_t> dstPathMap;
-  // Initialize the leaf module, to end of path.
-  dstPathMap[dstModule] = dstPathFromTop.size();
-  for (auto &dstInstance : llvm::enumerate(dstPathFromTop))
-    dstPathMap[dstInstance.value()->getParentOfType<FModuleOp>()] =
-        dstInstance.index();
-  auto *dstPathIterator = dstPathFromTop.begin();
-  // Now, reverse iterate over the path of the source, from the source module to
-  // the Top.
-  for (auto srcInstPath : llvm::reverse(srcTarget.instances)) {
-    auto refModule = cast<FModuleOp>(
-        state.instancePathCache.instanceGraph.getReferencedModule(srcInstPath)
-            .getOperation());
-    auto mapIter = dstPathMap.find(refModule);
-    // If `refModule` exists on the dst path, then this is the Lowest Common
-    // Ancestor between the source and dst module.
-    if (mapIter != dstPathMap.end()) {
-      lcaModule = refModule;
-      dstPathIterator += mapIter->getSecond();
-      break;
-    }
-    pathFromSrcToDst.push_back(srcInstPath);
-  }
-  pathFromSrcToDst.insert(pathFromSrcToDst.end(), dstPathIterator,
-                          dstPathFromTop.end());
-  return success();
-}
-
 //===----------------------------------------------------------------------===//
 // Code related to handling Grand Central Data/Mem Taps annotations
 //===----------------------------------------------------------------------===//
@@ -548,13 +412,22 @@ static Value lowerInternalPathAnno(AnnoPathValue &srcTarget,
   // module. This also updates all the instances of the external module.
   // This removes and replaces the instance, and returns the updated
   // instance.
-  modInstance = addPortsToModule(
-      mod, modInstance, portRefType, Direction::Out, refName,
-      state.instancePathCache,
-      [&](FModuleLike mod) -> ModuleNamespace & {
-        return state.getNamespace(mod);
-      },
-      &state.targetCaches);
+  if (!state.wiringProblemInstRefs.contains(modInstance)) {
+    modInstance = addPortsToModule(
+        mod, modInstance, portRefType, Direction::Out, refName,
+        state.instancePathCache,
+        [&](FModuleLike mod) -> ModuleNamespace & {
+          return state.getNamespace(mod);
+        },
+        &state.targetCaches);
+  } else {
+    // As a current limitation, mixing legacy Wiring and Data Taps is forbidden
+    // to prevent invalidating Values used later
+    mod->emitOpError(
+        "cannot be used for both legacy Wiring and DataTaps simultaneously");
+    return nullptr;
+  }
+
   // Since the instance op generates the RefType output, no need of another
   // RefSendOp.  Store into an op to ensure we have stable reference,
   // so future tapping won't invalidate this Value.
@@ -786,7 +659,8 @@ LogicalResult circt::firrtl::applyGCTDataTaps(const AnnoPathValue &target,
             [&](auto v) { return sinkBuilder.create<AsAsyncResetPrimOp>(v); });
     }
 
-    state.wiringProblems.push_back({sendVal, sink, ""});
+    state.wiringProblems.push_back(
+        {sendVal, sink, "", WiringProblem::RefTypeUsage::Prefer});
   }
 
   return success();
@@ -874,6 +748,7 @@ LogicalResult circt::firrtl::applyGCTMemTaps(const AnnoPathValue &target,
         "cannot generate the MemTap, wiretap Type does not match the memory "
         "type");
   auto sink = wireTarget->ref.getOp()->getResult(0);
-  state.wiringProblems.push_back({sendVal, sink, "memTap"});
+  state.wiringProblems.push_back(
+      {sendVal, sink, "memTap", WiringProblem::RefTypeUsage::Prefer});
   return success();
 }
diff --git a/lib/Dialect/FIRRTL/FIRRTLFolds.cpp b/lib/Dialect/FIRRTL/FIRRTLFolds.cpp
index 9d388f575..02e9ddd42 100644
--- a/lib/Dialect/FIRRTL/FIRRTLFolds.cpp
+++ b/lib/Dialect/FIRRTL/FIRRTLFolds.cpp
@@ -194,10 +194,9 @@ enum class BinOpKind {
 /// result type if \p useDstWidth is true, else to the larger of the two operand
 /// bit widths and depending on whether the operation is to be performed on
 /// signed or unsigned operands.
-static Attribute
-constFoldFIRRTLBinaryOp(Operation *op, ArrayRef<Attribute> operands,
-                        BinOpKind opKind,
-                        const function_ref<APInt(APSInt, APSInt)> &calculate) {
+static Attribute constFoldFIRRTLBinaryOp(
+    Operation *op, ArrayRef<Attribute> operands, BinOpKind opKind,
+    const function_ref<APInt(const APSInt &, const APSInt &)> &calculate) {
   assert(operands.size() == 2 && "binary op takes two operands");
 
   // We cannot fold something to an unknown width.
@@ -288,7 +287,7 @@ static LogicalResult canonicalizePrimOp(
     Attribute attr;
     if (auto *defOp = operand.getDefiningOp())
       TypeSwitch<Operation *>(defOp).Case<ConstantOp, SpecialConstantOp>(
-          [&](auto op) { attr = op.fold({}).template get<Attribute>(); });
+          [&](auto op) { attr = op.getValueAttr(); });
     constOperands.push_back(attr);
   }
 
@@ -343,18 +342,18 @@ static APInt getMaxSignedValue(unsigned bitWidth) {
 // Fold Hooks
 //===----------------------------------------------------------------------===//
 
-OpFoldResult ConstantOp::fold(ArrayRef<Attribute> operands) {
-  assert(operands.empty() && "constant has no operands");
+OpFoldResult ConstantOp::fold(FoldAdaptor adaptor) {
+  assert(adaptor.getOperands().empty() && "constant has no operands");
   return getValueAttr();
 }
 
-OpFoldResult SpecialConstantOp::fold(ArrayRef<Attribute> operands) {
-  assert(operands.empty() && "constant has no operands");
+OpFoldResult SpecialConstantOp::fold(FoldAdaptor adaptor) {
+  assert(adaptor.getOperands().empty() && "constant has no operands");
   return getValueAttr();
 }
 
-OpFoldResult AggregateConstantOp::fold(ArrayRef<Attribute> operands) {
-  assert(operands.empty() && "constant has no operands");
+OpFoldResult AggregateConstantOp::fold(FoldAdaptor adaptor) {
+  assert(adaptor.getOperands().empty() && "constant has no operands");
   return getFieldsAttr();
 }
 
@@ -362,9 +361,10 @@ OpFoldResult AggregateConstantOp::fold(ArrayRef<Attribute> operands) {
 // Binary Operators
 //===----------------------------------------------------------------------===//
 
-OpFoldResult AddPrimOp::fold(ArrayRef<Attribute> operands) {
-  return constFoldFIRRTLBinaryOp(*this, operands, BinOpKind::Normal,
-                                 [=](APSInt a, APSInt b) { return a + b; });
+OpFoldResult AddPrimOp::fold(FoldAdaptor adaptor) {
+  return constFoldFIRRTLBinaryOp(
+      *this, adaptor.getOperands(), BinOpKind::Normal,
+      [=](const APSInt &a, const APSInt &b) { return a + b; });
 }
 
 void AddPrimOp::getCanonicalizationPatterns(RewritePatternSet &results,
@@ -374,9 +374,10 @@ void AddPrimOp::getCanonicalizationPatterns(RewritePatternSet &results,
           context);
 }
 
-OpFoldResult SubPrimOp::fold(ArrayRef<Attribute> operands) {
-  return constFoldFIRRTLBinaryOp(*this, operands, BinOpKind::Normal,
-                                 [=](APSInt a, APSInt b) { return a - b; });
+OpFoldResult SubPrimOp::fold(FoldAdaptor adaptor) {
+  return constFoldFIRRTLBinaryOp(
+      *this, adaptor.getOperands(), BinOpKind::Normal,
+      [=](const APSInt &a, const APSInt &b) { return a - b; });
 }
 
 void SubPrimOp::getCanonicalizationPatterns(RewritePatternSet &results,
@@ -385,21 +386,22 @@ void SubPrimOp::getCanonicalizationPatterns(RewritePatternSet &results,
                  patterns::SubFromZeroUnsigned, patterns::SubOfSelf>(context);
 }
 
-OpFoldResult MulPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult MulPrimOp::fold(FoldAdaptor adaptor) {
   // mul(x, 0) -> 0
   //
   // This is legal because it aligns with the Scala FIRRTL Compiler
   // interpretation of lowering invalid to constant zero before constant
   // propagation.  Note: the Scala FIRRTL Compiler does NOT currently optimize
   // multiplication this way and will emit "x * 0".
-  if (isConstantZero(operands[1]) || isConstantZero(operands[0]))
+  if (isConstantZero(adaptor.getRhs()) || isConstantZero(adaptor.getLhs()))
     return getIntZerosAttr(getType());
 
-  return constFoldFIRRTLBinaryOp(*this, operands, BinOpKind::Normal,
-                                 [=](APSInt a, APSInt b) { return a * b; });
+  return constFoldFIRRTLBinaryOp(
+      *this, adaptor.getOperands(), BinOpKind::Normal,
+      [=](const APSInt &a, const APSInt &b) { return a * b; });
 }
 
-OpFoldResult DivPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult DivPrimOp::fold(FoldAdaptor adaptor) {
   /// div(x, x) -> 1
   ///
   /// Division by zero is undefined in the FIRRTL specification.  This fold
@@ -421,7 +423,7 @@ OpFoldResult DivPrimOp::fold(ArrayRef<Attribute> operands) {
   // interpretation of lowering invalid to constant zero before constant
   // propagation.  Note: the Scala FIRRTL Compiler does NOT currently optimize
   // division this way and will emit "0 / x".
-  if (isConstantZero(operands[0]) && !isConstantZero(operands[1]))
+  if (isConstantZero(adaptor.getLhs()) && !isConstantZero(adaptor.getRhs()))
     return getIntZerosAttr(getType());
 
   /// div(x, 1) -> x : (uint, uint) -> uint
@@ -429,19 +431,20 @@ OpFoldResult DivPrimOp::fold(ArrayRef<Attribute> operands) {
   /// UInt division by one returns the numerator. SInt division can't
   /// be folded here because it increases the return type bitwidth by
   /// one and requires sign extension (a new op).
-  if (auto rhsCst = operands[1].dyn_cast_or_null<IntegerAttr>())
+  if (auto rhsCst = adaptor.getRhs().dyn_cast_or_null<IntegerAttr>())
     if (rhsCst.getValue().isOne() && getLhs().getType() == getType())
       return getLhs();
 
-  return constFoldFIRRTLBinaryOp(*this, operands, BinOpKind::DivideOrShift,
-                                 [=](APSInt a, APSInt b) -> APInt {
-                                   if (!!b)
-                                     return a / b;
-                                   return APInt(a.getBitWidth(), 0);
-                                 });
+  return constFoldFIRRTLBinaryOp(
+      *this, adaptor.getOperands(), BinOpKind::DivideOrShift,
+      [=](const APSInt &a, const APSInt &b) -> APInt {
+        if (!!b)
+          return a / b;
+        return APInt(a.getBitWidth(), 0);
+      });
 }
 
-OpFoldResult RemPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult RemPrimOp::fold(FoldAdaptor adaptor) {
   // rem(x, x) -> 0
   //
   // Division by zero is undefined in the FIRRTL specification.  This fold
@@ -457,42 +460,42 @@ OpFoldResult RemPrimOp::fold(ArrayRef<Attribute> operands) {
   // interpretation of lowering invalid to constant zero before constant
   // propagation.  Note: the Scala FIRRTL Compiler does NOT currently optimize
   // division this way and will emit "0 % x".
-  if (isConstantZero(operands[0]))
+  if (isConstantZero(adaptor.getLhs()))
     return getIntZerosAttr(getType());
 
-  return constFoldFIRRTLBinaryOp(*this, operands, BinOpKind::DivideOrShift,
-                                 [=](APSInt a, APSInt b) -> APInt {
-                                   if (!!b)
-                                     return a % b;
-                                   return APInt(a.getBitWidth(), 0);
-                                 });
+  return constFoldFIRRTLBinaryOp(
+      *this, adaptor.getOperands(), BinOpKind::DivideOrShift,
+      [=](const APSInt &a, const APSInt &b) -> APInt {
+        if (!!b)
+          return a % b;
+        return APInt(a.getBitWidth(), 0);
+      });
 }
 
-OpFoldResult DShlPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult DShlPrimOp::fold(FoldAdaptor adaptor) {
   return constFoldFIRRTLBinaryOp(
-      *this, operands, BinOpKind::DivideOrShift,
-      [=](APSInt a, APSInt b) -> APInt { return a.shl(b); });
+      *this, adaptor.getOperands(), BinOpKind::DivideOrShift,
+      [=](const APSInt &a, const APSInt &b) -> APInt { return a.shl(b); });
 }
 
-OpFoldResult DShlwPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult DShlwPrimOp::fold(FoldAdaptor adaptor) {
   return constFoldFIRRTLBinaryOp(
-      *this, operands, BinOpKind::DivideOrShift,
-      [=](APSInt a, APSInt b) -> APInt { return a.shl(b); });
+      *this, adaptor.getOperands(), BinOpKind::DivideOrShift,
+      [=](const APSInt &a, const APSInt &b) -> APInt { return a.shl(b); });
 }
 
-OpFoldResult DShrPrimOp::fold(ArrayRef<Attribute> operands) {
-  return constFoldFIRRTLBinaryOp(*this, operands, BinOpKind::DivideOrShift,
-                                 [=](APSInt a, APSInt b) -> APInt {
-                                   return getType().isUnsigned() ||
-                                                  !a.getBitWidth()
-                                              ? a.lshr(b)
-                                              : a.ashr(b);
-                                 });
+OpFoldResult DShrPrimOp::fold(FoldAdaptor adaptor) {
+  return constFoldFIRRTLBinaryOp(
+      *this, adaptor.getOperands(), BinOpKind::DivideOrShift,
+      [=](const APSInt &a, const APSInt &b) -> APInt {
+        return getType().isUnsigned() || !a.getBitWidth() ? a.lshr(b)
+                                                          : a.ashr(b);
+      });
 }
 
 // TODO: Move to DRR.
-OpFoldResult AndPrimOp::fold(ArrayRef<Attribute> operands) {
-  if (auto rhsCst = getConstant(operands[1])) {
+OpFoldResult AndPrimOp::fold(FoldAdaptor adaptor) {
+  if (auto rhsCst = getConstant(adaptor.getRhs())) {
     /// and(x, 0) -> 0, 0 is largest or is implicit zero extended
     if (rhsCst->isZero())
       return getIntZerosAttr(getType());
@@ -503,7 +506,7 @@ OpFoldResult AndPrimOp::fold(ArrayRef<Attribute> operands) {
       return getLhs();
   }
 
-  if (auto lhsCst = getConstant(operands[0])) {
+  if (auto lhsCst = getConstant(adaptor.getLhs())) {
     /// and(0, x) -> 0, 0 is largest or is implicit zero extended
     if (lhsCst->isZero())
       return getIntZerosAttr(getType());
@@ -519,8 +522,8 @@ OpFoldResult AndPrimOp::fold(ArrayRef<Attribute> operands) {
     return getRhs();
 
   return constFoldFIRRTLBinaryOp(
-      *this, operands, BinOpKind::Normal,
-      [](APSInt a, APSInt b) -> APInt { return a & b; });
+      *this, adaptor.getOperands(), BinOpKind::Normal,
+      [](const APSInt &a, const APSInt &b) -> APInt { return a & b; });
 }
 
 void AndPrimOp::getCanonicalizationPatterns(RewritePatternSet &results,
@@ -530,8 +533,8 @@ void AndPrimOp::getCanonicalizationPatterns(RewritePatternSet &results,
               patterns::AndOfAllOne, patterns::AndOfSelf>(context);
 }
 
-OpFoldResult OrPrimOp::fold(ArrayRef<Attribute> operands) {
-  if (auto rhsCst = getConstant(operands[1])) {
+OpFoldResult OrPrimOp::fold(FoldAdaptor adaptor) {
+  if (auto rhsCst = getConstant(adaptor.getRhs())) {
     /// or(x, 0) -> x
     if (rhsCst->isZero() && getLhs().getType() == getType())
       return getLhs();
@@ -542,7 +545,7 @@ OpFoldResult OrPrimOp::fold(ArrayRef<Attribute> operands) {
       return getRhs();
   }
 
-  if (auto lhsCst = getConstant(operands[0])) {
+  if (auto lhsCst = getConstant(adaptor.getLhs())) {
     /// or(0, x) -> x
     if (lhsCst->isZero() && getRhs().getType() == getType())
       return getRhs();
@@ -558,8 +561,8 @@ OpFoldResult OrPrimOp::fold(ArrayRef<Attribute> operands) {
     return getRhs();
 
   return constFoldFIRRTLBinaryOp(
-      *this, operands, BinOpKind::Normal,
-      [](APSInt a, APSInt b) -> APInt { return a | b; });
+      *this, adaptor.getOperands(), BinOpKind::Normal,
+      [](const APSInt &a, const APSInt &b) -> APInt { return a | b; });
 }
 
 void OrPrimOp::getCanonicalizationPatterns(RewritePatternSet &results,
@@ -568,14 +571,14 @@ void OrPrimOp::getCanonicalizationPatterns(RewritePatternSet &results,
                  patterns::OrOfAllOne, patterns::OrOfSelf>(context);
 }
 
-OpFoldResult XorPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult XorPrimOp::fold(FoldAdaptor adaptor) {
   /// xor(x, 0) -> x
-  if (auto rhsCst = getConstant(operands[1]))
+  if (auto rhsCst = getConstant(adaptor.getRhs()))
     if (rhsCst->isZero() && getLhs().getType() == getType())
       return getLhs();
 
   /// xor(x, 0) -> x
-  if (auto lhsCst = getConstant(operands[0]))
+  if (auto lhsCst = getConstant(adaptor.getLhs()))
     if (lhsCst->isZero() && getRhs().getType() == getType())
       return getRhs();
 
@@ -585,8 +588,8 @@ OpFoldResult XorPrimOp::fold(ArrayRef<Attribute> operands) {
                       APInt(std::max(getType().getWidthOrSentinel(), 0), 0));
 
   return constFoldFIRRTLBinaryOp(
-      *this, operands, BinOpKind::Normal,
-      [](APSInt a, APSInt b) -> APInt { return a ^ b; });
+      *this, adaptor.getOperands(), BinOpKind::Normal,
+      [](const APSInt &a, const APSInt &b) -> APInt { return a ^ b; });
 }
 
 void XorPrimOp::getCanonicalizationPatterns(RewritePatternSet &results,
@@ -600,7 +603,7 @@ void LEQPrimOp::getCanonicalizationPatterns(RewritePatternSet &results,
   results.insert<patterns::LEQWithConstLHS>(context);
 }
 
-OpFoldResult LEQPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult LEQPrimOp::fold(FoldAdaptor adaptor) {
   bool isUnsigned = getLhs().getType().isa<UIntType>();
 
   // leq(x, x) -> 1
@@ -609,7 +612,7 @@ OpFoldResult LEQPrimOp::fold(ArrayRef<Attribute> operands) {
 
   // Comparison against constant outside type bounds.
   if (auto width = getLhs().getType().cast<IntType>().getWidth()) {
-    if (auto rhsCst = getConstant(operands[1])) {
+    if (auto rhsCst = getConstant(adaptor.getRhs())) {
       auto commonWidth = std::max<int32_t>(*width, rhsCst->getBitWidth());
       commonWidth = std::max(commonWidth, 1);
 
@@ -634,8 +637,10 @@ OpFoldResult LEQPrimOp::fold(ArrayRef<Attribute> operands) {
   }
 
   return constFoldFIRRTLBinaryOp(
-      *this, operands, BinOpKind::Compare,
-      [=](APSInt a, APSInt b) -> APInt { return APInt(1, a <= b); });
+      *this, adaptor.getOperands(), BinOpKind::Compare,
+      [=](const APSInt &a, const APSInt &b) -> APInt {
+        return APInt(1, a <= b);
+      });
 }
 
 void LTPrimOp::getCanonicalizationPatterns(RewritePatternSet &results,
@@ -643,7 +648,7 @@ void LTPrimOp::getCanonicalizationPatterns(RewritePatternSet &results,
   results.insert<patterns::LTWithConstLHS>(context);
 }
 
-OpFoldResult LTPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult LTPrimOp::fold(FoldAdaptor adaptor) {
   bool isUnsigned = getLhs().getType().isa<UIntType>();
 
   // lt(x, x) -> 0
@@ -651,14 +656,14 @@ OpFoldResult LTPrimOp::fold(ArrayRef<Attribute> operands) {
     return getIntAttr(getType(), APInt(1, 0));
 
   // lt(x, 0) -> 0 when x is unsigned
-  if (auto rhsCst = getConstant(operands[1])) {
+  if (auto rhsCst = getConstant(adaptor.getRhs())) {
     if (rhsCst->isZero() && getLhs().getType().isa<UIntType>())
       return getIntAttr(getType(), APInt(1, 0));
   }
 
   // Comparison against constant outside type bounds.
   if (auto width = getLhs().getType().cast<IntType>().getWidth()) {
-    if (auto rhsCst = getConstant(operands[1])) {
+    if (auto rhsCst = getConstant(adaptor.getRhs())) {
       auto commonWidth = std::max<int32_t>(*width, rhsCst->getBitWidth());
       commonWidth = std::max(commonWidth, 1);
 
@@ -683,8 +688,10 @@ OpFoldResult LTPrimOp::fold(ArrayRef<Attribute> operands) {
   }
 
   return constFoldFIRRTLBinaryOp(
-      *this, operands, BinOpKind::Compare,
-      [=](APSInt a, APSInt b) -> APInt { return APInt(1, a < b); });
+      *this, adaptor.getOperands(), BinOpKind::Compare,
+      [=](const APSInt &a, const APSInt &b) -> APInt {
+        return APInt(1, a < b);
+      });
 }
 
 void GEQPrimOp::getCanonicalizationPatterns(RewritePatternSet &results,
@@ -692,7 +699,7 @@ void GEQPrimOp::getCanonicalizationPatterns(RewritePatternSet &results,
   results.insert<patterns::GEQWithConstLHS>(context);
 }
 
-OpFoldResult GEQPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult GEQPrimOp::fold(FoldAdaptor adaptor) {
   bool isUnsigned = getLhs().getType().isa<UIntType>();
 
   // geq(x, x) -> 1
@@ -700,14 +707,14 @@ OpFoldResult GEQPrimOp::fold(ArrayRef<Attribute> operands) {
     return getIntAttr(getType(), APInt(1, 1));
 
   // geq(x, 0) -> 1 when x is unsigned
-  if (auto rhsCst = getConstant(operands[1])) {
+  if (auto rhsCst = getConstant(adaptor.getRhs())) {
     if (rhsCst->isZero() && getLhs().getType().isa<UIntType>())
       return getIntAttr(getType(), APInt(1, 1));
   }
 
   // Comparison against constant outside type bounds.
   if (auto width = getLhs().getType().cast<IntType>().getWidth()) {
-    if (auto rhsCst = getConstant(operands[1])) {
+    if (auto rhsCst = getConstant(adaptor.getRhs())) {
       auto commonWidth = std::max<int32_t>(*width, rhsCst->getBitWidth());
       commonWidth = std::max(commonWidth, 1);
 
@@ -732,8 +739,10 @@ OpFoldResult GEQPrimOp::fold(ArrayRef<Attribute> operands) {
   }
 
   return constFoldFIRRTLBinaryOp(
-      *this, operands, BinOpKind::Compare,
-      [=](APSInt a, APSInt b) -> APInt { return APInt(1, a >= b); });
+      *this, adaptor.getOperands(), BinOpKind::Compare,
+      [=](const APSInt &a, const APSInt &b) -> APInt {
+        return APInt(1, a >= b);
+      });
 }
 
 void GTPrimOp::getCanonicalizationPatterns(RewritePatternSet &results,
@@ -741,7 +750,7 @@ void GTPrimOp::getCanonicalizationPatterns(RewritePatternSet &results,
   results.insert<patterns::GTWithConstLHS>(context);
 }
 
-OpFoldResult GTPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult GTPrimOp::fold(FoldAdaptor adaptor) {
   bool isUnsigned = getLhs().getType().isa<UIntType>();
 
   // gt(x, x) -> 0
@@ -750,7 +759,7 @@ OpFoldResult GTPrimOp::fold(ArrayRef<Attribute> operands) {
 
   // Comparison against constant outside type bounds.
   if (auto width = getLhs().getType().cast<IntType>().getWidth()) {
-    if (auto rhsCst = getConstant(operands[1])) {
+    if (auto rhsCst = getConstant(adaptor.getRhs())) {
       auto commonWidth = std::max<int32_t>(*width, rhsCst->getBitWidth());
       commonWidth = std::max(commonWidth, 1);
 
@@ -775,16 +784,18 @@ OpFoldResult GTPrimOp::fold(ArrayRef<Attribute> operands) {
   }
 
   return constFoldFIRRTLBinaryOp(
-      *this, operands, BinOpKind::Compare,
-      [=](APSInt a, APSInt b) -> APInt { return APInt(1, a > b); });
+      *this, adaptor.getOperands(), BinOpKind::Compare,
+      [=](const APSInt &a, const APSInt &b) -> APInt {
+        return APInt(1, a > b);
+      });
 }
 
-OpFoldResult EQPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult EQPrimOp::fold(FoldAdaptor adaptor) {
   // eq(x, x) -> 1
   if (getLhs() == getRhs())
     return getIntAttr(getType(), APInt(1, 1));
 
-  if (auto rhsCst = getConstant(operands[1])) {
+  if (auto rhsCst = getConstant(adaptor.getRhs())) {
     /// eq(x, 1) -> x when x is 1 bit.
     /// TODO: Support SInt<1> on the LHS etc.
     if (rhsCst->isAllOnes() && getLhs().getType() == getType() &&
@@ -793,8 +804,10 @@ OpFoldResult EQPrimOp::fold(ArrayRef<Attribute> operands) {
   }
 
   return constFoldFIRRTLBinaryOp(
-      *this, operands, BinOpKind::Compare,
-      [=](APSInt a, APSInt b) -> APInt { return APInt(1, a == b); });
+      *this, adaptor.getOperands(), BinOpKind::Compare,
+      [=](const APSInt &a, const APSInt &b) -> APInt {
+        return APInt(1, a == b);
+      });
 }
 
 LogicalResult EQPrimOp::canonicalize(EQPrimOp op, PatternRewriter &rewriter) {
@@ -829,12 +842,12 @@ LogicalResult EQPrimOp::canonicalize(EQPrimOp op, PatternRewriter &rewriter) {
       });
 }
 
-OpFoldResult NEQPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult NEQPrimOp::fold(FoldAdaptor adaptor) {
   // neq(x, x) -> 0
   if (getLhs() == getRhs())
     return getIntAttr(getType(), APInt(1, 0));
 
-  if (auto rhsCst = getConstant(operands[1])) {
+  if (auto rhsCst = getConstant(adaptor.getRhs())) {
     /// neq(x, 0) -> x when x is 1 bit.
     /// TODO: Support SInt<1> on the LHS etc.
     if (rhsCst->isZero() && getLhs().getType() == getType() &&
@@ -843,8 +856,10 @@ OpFoldResult NEQPrimOp::fold(ArrayRef<Attribute> operands) {
   }
 
   return constFoldFIRRTLBinaryOp(
-      *this, operands, BinOpKind::Compare,
-      [=](APSInt a, APSInt b) -> APInt { return APInt(1, a != b); });
+      *this, adaptor.getOperands(), BinOpKind::Compare,
+      [=](const APSInt &a, const APSInt &b) -> APInt {
+        return APInt(1, a != b);
+      });
 }
 
 LogicalResult NEQPrimOp::canonicalize(NEQPrimOp op, PatternRewriter &rewriter) {
@@ -883,7 +898,7 @@ LogicalResult NEQPrimOp::canonicalize(NEQPrimOp op, PatternRewriter &rewriter) {
 // Unary Operators
 //===----------------------------------------------------------------------===//
 
-OpFoldResult SizeOfIntrinsicOp::fold(llvm::ArrayRef<mlir::Attribute>) {
+OpFoldResult SizeOfIntrinsicOp::fold(FoldAdaptor) {
   auto base = getInput().getType().cast<FIRRTLBaseType>();
   auto w = base.getBitWidthOrSentinel();
   if (w >= 0)
@@ -891,14 +906,14 @@ OpFoldResult SizeOfIntrinsicOp::fold(llvm::ArrayRef<mlir::Attribute>) {
   return {};
 }
 
-OpFoldResult IsXIntrinsicOp::fold(llvm::ArrayRef<mlir::Attribute> operands) {
+OpFoldResult IsXIntrinsicOp::fold(FoldAdaptor adaptor) {
   // No constant can be 'x' by definition.
-  if (auto cst = getConstant(operands[0]))
+  if (auto cst = getConstant(adaptor.getArg()))
     return getIntAttr(getType(), APInt(1, 0));
   return {};
 }
 
-OpFoldResult AsSIntPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult AsSIntPrimOp::fold(FoldAdaptor adaptor) {
   // No effect.
   if (getInput().getType() == getType())
     return getInput();
@@ -907,13 +922,13 @@ OpFoldResult AsSIntPrimOp::fold(ArrayRef<Attribute> operands) {
   // Otherwise width inference may produce differently-sized constants if the
   // sign changes.
   if (getType().hasWidth())
-    if (auto cst = getConstant(operands[0]))
+    if (auto cst = getConstant(adaptor.getInput()))
       return getIntAttr(getType(), *cst);
 
   return {};
 }
 
-OpFoldResult AsUIntPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult AsUIntPrimOp::fold(FoldAdaptor adaptor) {
   // No effect.
   if (getInput().getType() == getType())
     return getInput();
@@ -922,73 +937,73 @@ OpFoldResult AsUIntPrimOp::fold(ArrayRef<Attribute> operands) {
   // Otherwise width inference may produce differently-sized constants if the
   // sign changes.
   if (getType().hasWidth())
-    if (auto cst = getConstant(operands[0]))
+    if (auto cst = getConstant(adaptor.getInput()))
       return getIntAttr(getType(), *cst);
 
   return {};
 }
 
-OpFoldResult AsAsyncResetPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult AsAsyncResetPrimOp::fold(FoldAdaptor adaptor) {
   // No effect.
   if (getInput().getType() == getType())
     return getInput();
 
   // Constant fold.
-  if (auto cst = getConstant(operands[0]))
+  if (auto cst = getConstant(adaptor.getInput()))
     return BoolAttr::get(getContext(), cst->getBoolValue());
 
   return {};
 }
 
-OpFoldResult AsClockPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult AsClockPrimOp::fold(FoldAdaptor adaptor) {
   // No effect.
   if (getInput().getType() == getType())
     return getInput();
 
   // Constant fold.
-  if (auto cst = getConstant(operands[0]))
+  if (auto cst = getConstant(adaptor.getInput()))
     return BoolAttr::get(getContext(), cst->getBoolValue());
 
   return {};
 }
 
-OpFoldResult CvtPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult CvtPrimOp::fold(FoldAdaptor adaptor) {
   if (!hasKnownWidthIntTypes(*this))
     return {};
 
   // Signed to signed is a noop, unsigned operands prepend a zero bit.
-  if (auto cst = getExtendedConstant(getOperand(), operands[0],
+  if (auto cst = getExtendedConstant(getOperand(), adaptor.getInput(),
                                      getType().getWidthOrSentinel()))
     return getIntAttr(getType(), *cst);
 
   return {};
 }
 
-OpFoldResult NegPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult NegPrimOp::fold(FoldAdaptor adaptor) {
   if (!hasKnownWidthIntTypes(*this))
     return {};
 
   // FIRRTL negate always adds a bit.
   // -x ---> 0-sext(x) or 0-zext(x)
-  if (auto cst = getExtendedConstant(getOperand(), operands[0],
+  if (auto cst = getExtendedConstant(getOperand(), adaptor.getInput(),
                                      getType().getWidthOrSentinel()))
     return getIntAttr(getType(), APInt((*cst).getBitWidth(), 0) - *cst);
 
   return {};
 }
 
-OpFoldResult NotPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult NotPrimOp::fold(FoldAdaptor adaptor) {
   if (!hasKnownWidthIntTypes(*this))
     return {};
 
-  if (auto cst = getExtendedConstant(getOperand(), operands[0],
+  if (auto cst = getExtendedConstant(getOperand(), adaptor.getInput(),
                                      getType().getWidthOrSentinel()))
     return getIntAttr(getType(), ~*cst);
 
   return {};
 }
 
-OpFoldResult AndRPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult AndRPrimOp::fold(FoldAdaptor adaptor) {
   if (!hasKnownWidthIntTypes(*this))
     return {};
 
@@ -996,7 +1011,7 @@ OpFoldResult AndRPrimOp::fold(ArrayRef<Attribute> operands) {
     return getIntAttr(getType(), APInt(1, 1));
 
   // x == -1
-  if (auto cst = getConstant(operands[0]))
+  if (auto cst = getConstant(adaptor.getInput()))
     return getIntAttr(getType(), APInt(1, cst->isAllOnes()));
 
   // one bit is identity.  Only applies to UInt since we can't make a cast
@@ -1007,7 +1022,7 @@ OpFoldResult AndRPrimOp::fold(ArrayRef<Attribute> operands) {
   return {};
 }
 
-OpFoldResult OrRPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult OrRPrimOp::fold(FoldAdaptor adaptor) {
   if (!hasKnownWidthIntTypes(*this))
     return {};
 
@@ -1015,7 +1030,7 @@ OpFoldResult OrRPrimOp::fold(ArrayRef<Attribute> operands) {
     return getIntAttr(getType(), APInt(1, 0));
 
   // x != 0
-  if (auto cst = getConstant(operands[0]))
+  if (auto cst = getConstant(adaptor.getInput()))
     return getIntAttr(getType(), APInt(1, !cst->isZero()));
 
   // one bit is identity.  Only applies to UInt since we can't make a cast
@@ -1026,7 +1041,7 @@ OpFoldResult OrRPrimOp::fold(ArrayRef<Attribute> operands) {
   return {};
 }
 
-OpFoldResult XorRPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult XorRPrimOp::fold(FoldAdaptor adaptor) {
   if (!hasKnownWidthIntTypes(*this))
     return {};
 
@@ -1034,7 +1049,7 @@ OpFoldResult XorRPrimOp::fold(ArrayRef<Attribute> operands) {
     return getIntAttr(getType(), APInt(1, 0));
 
   // popcount(x) & 1
-  if (auto cst = getConstant(operands[0]))
+  if (auto cst = getConstant(adaptor.getInput()))
     return getIntAttr(getType(), APInt(1, cst->countPopulation() & 1));
 
   // one bit is identity.  Only applies to UInt since we can't make a cast here.
@@ -1048,7 +1063,7 @@ OpFoldResult XorRPrimOp::fold(ArrayRef<Attribute> operands) {
 // Other Operators
 //===----------------------------------------------------------------------===//
 
-OpFoldResult CatPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult CatPrimOp::fold(FoldAdaptor adaptor) {
   // cat(x, 0-width) -> x
   // cat(0-width, x) -> x
   // Limit to unsigned (result type), as cannot insert cast here.
@@ -1063,8 +1078,8 @@ OpFoldResult CatPrimOp::fold(ArrayRef<Attribute> operands) {
     return {};
 
   // Constant fold cat.
-  if (auto lhs = getConstant(operands[0]))
-    if (auto rhs = getConstant(operands[1]))
+  if (auto lhs = getConstant(adaptor.getLhs()))
+    if (auto rhs = getConstant(adaptor.getRhs()))
       return getIntAttr(getType(), lhs->concat(*rhs));
 
   return {};
@@ -1112,7 +1127,7 @@ void CatPrimOp::getCanonicalizationPatterns(RewritePatternSet &results,
   results.insert<CatBitsBits>(context);
 }
 
-OpFoldResult BitCastOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult BitCastOp::fold(FoldAdaptor adaptor) {
   auto op = (*this);
   // BitCast is redundant if input and result types are same.
   if (op.getType() == op.getInput().getType())
@@ -1127,7 +1142,7 @@ OpFoldResult BitCastOp::fold(ArrayRef<Attribute> operands) {
   return {};
 }
 
-OpFoldResult BitsPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult BitsPrimOp::fold(FoldAdaptor adaptor) {
   auto inputType = getInput().getType().cast<FIRRTLBaseType>();
   // If we are extracting the entire input, then return it.
   if (inputType == getType() && getType().hasWidth())
@@ -1135,7 +1150,7 @@ OpFoldResult BitsPrimOp::fold(ArrayRef<Attribute> operands) {
 
   // Constant fold.
   if (hasKnownWidthIntTypes(*this))
-    if (auto cst = getConstant(operands[0]))
+    if (auto cst = getConstant(adaptor.getInput()))
       return getIntAttr(getType(),
                         cst->extractBits(getHi() - getLo() + 1, getLo()));
 
@@ -1165,7 +1180,7 @@ static void replaceWithBits(Operation *op, Value value, unsigned hiBit,
   rewriter.replaceOp(op, value);
 }
 
-OpFoldResult MuxPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult MuxPrimOp::fold(FoldAdaptor adaptor) {
 
   // mux : UInt<0> -> 0
   if (getType().getBitWidthOrSentinel() == 0)
@@ -1182,7 +1197,7 @@ OpFoldResult MuxPrimOp::fold(ArrayRef<Attribute> operands) {
     return {};
 
   // mux(0/1, x, y) -> x or y
-  if (auto cond = getConstant(operands[0])) {
+  if (auto cond = getConstant(adaptor.getSel())) {
     if (cond->isZero() && getLow().getType() == getType())
       return getLow();
     if (!cond->isZero() && getHigh().getType() == getType())
@@ -1190,9 +1205,9 @@ OpFoldResult MuxPrimOp::fold(ArrayRef<Attribute> operands) {
   }
 
   // mux(cond, x, cst)
-  if (auto lowCst = getConstant(operands[2])) {
+  if (auto lowCst = getConstant(adaptor.getLow())) {
     // mux(cond, c1, c2)
-    if (auto highCst = getConstant(operands[1])) {
+    if (auto highCst = getConstant(adaptor.getHigh())) {
       // mux(cond, cst, cst) -> cst
       if (highCst->getBitWidth() == lowCst->getBitWidth() &&
           *highCst == *lowCst)
@@ -1261,7 +1276,7 @@ void MuxPrimOp::getCanonicalizationPatterns(RewritePatternSet &results,
               patterns::NarrowMuxLHS, patterns::NarrowMuxRHS>(context);
 }
 
-OpFoldResult PadPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult PadPrimOp::fold(FoldAdaptor adaptor) {
   auto input = this->getInput();
 
   // pad(x) -> x  if the width doesn't change.
@@ -1275,7 +1290,7 @@ OpFoldResult PadPrimOp::fold(ArrayRef<Attribute> operands) {
     return {};
 
   // Constant fold.
-  if (auto cst = getConstant(operands[0])) {
+  if (auto cst = getConstant(adaptor.getInput())) {
     auto destWidth = getType().getWidthOrSentinel();
     if (destWidth == -1)
       return {};
@@ -1288,7 +1303,7 @@ OpFoldResult PadPrimOp::fold(ArrayRef<Attribute> operands) {
   return {};
 }
 
-OpFoldResult ShlPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult ShlPrimOp::fold(FoldAdaptor adaptor) {
   auto input = this->getInput();
   auto inputType = input.getType().cast<IntType>();
   int shiftAmount = getAmount();
@@ -1298,7 +1313,7 @@ OpFoldResult ShlPrimOp::fold(ArrayRef<Attribute> operands) {
     return input;
 
   // Constant fold.
-  if (auto cst = getConstant(operands[0])) {
+  if (auto cst = getConstant(adaptor.getInput())) {
     auto inputWidth = inputType.getWidthOrSentinel();
     if (inputWidth != -1) {
       auto resultWidth = inputWidth + shiftAmount;
@@ -1309,7 +1324,7 @@ OpFoldResult ShlPrimOp::fold(ArrayRef<Attribute> operands) {
   return {};
 }
 
-OpFoldResult ShrPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult ShrPrimOp::fold(FoldAdaptor adaptor) {
   auto input = this->getInput();
   auto inputType = input.getType().cast<IntType>();
   int shiftAmount = getAmount();
@@ -1330,7 +1345,7 @@ OpFoldResult ShrPrimOp::fold(ArrayRef<Attribute> operands) {
     return getIntAttr(getType(), APInt(1, 0));
 
   // Constant fold.
-  if (auto cst = getConstant(operands[0])) {
+  if (auto cst = getConstant(adaptor.getInput())) {
     APInt value;
     if (inputType.isSigned())
       value = cst->ashr(std::min(shiftAmount, inputWidth - 1));
@@ -1380,9 +1395,9 @@ LogicalResult HeadPrimOp::canonicalize(HeadPrimOp op,
   return success();
 }
 
-OpFoldResult HeadPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult HeadPrimOp::fold(FoldAdaptor adaptor) {
   if (hasKnownWidthIntTypes(*this))
-    if (auto cst = getConstant(operands[0])) {
+    if (auto cst = getConstant(adaptor.getInput())) {
       int shiftAmount =
           getInput().getType().cast<IntType>().getWidthOrSentinel() -
           getAmount();
@@ -1392,9 +1407,9 @@ OpFoldResult HeadPrimOp::fold(ArrayRef<Attribute> operands) {
   return {};
 }
 
-OpFoldResult TailPrimOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult TailPrimOp::fold(FoldAdaptor adaptor) {
   if (hasKnownWidthIntTypes(*this))
-    if (auto cst = getConstant(operands[0]))
+    if (auto cst = getConstant(adaptor.getInput()))
       return getIntAttr(getType(), cst->trunc(getType().getWidthOrSentinel()));
   return {};
 }
@@ -1419,12 +1434,12 @@ void SubaccessOp::getCanonicalizationPatterns(RewritePatternSet &results,
   results.add<patterns::SubaccessOfConstant>(context);
 }
 
-OpFoldResult MultibitMuxOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult MultibitMuxOp::fold(FoldAdaptor adaptor) {
   // If there is only one input, just return it.
-  if (operands.size() == 2)
+  if (adaptor.getInputs().size() == 1)
     return getOperand(1);
 
-  if (auto constIndex = getConstant(operands[0])) {
+  if (auto constIndex = getConstant(adaptor.getIndex())) {
     auto index = constIndex->getZExtValue();
     if (index >= 0 && index < getInputs().size())
       return getInputs()[getInputs().size() - 1 - index];
@@ -1705,14 +1720,14 @@ struct NodeBypass : public mlir::RewritePattern {
 } // namespace
 
 // Interesting names and symbols and don't touch force nodes to stick around.
-OpFoldResult NodeOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult NodeOp::fold(FoldAdaptor adaptor) {
   if (!hasDroppableName())
     return {};
   if (hasDontTouch(getResult())) // handles inner symbols
     return {};
   if (getAnnotationsAttr() && !getAnnotationsAttr().empty())
     return {};
-  return operands[0];
+  return adaptor.getInput();
 }
 
 void NodeOp::getCanonicalizationPatterns(RewritePatternSet &results,
@@ -1836,15 +1851,15 @@ void SubindexOp::getCanonicalizationPatterns(RewritePatternSet &results,
   results.insert<SubindexAggOneShot>(context);
 }
 
-OpFoldResult SubindexOp::fold(ArrayRef<Attribute> operands) {
-  auto attr = operands[0].dyn_cast_or_null<ArrayAttr>();
+OpFoldResult SubindexOp::fold(FoldAdaptor adaptor) {
+  auto attr = adaptor.getInput().dyn_cast_or_null<ArrayAttr>();
   if (!attr)
     return {};
   return attr[getIndex()];
 }
 
-OpFoldResult SubfieldOp::fold(ArrayRef<Attribute> operands) {
-  auto attr = operands[0].dyn_cast_or_null<ArrayAttr>();
+OpFoldResult SubfieldOp::fold(FoldAdaptor adaptor) {
+  auto attr = adaptor.getInput().dyn_cast_or_null<ArrayAttr>();
   if (!attr)
     return {};
   auto index = getFieldIndex();
@@ -1864,12 +1879,12 @@ static Attribute collectFields(MLIRContext *context,
   return ArrayAttr::get(context, operands);
 }
 
-OpFoldResult BundleCreateOp::fold(ArrayRef<Attribute> operands) {
-  return collectFields(getContext(), operands);
+OpFoldResult BundleCreateOp::fold(FoldAdaptor adaptor) {
+  return collectFields(getContext(), adaptor.getOperands());
 }
 
-OpFoldResult VectorCreateOp::fold(ArrayRef<Attribute> operands) {
-  return collectFields(getContext(), operands);
+OpFoldResult VectorCreateOp::fold(FoldAdaptor adaptor) {
+  return collectFields(getContext(), adaptor.getOperands());
 }
 
 namespace {
@@ -2063,7 +2078,7 @@ struct FoldZeroWidthMemory : public mlir::RewritePattern {
   }
 };
 
-// If memory has no write ports, eliminate it.
+// If memory has no write ports and no file initialization, eliminate it.
 struct FoldReadOrWriteOnlyMemory : public mlir::RewritePattern {
   FoldReadOrWriteOnlyMemory(MLIRContext *context)
       : RewritePattern(MemOp::getOperationName(), 0, context) {}
@@ -2093,6 +2108,12 @@ struct FoldReadOrWriteOnlyMemory : public mlir::RewritePattern {
     }
     assert((!isWritten || !isRead) && "memory is in use");
 
+    // If the memory is read only, but has a file initialization, then we can't
+    // remove it.  A write only memory with file initialization is okay to
+    // remove.
+    if (isRead && mem.getInit())
+      return failure();
+
     for (auto port : mem.getResults())
       erasePort(rewriter, port);
 
@@ -2155,7 +2176,7 @@ struct FoldUnusedPorts : public mlir::RewritePattern {
           mem.getWriteLatency(), mem.getDepth(), mem.getRuw(),
           rewriter.getStrArrayAttr(portNames), mem.getName(), mem.getNameKind(),
           mem.getAnnotations(), rewriter.getArrayAttr(portAnnotations),
-          mem.getInnerSymAttr(), mem.getGroupIDAttr());
+          mem.getInnerSymAttr(), mem.getGroupIDAttr(), mem.getInitAttr());
 
     // Replace the dead ports with dummy wires.
     unsigned nextPort = 0;
@@ -2216,7 +2237,7 @@ struct FoldReadWritePorts : public mlir::RewritePattern {
         mem.getDepth(), mem.getRuw(), rewriter.getStrArrayAttr(portNames),
         mem.getName(), mem.getNameKind(), mem.getAnnotations(),
         rewriter.getArrayAttr(portAnnotations), mem.getInnerSymAttr(),
-        mem.getGroupIDAttr());
+        mem.getGroupIDAttr(), mem.getInitAttr());
 
     for (unsigned i = 0, n = mem.getNumResults(); i < n; ++i) {
       auto result = mem.getResult(i);
diff --git a/lib/Dialect/FIRRTL/FIRRTLOpInterfaces.cpp b/lib/Dialect/FIRRTL/FIRRTLOpInterfaces.cpp
index 96d1e48ff..92a97049b 100644
--- a/lib/Dialect/FIRRTL/FIRRTLOpInterfaces.cpp
+++ b/lib/Dialect/FIRRTL/FIRRTLOpInterfaces.cpp
@@ -83,30 +83,21 @@ LogicalResult circt::firrtl::verifyModuleLikeOpInterface(FModuleLike module) {
       }))
     return module.emitOpError("port symbols should all be InnerSym attributes");
 
+  // Verify the port locations.
+  auto portLocs = module.getPortLocationsAttr();
+  if (!portLocs)
+    return module.emitOpError("requires valid port locations");
+  if (portLocs.size() != numPorts)
+    return module.emitOpError("requires ") << numPorts << " port locations";
+  if (llvm::any_of(portLocs.getValue(), [](Attribute attr) {
+        return !attr || !attr.isa<LocationAttr>();
+      }))
+    return module.emitOpError("port symbols should all be location attributes");
+
   // Verify the body.
   if (module->getNumRegions() != 1)
     return module.emitOpError("requires one region");
 
-  // Verify the block arguments.
-  auto &body = module->getRegion(0);
-  if (!body.empty()) {
-    auto &block = body.front();
-    if (block.getNumArguments() != numPorts)
-      return module.emitOpError("entry block must have ")
-             << numPorts << " arguments to match module signature";
-
-    if (llvm::any_of(
-            llvm::zip(block.getArguments(), portTypes.getValue()),
-            [](auto pair) {
-              auto blockType = std::get<0>(pair).getType();
-              auto portType =
-                  std::get<1>(pair).template cast<TypeAttr>().getValue();
-              return blockType != portType;
-            }))
-      return module.emitOpError(
-          "block argument types should match signature types");
-  }
-
   return success();
 }
 
diff --git a/lib/Dialect/FIRRTL/FIRRTLOps.cpp b/lib/Dialect/FIRRTL/FIRRTLOps.cpp
index 8885aa02d..d756ab47e 100644
--- a/lib/Dialect/FIRRTL/FIRRTLOps.cpp
+++ b/lib/Dialect/FIRRTL/FIRRTLOps.cpp
@@ -439,33 +439,22 @@ Block *CircuitOp::getBodyBlock() { return &getBody().front(); }
 // FExtModuleOp and FModuleOp
 //===----------------------------------------------------------------------===//
 
-/// This function can extract information about ports from a module and an
-/// extmodule.
-SmallVector<PortInfo> FModuleOp::getPorts() {
-  SmallVector<PortInfo> results;
-  for (unsigned i = 0, e = getNumPorts(); i < e; ++i) {
-    results.push_back({getPortNameAttr(i), getPortType(i), getPortDirection(i),
-                       getPortSymbolAttr(i), getArgument(i).getLoc(),
-                       AnnotationSet::forPort(*this, i)});
-  }
-  return results;
-}
-
-/// This function can extract information about ports from a module and an
-/// extmodule or genmodule.
 static SmallVector<PortInfo> getPorts(FModuleLike module) {
-  // FExtModuleOp's don't have block arguments or locations for their ports.
-  auto loc = module->getLoc();
   SmallVector<PortInfo> results;
   for (unsigned i = 0, e = getNumPorts(module); i < e; ++i) {
     results.push_back({module.getPortNameAttr(i), module.getPortType(i),
                        module.getPortDirection(i),
                        cast<hw::HWModuleLike>(*module).getPortSymbolAttr(i),
-                       loc, AnnotationSet::forPort(module, i)});
+                       module.getPortLocation(i),
+                       AnnotationSet::forPort(module, i)});
   }
   return results;
 }
 
+SmallVector<PortInfo> FModuleOp::getPorts() {
+  return ::getPorts(cast<FModuleLike>((Operation *)*this));
+}
+
 SmallVector<PortInfo> FExtModuleOp::getPorts() {
   return ::getPorts(cast<FModuleLike>((Operation *)*this));
 }
@@ -483,8 +472,7 @@ BlockArgument FModuleOp::getArgument(size_t portNumber) {
 /// Insertion occurs in-order, such that ports with the same insertion index
 /// appear in the module in the same order they appeared in the list.
 static void insertPorts(FModuleLike op,
-                        ArrayRef<std::pair<unsigned, PortInfo>> ports,
-                        Block *body = nullptr) {
+                        ArrayRef<std::pair<unsigned, PortInfo>> ports) {
   if (ports.empty())
     return;
   unsigned oldNumArgs = getNumPorts(op);
@@ -495,17 +483,20 @@ static void insertPorts(FModuleLike op,
       direction::unpackAttribute(op.getPortDirectionsAttr());
   ArrayRef<Attribute> existingNames = op.getPortNames();
   ArrayRef<Attribute> existingTypes = op.getPortTypes();
+  ArrayRef<Attribute> existingLocs = op.getPortLocations();
   assert(existingDirections.size() == oldNumArgs);
   assert(existingNames.size() == oldNumArgs);
   assert(existingTypes.size() == oldNumArgs);
+  assert(existingLocs.size() == oldNumArgs);
 
   SmallVector<Direction> newDirections;
-  SmallVector<Attribute> newNames, newTypes, newAnnos, newSyms;
+  SmallVector<Attribute> newNames, newTypes, newAnnos, newSyms, newLocs;
   newDirections.reserve(newNumArgs);
   newNames.reserve(newNumArgs);
   newTypes.reserve(newNumArgs);
   newAnnos.reserve(newNumArgs);
   newSyms.reserve(newNumArgs);
+  newLocs.reserve(newNumArgs);
 
   auto emptyArray = ArrayAttr::get(op.getContext(), {});
 
@@ -517,13 +508,13 @@ static void insertPorts(FModuleLike op,
       newTypes.push_back(existingTypes[oldIdx]);
       newAnnos.push_back(op.getAnnotationsAttrForPort(oldIdx));
       newSyms.push_back(cast<hw::HWModuleLike>(*op).getPortSymbolAttr(oldIdx));
+      newLocs.push_back(existingLocs[oldIdx]);
       ++oldIdx;
     }
   };
   for (auto &pair : llvm::enumerate(ports)) {
     auto idx = pair.value().first;
     auto &port = pair.value().second;
-    auto newIdx = pair.index();
     migrateOldPorts(idx);
     newDirections.push_back(port.direction);
     newNames.push_back(port.name);
@@ -531,11 +522,7 @@ static void insertPorts(FModuleLike op,
     auto annos = port.annotations.getArrayAttr();
     newAnnos.push_back(annos ? annos : emptyArray);
     newSyms.push_back(port.sym);
-    if (body) {
-      // Block arguments are inserted one at a time, so for each argument we
-      // insert we have to increase the index by 1.
-      body->insertArgument(idx + newIdx, port.type, port.loc);
-    }
+    newLocs.push_back(port.loc);
   }
   migrateOldPorts(oldNumArgs);
 
@@ -553,6 +540,7 @@ static void insertPorts(FModuleLike op,
   op->setAttr("portTypes", ArrayAttr::get(op.getContext(), newTypes));
   op->setAttr("portAnnotations", ArrayAttr::get(op.getContext(), newAnnos));
   op.setPortSymbols(newSyms);
+  op->setAttr("portLocations", ArrayAttr::get(op.getContext(), newLocs));
 }
 
 /// Erases the ports that have their corresponding bit set in `portIndices`.
@@ -567,6 +555,7 @@ static void erasePorts(FModuleLike op, const llvm::BitVector &portIndices) {
   ArrayRef<Attribute> portTypes = op.getPortTypes();
   ArrayRef<Attribute> portAnnos = op.getPortAnnotations();
   ArrayRef<Attribute> portSyms = op.getPortSymbols();
+  ArrayRef<Attribute> portLocs = op.getPortLocations();
   auto numPorts = getNumPorts(op);
   (void)numPorts;
   assert(portDirections.size() == numPorts);
@@ -574,14 +563,17 @@ static void erasePorts(FModuleLike op, const llvm::BitVector &portIndices) {
   assert(portAnnos.size() == numPorts || portAnnos.empty());
   assert(portTypes.size() == numPorts);
   assert(portSyms.size() == numPorts || portSyms.empty());
+  assert(portLocs.size() == numPorts);
 
   SmallVector<Direction> newPortDirections =
       removeElementsAtIndices<Direction>(portDirections, portIndices);
-  SmallVector<Attribute> newPortNames, newPortTypes, newPortAnnos, newPortSyms;
+  SmallVector<Attribute> newPortNames, newPortTypes, newPortAnnos, newPortSyms,
+      newPortLocs;
   newPortNames = removeElementsAtIndices(portNames, portIndices);
   newPortTypes = removeElementsAtIndices(portTypes, portIndices);
   newPortAnnos = removeElementsAtIndices(portAnnos, portIndices);
   newPortSyms = removeElementsAtIndices(portSyms, portIndices);
+  newPortLocs = removeElementsAtIndices(portLocs, portIndices);
   op->setAttr("portDirections",
               direction::packAttribute(op.getContext(), newPortDirections));
   op->setAttr("portNames", ArrayAttr::get(op.getContext(), newPortNames));
@@ -589,20 +581,19 @@ static void erasePorts(FModuleLike op, const llvm::BitVector &portIndices) {
   op->setAttr("portTypes", ArrayAttr::get(op.getContext(), newPortTypes));
   FModuleLike::fixupPortSymsArray(newPortSyms, op.getContext());
   op->setAttr("portSyms", ArrayAttr::get(op.getContext(), newPortSyms));
+  op->setAttr("portLocations", ArrayAttr::get(op.getContext(), newPortLocs));
 }
 
 void FExtModuleOp::erasePorts(const llvm::BitVector &portIndices) {
-  return ::erasePorts(cast<FModuleLike>((Operation *)*this), portIndices);
+  ::erasePorts(cast<FModuleLike>((Operation *)*this), portIndices);
 }
 
 void FMemModuleOp::erasePorts(const llvm::BitVector &portIndices) {
-  return ::erasePorts(cast<FModuleLike>((Operation *)*this), portIndices);
+  ::erasePorts(cast<FModuleLike>((Operation *)*this), portIndices);
 }
 
-/// Erases the ports that have their corresponding bit set in `portIndices`.
 void FModuleOp::erasePorts(const llvm::BitVector &portIndices) {
   ::erasePorts(cast<FModuleLike>((Operation *)*this), portIndices);
-  // Erase the block arguments.
   getBodyBlock()->eraseArguments(portIndices);
 }
 
@@ -610,8 +601,16 @@ void FModuleOp::erasePorts(const llvm::BitVector &portIndices) {
 /// Insertion occurs in-order, such that ports with the same insertion index
 /// appear in the module in the same order they appeared in the list.
 void FModuleOp::insertPorts(ArrayRef<std::pair<unsigned, PortInfo>> ports) {
-  Block *body = getBodyBlock();
-  ::insertPorts(cast<FModuleLike>((Operation *)*this), ports, body);
+  ::insertPorts(cast<FModuleLike>((Operation *)*this), ports);
+
+  // Insert the block arguments.
+  auto *body = getBodyBlock();
+  for (size_t i = 0, e = ports.size(); i < e; ++i) {
+    // Block arguments are inserted one at a time, so for each argument we
+    // insert we have to increase the index by 1.
+    auto &[index, port] = ports[i];
+    body->insertArgument(index + i, port.type, port.loc);
+  }
 }
 
 void FExtModuleOp::insertPorts(ArrayRef<std::pair<unsigned, PortInfo>> ports) {
@@ -637,12 +636,14 @@ static void buildModule(OpBuilder &builder, OperationState &result,
   SmallVector<Attribute, 4> portTypes;
   SmallVector<Attribute, 4> portAnnotations;
   SmallVector<Attribute, 4> portSyms;
-  for (size_t i = 0, e = ports.size(); i != e; ++i) {
-    portDirections.push_back(ports[i].direction);
-    portNames.push_back(ports[i].name);
-    portTypes.push_back(TypeAttr::get(ports[i].type));
-    portAnnotations.push_back(ports[i].annotations.getArrayAttr());
-    portSyms.push_back(ports[i].sym);
+  SmallVector<Attribute, 4> portLocs;
+  for (const auto &port : ports) {
+    portDirections.push_back(port.direction);
+    portNames.push_back(port.name);
+    portTypes.push_back(TypeAttr::get(port.type));
+    portAnnotations.push_back(port.annotations.getArrayAttr());
+    portSyms.push_back(port.sym);
+    portLocs.push_back(port.loc);
   }
 
   // The lack of *any* port annotations is represented by an empty
@@ -661,6 +662,7 @@ static void buildModule(OpBuilder &builder, OperationState &result,
   result.addAttribute("portTypes", builder.getArrayAttr(portTypes));
   result.addAttribute("portAnnotations", builder.getArrayAttr(portAnnotations));
   result.addAttribute("portSyms", builder.getArrayAttr(portSyms));
+  result.addAttribute("portLocations", builder.getArrayAttr(portLocs));
 
   if (!annotations)
     annotations = builder.getArrayAttr({});
@@ -680,7 +682,7 @@ void FModuleOp::build(OpBuilder &builder, OperationState &result,
   bodyRegion->push_back(body);
 
   // Add arguments to the body block.
-  for (auto elt : ports)
+  for (auto &elt : ports)
     body->addArgument(elt.type, elt.loc);
 }
 
@@ -736,11 +738,14 @@ static bool printModulePorts(OpAsmPrinter &p, Block *block,
                              ArrayRef<Attribute> portNames,
                              ArrayRef<Attribute> portTypes,
                              ArrayRef<Attribute> portAnnotations,
-                             ArrayRef<Attribute> portSyms) {
+                             ArrayRef<Attribute> portSyms,
+                             ArrayRef<Attribute> portLocs) {
   // When printing port names as SSA values, we can fail to print them
   // identically.
   bool printedNamesDontMatch = false;
 
+  mlir::OpPrintingFlags flags;
+
   // If we are printing the ports as block arguments the op must have a first
   // block.
   SmallString<32> resultNameStr;
@@ -789,6 +794,13 @@ static bool printModulePorts(OpAsmPrinter &p, Block *block,
       p << " ";
       p.printAttribute(portAnnotations[i]);
     }
+
+    // Print the port location.
+    // TODO: `printOptionalLocationSpecifier` will emit aliases for locations,
+    // even if they are not printed.  This will have to be fixed upstream.  For
+    // now, use what was specified on the command line.
+    if (flags.shouldPrintDebugInfo() && !portLocs.empty())
+      p.printOptionalLocationSpecifier(portLocs[i].cast<LocationAttr>());
   }
 
   p << ')';
@@ -804,7 +816,8 @@ parseModulePorts(OpAsmParser &parser, bool hasSSAIdentifiers,
                  SmallVectorImpl<Attribute> &portNames,
                  SmallVectorImpl<Attribute> &portTypes,
                  SmallVectorImpl<Attribute> &portAnnotations,
-                 SmallVectorImpl<Attribute> &portSyms) {
+                 SmallVectorImpl<Attribute> &portSyms,
+                 SmallVectorImpl<Attribute> &portLocs) {
   auto *context = parser.getContext();
 
   auto parseArgument = [&]() -> ParseResult {
@@ -816,12 +829,16 @@ parseModulePorts(OpAsmParser &parser, bool hasSSAIdentifiers,
     else
       return failure();
 
-    // Parse the port name.
+    // This is the location or the port declaration in the IR.  If there is no
+    // other location information, we use this to point to the MLIR.
+    llvm::SMLoc irLoc;
+
     if (hasSSAIdentifiers) {
       OpAsmParser::Argument arg;
       if (parser.parseArgument(arg))
         return failure();
       entryArgs.push_back(arg);
+
       // The name of an argument is of the form "%42" or "%id", and since
       // parsing succeeded, we know it always has one character.
       assert(arg.ssaName.name.size() > 1 && arg.ssaName.name[0] == '%' &&
@@ -831,7 +848,13 @@ parseModulePorts(OpAsmParser &parser, bool hasSSAIdentifiers,
       else
         portNames.push_back(
             StringAttr::get(context, arg.ssaName.name.drop_front()));
+
+      // Store the location of the SSA name.
+      irLoc = arg.ssaName.location;
+
     } else {
+      // Parse the port name.
+      irLoc = parser.getCurrentLocation();
       std::string portName;
       if (parser.parseKeywordOrString(&portName))
         return failure();
@@ -868,6 +891,15 @@ parseModulePorts(OpAsmParser &parser, bool hasSSAIdentifiers,
       return failure();
     portAnnotations.push_back(annos);
 
+    // Parse the optional port location.
+    llvm::Optional<Location> maybeLoc;
+    if (failed(parser.parseOptionalLocationSpecifier(maybeLoc)))
+      return failure();
+    Location loc = maybeLoc ? *maybeLoc : parser.getEncodedSourceLoc(irLoc);
+    portLocs.push_back(loc);
+    if (hasSSAIdentifiers)
+      entryArgs.back().sourceLoc = loc;
+
     return success();
   };
 
@@ -917,11 +949,11 @@ static void printFModuleLikeOp(OpAsmPrinter &p, FModuleLike op) {
 
   auto needPortNamesAttr = printModulePorts(
       p, body, portDirections, op.getPortNames(), op.getPortTypes(),
-      op.getPortAnnotations(), op.getPortSymbols());
+      op.getPortAnnotations(), op.getPortSymbols(), op.getPortLocations());
 
-  SmallVector<StringRef, 4> omittedAttrs = {
-      "sym_name", "portDirections", "portTypes",       "portAnnotations",
-      "portSyms", "parameters",     visibilityAttrName};
+  SmallVector<StringRef, 11> omittedAttrs = {
+      "sym_name", "portDirections", "portTypes",  "portAnnotations",
+      "portSyms", "portLocations",  "parameters", visibilityAttrName};
 
   // We can omit the portNames if they were able to be printed as properly as
   // block arguments.
@@ -1019,8 +1051,10 @@ static ParseResult parseFModuleLikeOp(OpAsmParser &parser,
   SmallVector<Attribute, 4> portTypes;
   SmallVector<Attribute, 4> portAnnotations;
   SmallVector<Attribute, 4> portSyms;
+  SmallVector<Attribute, 4> portLocs;
   if (parseModulePorts(parser, hasSSAIdentifiers, entryArgs, portDirections,
-                       portNames, portTypes, portAnnotations, portSyms))
+                       portNames, portTypes, portAnnotations, portSyms,
+                       portLocs))
     return failure();
 
   // If module attributes are present, parse them.
@@ -1038,9 +1072,8 @@ static ParseResult parseFModuleLikeOp(OpAsmParser &parser,
                         direction::packAttribute(context, portDirections));
 
   // Add port names.
-  if (!result.attributes.get("portNames")) {
+  if (!result.attributes.get("portNames"))
     result.addAttribute("portNames", builder.getArrayAttr(portNames));
-  }
 
   // Add the port types.
   if (!result.attributes.get("portTypes"))
@@ -1062,6 +1095,10 @@ static ParseResult parseFModuleLikeOp(OpAsmParser &parser,
     result.addAttribute("portSyms", builder.getArrayAttr(portSyms));
   }
 
+  // Add port locations.
+  if (!result.attributes.get("portLocations"))
+    result.addAttribute("portLocations", ArrayAttr::get(context, portLocs));
+
   // The annotations attribute is always present, but not printed when empty.
   if (!result.attributes.get("annotations"))
     result.addAttribute("annotations", builder.getArrayAttr({}));
@@ -1095,6 +1132,30 @@ ParseResult FMemModuleOp::parse(OpAsmParser &parser, OperationState &result) {
   return parseFModuleLikeOp(parser, result, /*hasSSAIdentifiers=*/false);
 }
 
+LogicalResult FModuleOp::verify() {
+  // Verify the block arguments.
+  auto *body = getBodyBlock();
+  auto portTypes = getPortTypes();
+  auto portLocs = getPortLocations();
+  auto numPorts = portTypes.size();
+
+  // Verify that we have the correct number of block arguments.
+  if (body->getNumArguments() != numPorts)
+    return emitOpError("entry block must have ")
+           << numPorts << " arguments to match module signature";
+
+  // Verify the block arguments' types and locations match our attributes.
+  for (auto [arg, type, loc] : zip(body->getArguments(), portTypes, portLocs)) {
+    if (arg.getType() != type.cast<TypeAttr>().getValue())
+      return emitOpError("block argument types should match signature types");
+    if (arg.getLoc() != loc.cast<LocationAttr>())
+      return emitOpError(
+          "block argument locations should match signature locations");
+  }
+
+  return success();
+}
+
 LogicalResult FExtModuleOp::verify() {
   auto params = getParameters();
   if (params.empty())
@@ -1452,10 +1513,9 @@ void InstanceOp::print(OpAsmPrinter &p) {
   }
   if (getNameKindAttr().getValue() != NameKindEnum::DroppableName)
     p << ' ' << stringifyNameKindEnum(getNameKindAttr().getValue());
-  p << " ";
 
   // Print the attr-dict.
-  SmallVector<StringRef, 4> omittedAttrs = {"moduleName",     "name",
+  SmallVector<StringRef, 9> omittedAttrs = {"moduleName",     "name",
                                             "portDirections", "portNames",
                                             "portTypes",      "portAnnotations",
                                             "inner_sym",      "nameKind"};
@@ -1475,7 +1535,7 @@ void InstanceOp::print(OpAsmPrinter &p) {
   auto portDirections = direction::unpackAttribute(getPortDirectionsAttr());
   printModulePorts(p, /*block=*/nullptr, portDirections,
                    getPortNames().getValue(), portTypes,
-                   getPortAnnotations().getValue(), {});
+                   getPortAnnotations().getValue(), {}, {});
 }
 
 ParseResult InstanceOp::parse(OpAsmParser &parser, OperationState &result) {
@@ -1491,6 +1551,7 @@ ParseResult InstanceOp::parse(OpAsmParser &parser, OperationState &result) {
   SmallVector<Attribute, 4> portTypes;
   SmallVector<Attribute, 4> portAnnotations;
   SmallVector<Attribute, 4> portSyms;
+  SmallVector<Attribute, 4> portLocs;
   NameKindEnumAttr nameKind;
 
   if (parser.parseKeywordOrString(&name))
@@ -1508,7 +1569,7 @@ ParseResult InstanceOp::parse(OpAsmParser &parser, OperationState &result) {
       parser.parseAttribute(moduleName, "moduleName", resultAttrs) ||
       parseModulePorts(parser, /*hasSSAIdentifiers=*/false, entryArgs,
                        portDirections, portNames, portTypes, portAnnotations,
-                       portSyms))
+                       portSyms, portLocs))
     return failure();
 
   // Add the attributes. We let attributes defined in the attr-dict override
@@ -1963,6 +2024,7 @@ FirMemory MemOp::getSummary() {
   uint32_t groupID = 0;
   if (auto gID = op.getGroupIDAttr())
     groupID = gID.getUInt();
+  MemoryInitAttr init = op->getAttrOfType<MemoryInitAttr>("init");
   StringAttr modName;
   if (op->hasAttr("modName"))
     modName = op->getAttrOfType<StringAttr>("modName");
@@ -1970,20 +2032,36 @@ FirMemory MemOp::getSummary() {
     SmallString<8> clocks;
     for (auto a : writeClockIDs)
       clocks.append(Twine((char)(a + 'a')).str());
+    SmallString<32> initStr;
+    // If there is a file initialization, then come up with a decent
+    // representation for this.  Use the filename, but only characters
+    // [a-zA-Z0-9] and the bool/hex and inline booleans.
+    if (init) {
+      for (auto c : init.getFilename().getValue())
+        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||
+            (c >= '0' && c <= '9'))
+          initStr.push_back(c);
+      initStr.push_back('_');
+      initStr.push_back(init.getIsBinary().getValue() ? 't' : 'f');
+      initStr.push_back('_');
+      initStr.push_back(init.getIsInline().getValue() ? 't' : 'f');
+    }
     modName = StringAttr::get(
         op->getContext(),
         llvm::formatv(
-            "FIRRTLMem_{0}_{1}_{2}_{3}_{4}_{5}_{6}_{7}_{8}_{9}_{10}{11}",
+            "FIRRTLMem_{0}_{1}_{2}_{3}_{4}_{5}_{6}_{7}_{8}_{9}_{10}{11}{12}",
             numReadPorts, numWritePorts, numReadWritePorts, (size_t)width,
             op.getDepth(), op.getReadLatency(), op.getWriteLatency(),
             op.getMaskBits(), (size_t)op.getRuw(), (unsigned)hw::WUW::PortOrder,
-            groupID, clocks.empty() ? "" : "_" + clocks));
+            groupID, clocks.empty() ? "" : "_" + clocks,
+            init ? initStr.str() : ""));
   }
   return {numReadPorts,         numWritePorts,    numReadWritePorts,
           (size_t)width,        op.getDepth(),    op.getReadLatency(),
           op.getWriteLatency(), op.getMaskBits(), (size_t)op.getRuw(),
           hw::WUW::PortOrder,   writeClockIDs,    modName,
-          op.getMaskBits() > 1, groupID,          op.getLoc()};
+          op.getMaskBits() > 1, groupID,          init,
+          op.getLoc()};
 }
 
 void MemOp::getAsmResultNames(OpAsmSetValueNameFn setNameFn) {
@@ -3516,7 +3594,7 @@ static void printNameKind(OpAsmPrinter &p, Operation *op,
                           firrtl::NameKindEnumAttr attr,
                           ArrayRef<StringRef> extraElides = {}) {
   if (attr.getValue() != NameKindEnum::DroppableName)
-    p << stringifyNameKindEnum(attr.getValue());
+    p << " " << stringifyNameKindEnum(attr.getValue());
 }
 
 //===----------------------------------------------------------------------===//
diff --git a/lib/Dialect/FIRRTL/Import/FIRParser.cpp b/lib/Dialect/FIRRTL/Import/FIRParser.cpp
index 1052e16ef..8114a65ef 100644
--- a/lib/Dialect/FIRRTL/Import/FIRParser.cpp
+++ b/lib/Dialect/FIRRTL/Import/FIRParser.cpp
@@ -2536,7 +2536,7 @@ ParseResult FIRStmtParser::parseMem(unsigned memIndent) {
       resultTypes, readLatency, writeLatency, depth, ruw,
       builder.getArrayAttr(resultNames), id, NameKindEnum::InterestingName,
       annotations, builder.getArrayAttr(resultAnnotations), hw::InnerSymAttr(),
-      IntegerAttr());
+      IntegerAttr(), MemoryInitAttr());
 
   UnbundledValueEntry unbundledValueEntry;
   unbundledValueEntry.reserve(result.getNumResults());
diff --git a/lib/Dialect/FIRRTL/Transforms/CMakeLists.txt b/lib/Dialect/FIRRTL/Transforms/CMakeLists.txt
index 57d42002c..1404a0ab9 100755
--- a/lib/Dialect/FIRRTL/Transforms/CMakeLists.txt
+++ b/lib/Dialect/FIRRTL/Transforms/CMakeLists.txt
@@ -18,6 +18,7 @@ add_circt_dialect_library(CIRCTFIRRTLTransforms
   InferWidths.cpp
   InjectDUTHierarchy.cpp
   InnerSymbolDCE.cpp
+  LegacyWiring.cpp
   LowerAnnotations.cpp
   LowerCHIRRTL.cpp
   LowerIntrinsics.cpp
diff --git a/lib/Dialect/FIRRTL/Transforms/Dedup.cpp b/lib/Dialect/FIRRTL/Transforms/Dedup.cpp
index 0ff7563c4..b0070074a 100644
--- a/lib/Dialect/FIRRTL/Transforms/Dedup.cpp
+++ b/lib/Dialect/FIRRTL/Transforms/Dedup.cpp
@@ -67,6 +67,7 @@ struct StructuralHasher {
     nonessentialAttributes.insert(StringAttr::get(context, "portAnnotations"));
     nonessentialAttributes.insert(StringAttr::get(context, "portNames"));
     nonessentialAttributes.insert(StringAttr::get(context, "portSyms"));
+    nonessentialAttributes.insert(StringAttr::get(context, "portLocations"));
     nonessentialAttributes.insert(StringAttr::get(context, "sym_name"));
     nonessentialAttributes.insert(StringAttr::get(context, "inner_sym"));
   };
@@ -210,6 +211,7 @@ struct Equivalence {
     nonessentialAttributes.insert(StringAttr::get(context, "portNames"));
     nonessentialAttributes.insert(StringAttr::get(context, "portTypes"));
     nonessentialAttributes.insert(StringAttr::get(context, "portSyms"));
+    nonessentialAttributes.insert(StringAttr::get(context, "portLocations"));
     nonessentialAttributes.insert(StringAttr::get(context, "sym_name"));
     nonessentialAttributes.insert(StringAttr::get(context, "inner_sym"));
   }
@@ -656,6 +658,18 @@ struct Deduper {
     // used to update NLAs that reference the "fromModule".
     RenameMap renameMap;
 
+    // Merge the port locations.
+    SmallVector<Attribute> newLocs;
+    for (auto [toLoc, fromLoc] : llvm::zip(toModule.getPortLocations(),
+                                           fromModule.getPortLocations())) {
+      if (toLoc == fromLoc)
+        newLocs.push_back(toLoc);
+      else
+        newLocs.push_back(mergeLoc(context, toLoc.cast<LocationAttr>(),
+                                   fromLoc.cast<LocationAttr>()));
+    }
+    toModule->setAttr("portLocations", ArrayAttr::get(context, newLocs));
+
     // Merge the two modules.
     mergeOps(renameMap, toModule, toModule, fromModule, fromModule);
 
@@ -1089,6 +1103,12 @@ private:
   /// Recursively merge two blocks.
   void mergeBlocks(RenameMap &renameMap, FModuleLike toModule, Block &toBlock,
                    FModuleLike fromModule, Block &fromBlock) {
+    // Merge the block locations.
+    for (auto [toArg, fromArg] :
+         llvm::zip(toBlock.getArguments(), fromBlock.getArguments()))
+      if (toArg.getLoc() != fromArg.getLoc())
+        toArg.setLoc(mergeLoc(context, toArg.getLoc(), fromArg.getLoc()));
+
     for (auto ops : llvm::zip(toBlock, fromBlock))
       mergeOps(renameMap, toModule, &std::get<0>(ops), fromModule,
                &std::get<1>(ops));
diff --git a/lib/Dialect/FIRRTL/Transforms/ExpandWhens.cpp b/lib/Dialect/FIRRTL/Transforms/ExpandWhens.cpp
index cd4d29304..b9783ce73 100644
--- a/lib/Dialect/FIRRTL/Transforms/ExpandWhens.cpp
+++ b/lib/Dialect/FIRRTL/Transforms/ExpandWhens.cpp
@@ -512,7 +512,7 @@ void LastConnectResolver<ConcreteT>::processWhenOp(WhenOp whenOp,
 
   // Process the `then` block. If we are already in a whenblock, the we need to
   // conjoin ('and') the outer conditions.
-  auto thenCondition = whenOp.getCondition();
+  Value thenCondition = whenOp.getCondition();
   if (outerCondition)
     thenCondition =
         b.createOrFold<AndPrimOp>(loc, ui1Type, outerCondition, thenCondition);
diff --git a/lib/Dialect/FIRRTL/Transforms/FlattenMemory.cpp b/lib/Dialect/FIRRTL/Transforms/FlattenMemory.cpp
index cb0c5e55f..78256fe6f 100644
--- a/lib/Dialect/FIRRTL/Transforms/FlattenMemory.cpp
+++ b/lib/Dialect/FIRRTL/Transforms/FlattenMemory.cpp
@@ -113,7 +113,7 @@ struct FlattenMemoryPass : public FlattenMemoryBase<FlattenMemoryPass> {
           memOp.getDepth(), memOp.getRuw(), builder.getArrayAttr(portNames),
           memOp.getNameAttr(), memOp.getNameKind(), memOp.getAnnotations(),
           memOp.getPortAnnotations(), memOp.getInnerSymAttr(),
-          memOp.getGroupIDAttr());
+          memOp.getGroupIDAttr(), memOp.getInitAttr());
       // Hook up the new memory to the wires the old memory was replaced with.
       for (size_t index = 0, rend = memOp.getNumResults(); index < rend;
            ++index) {
diff --git a/lib/Dialect/FIRRTL/Transforms/GrandCentral.cpp b/lib/Dialect/FIRRTL/Transforms/GrandCentral.cpp
index a07f85e0c..142c73fb1 100644
--- a/lib/Dialect/FIRRTL/Transforms/GrandCentral.cpp
+++ b/lib/Dialect/FIRRTL/Transforms/GrandCentral.cpp
@@ -1075,7 +1075,8 @@ parseAugmentedType(ApplyState &state, DictionaryAttr augmentedType,
 
     // Append this new Wiring Problem to the ApplyState.  The Wiring Problem
     // will be resolved to bore RefType ports before LowerAnnotations finishes.
-    state.wiringProblems.push_back({*source, sink, (path + "__bore").str()});
+    state.wiringProblems.push_back({*source, sink, (path + "__bore").str(),
+                                    WiringProblem::RefTypeUsage::Prefer});
 
     return DictionaryAttr::getWithSorted(context, elementIface);
   }
@@ -1549,7 +1550,14 @@ void GrandCentralPass::runOnOperation() {
   bool removalError = false;
   AnnotationSet::removeAnnotations(circuitOp, [&](Annotation anno) {
     if (anno.isClass(augmentedBundleTypeClass)) {
-      worklist.push_back(anno);
+      // If we are in "instantiateCompanionOnly" mode, then we don't need to
+      // create the interface, so we can skip adding it to the worklist.  This
+      // is a janky hack for situations where you want to synthesize assertion
+      // logic included in the companion, but don't want to have a dead
+      // interface hanging around (or have problems with tools understanding
+      // interfaces).
+      if (!instantiateCompanionOnly)
+        worklist.push_back(anno);
       ++numAnnosRemoved;
       return true;
     }
@@ -2033,14 +2041,6 @@ void GrandCentralPass::runOnOperation() {
     }
   });
 
-  // If we are in "instantiateCompanionOnly" mode, then just exit here.  We
-  // don't need to create the interface.  This is a janky hack for situations
-  // where you want to synthesize assertion logic included in the companion, but
-  // don't want to have a dead interface hanging around (or have problems with
-  // tools understanding interfaces).
-  if (instantiateCompanionOnly)
-    return;
-
   // Now, iterate over the worklist of interface-encoding annotations to create
   // the interface and all its sub-interfaces (interfaces that it instantiates),
   // instantiate the top-level interface, and generate a "mappings file" that
@@ -2134,11 +2134,15 @@ void GrandCentralPass::runOnOperation() {
       continue;
     auto companionBuilder =
         OpBuilder::atBlockEnd(companionModule.getBodyBlock());
+
+    // Generate gathered XMR's.
     for (auto xmrElem : xmrElems) {
       auto uloc = companionBuilder.getUnknownLoc();
       companionBuilder.create<sv::VerbatimOp>(uloc, xmrElem.str, xmrElem.val,
                                               xmrElem.syms);
     }
+    numXMRs += xmrElems.size();
+
     sv::InterfaceOp topIface;
     for (const auto &ifaceBuilder : interfaceBuilder) {
       auto builder = OpBuilder::atBlockEnd(getOperation().getBodyBlock());
diff --git a/lib/Dialect/FIRRTL/Transforms/InferReadWrite.cpp b/lib/Dialect/FIRRTL/Transforms/InferReadWrite.cpp
index 7b8483caa..78dba7475 100644
--- a/lib/Dialect/FIRRTL/Transforms/InferReadWrite.cpp
+++ b/lib/Dialect/FIRRTL/Transforms/InferReadWrite.cpp
@@ -137,7 +137,7 @@ struct InferReadWritePass : public InferReadWriteBase<InferReadWritePass> {
           builder.getArrayAttr(resultNames), memOp.getNameAttr(),
           memOp.getNameKind(), memOp.getAnnotations(),
           builder.getArrayAttr(portAnnotations), memOp.getInnerSymAttr(),
-          memOp.getGroupIDAttr());
+          memOp.getGroupIDAttr(), memOp.getInitAttr());
       ++numRWPortMemoriesInferred;
       auto rwPort = rwMem->getResult(nDbgs);
       // Create the subfield access to all fields of the port.
diff --git a/lib/Dialect/FIRRTL/Transforms/InnerSymbolDCE.cpp b/lib/Dialect/FIRRTL/Transforms/InnerSymbolDCE.cpp
index 79e636b3b..55566969a 100644
--- a/lib/Dialect/FIRRTL/Transforms/InnerSymbolDCE.cpp
+++ b/lib/Dialect/FIRRTL/Transforms/InnerSymbolDCE.cpp
@@ -13,7 +13,6 @@
 #include "circt/Dialect/FIRRTL/FIRRTLOps.h"
 #include "circt/Dialect/HW/HWAttributes.h"
 #include "mlir/IR/BuiltinOps.h"
-#include "mlir/IR/SubElementInterfaces.h"
 #include "mlir/IR/Threading.h"
 #include "llvm/Support/Debug.h"
 
@@ -37,18 +36,11 @@ private:
 
 /// Find all InnerRefAttrs inside a given Attribute.
 void InnerSymbolDCEPass::findInnerRefs(Attribute attr) {
-  // Check if this Attribute is an InnerRefAttr.
-  if (auto innerRef = dyn_cast<InnerRefAttr>(attr)) {
-    insertInnerRef(innerRef);
-    return;
-  }
-
-  // Check if any sub-Attributes are InnerRefAttrs.
-  if (auto subElementAttr = dyn_cast<SubElementAttrInterface>(attr))
-    subElementAttr.walkSubAttrs([&](Attribute subAttr) {
-      if (auto innerRef = dyn_cast<InnerRefAttr>(subAttr))
-        insertInnerRef(innerRef);
-    });
+  // Check if this Attribute or any sub-Attributes are InnerRefAttrs.
+  attr.walk([&](Attribute subAttr) {
+    if (auto innerRef = dyn_cast<InnerRefAttr>(subAttr))
+      insertInnerRef(innerRef);
+  });
 }
 
 /// Add an InnerRefAttr to the set of all InnerRefAttrs.
diff --git a/lib/Dialect/FIRRTL/Transforms/LegacyWiring.cpp b/lib/Dialect/FIRRTL/Transforms/LegacyWiring.cpp
new file mode 100644
index 000000000..ca6e7886e
--- /dev/null
+++ b/lib/Dialect/FIRRTL/Transforms/LegacyWiring.cpp
@@ -0,0 +1,109 @@
+//===- LegacyWiring- legacy Wiring annotation resolver --------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines the legacy Wiring annotation resolver.
+//
+//===----------------------------------------------------------------------===//
+
+#include "circt/Dialect/FIRRTL/AnnotationDetails.h"
+#include "circt/Dialect/FIRRTL/FIRRTLAnnotationHelper.h"
+#include "circt/Dialect/FIRRTL/FIRRTLAnnotations.h"
+#include "circt/Dialect/FIRRTL/FIRRTLUtils.h"
+#include "mlir/IR/ImplicitLocOpBuilder.h"
+#include "mlir/Support/LogicalResult.h"
+
+using namespace circt;
+using namespace firrtl;
+
+/// Consume SourceAnnotation and SinkAnnotation, storing into state
+LogicalResult circt::firrtl::applyWiring(const AnnoPathValue &target,
+                                         DictionaryAttr anno,
+                                         ApplyState &state) {
+  auto clazz = anno.getAs<StringAttr>("class").getValue();
+  auto *context = anno.getContext();
+  ImplicitLocOpBuilder builder(target.ref.getOp()->getLoc(), context);
+
+  // Convert target to Value
+  Value targetValue;
+  if (auto portTarget = target.ref.dyn_cast<PortAnnoTarget>()) {
+    auto portNum = portTarget.getImpl().getPortNo();
+    if (auto module = dyn_cast<FModuleOp>(portTarget.getOp())) {
+      if (clazz == wiringSourceAnnoClass) {
+        builder.setInsertionPointToStart(module.getBodyBlock());
+      } else if (clazz == wiringSinkAnnoClass) {
+        builder.setInsertionPointToEnd(module.getBodyBlock());
+      }
+      targetValue = getValueByFieldID(builder, module.getArgument(portNum),
+                                      target.fieldIdx);
+    } else if (auto ext = dyn_cast<FExtModuleOp>(portTarget.getOp())) {
+      InstanceOp inst;
+      if (target.instances.empty()) {
+        auto paths = state.instancePathCache.getAbsolutePaths(ext);
+        if (paths.size() > 1) {
+          mlir::emitError(state.circuit.getLoc())
+              << "cannot resolve a unique instance path from the "
+                 "external module target "
+              << target.ref;
+          return failure();
+        }
+        inst = cast<InstanceOp>(paths[0].back());
+      } else {
+        inst = cast<InstanceOp>(target.instances.back());
+      }
+      state.wiringProblemInstRefs.insert(inst);
+      builder.setInsertionPointAfter(inst);
+      targetValue =
+          getValueByFieldID(builder, inst->getResult(portNum), target.fieldIdx);
+    } else {
+      return mlir::emitError(state.circuit.getLoc())
+             << "Annotation has invalid target: " << anno;
+    }
+  } else if (auto opResult = target.ref.dyn_cast<OpAnnoTarget>()) {
+    if (target.isOpOfType<WireOp, RegOp, RegResetOp>()) {
+      auto module = cast<FModuleOp>(opResult.getModule());
+      if (clazz == wiringSourceAnnoClass) {
+        builder.setInsertionPointToStart(module.getBodyBlock());
+      } else if (clazz == wiringSinkAnnoClass) {
+        builder.setInsertionPointToEnd(module.getBodyBlock());
+      }
+      targetValue = getValueByFieldID(builder, opResult.getOp()->getResult(0),
+                                      target.fieldIdx);
+    } else {
+      return mlir::emitError(state.circuit.getLoc())
+             << "Annotation targets non-wireable operation: " << anno;
+    }
+  } else {
+    return mlir::emitError(state.circuit.getLoc())
+           << "Annotation has invalid target: " << anno;
+  }
+
+  // Get pin field
+  auto pin = anno.getAs<StringAttr>("pin");
+  if (!pin) {
+    return mlir::emitError(state.circuit.getLoc())
+           << "Annotation does not have an associated pin name: " << anno;
+  }
+
+  // Handle difference between sinks and sources
+  if (clazz == wiringSourceAnnoClass) {
+    if (state.legacyWiringProblems.find(pin) !=
+        state.legacyWiringProblems.end()) {
+      // Check if existing problem can be updated
+      if (state.legacyWiringProblems[pin].source) {
+        return mlir::emitError(state.circuit.getLoc())
+               << "More than one " << wiringSourceAnnoClass
+               << " defined for pin " << pin;
+      }
+    }
+    state.legacyWiringProblems[pin].source = targetValue;
+  } else if (clazz == wiringSinkAnnoClass) {
+    state.legacyWiringProblems[pin].sinks.push_back(targetValue);
+  }
+
+  return success();
+}
diff --git a/lib/Dialect/FIRRTL/Transforms/LowerAnnotations.cpp b/lib/Dialect/FIRRTL/Transforms/LowerAnnotations.cpp
index 6b15c7d9d..1166435c5 100644
--- a/lib/Dialect/FIRRTL/Transforms/LowerAnnotations.cpp
+++ b/lib/Dialect/FIRRTL/Transforms/LowerAnnotations.cpp
@@ -277,6 +277,62 @@ static LogicalResult drop(const AnnoPathValue &target, DictionaryAttr anno,
   return success();
 }
 
+//===----------------------------------------------------------------------===//
+// Customized Appliers
+//===----------------------------------------------------------------------===//
+
+/// Update a memory op with attributes about memory file loading.
+template <bool isInline>
+static LogicalResult applyLoadMemoryAnno(const AnnoPathValue &target,
+                                         DictionaryAttr anno,
+                                         ApplyState &state) {
+  if (!target.isLocal()) {
+    mlir::emitError(state.circuit.getLoc())
+        << "has a " << anno.get("class")
+        << " annotation which is non-local, but this annotation is not allowed "
+           "to be non-local";
+    return failure();
+  }
+
+  auto *op = target.ref.getOp();
+
+  if (!target.isOpOfType<MemOp, CombMemOp, SeqMemOp>()) {
+    mlir::emitError(op->getLoc())
+        << "can only apply a load memory annotation to a memory";
+    return failure();
+  }
+
+  // The two annotations have different case usage in "filename".
+  StringAttr filename = tryGetAs<StringAttr>(
+      anno, anno, isInline ? "filename" : "fileName", op->getLoc(),
+      anno.getAs<StringAttr>("class").getValue());
+  if (!filename)
+    return failure();
+
+  auto hexOrBinary =
+      tryGetAs<StringAttr>(anno, anno, "hexOrBinary", op->getLoc(),
+                           anno.getAs<StringAttr>("class").getValue());
+  if (!hexOrBinary)
+    return failure();
+
+  auto hexOrBinaryValue = hexOrBinary.getValue();
+  if (hexOrBinaryValue != "h" && hexOrBinaryValue != "b") {
+    auto diag = mlir::emitError(op->getLoc())
+                << "has memory initialization annotation with invalid format, "
+                   "'hexOrBinary' field must be either 'h' or 'b'";
+    diag.attachNote() << "the full annotation is: " << anno;
+    return failure();
+  }
+
+  op->setAttr("init",
+              MemoryInitAttr::get(
+                  op->getContext(), filename,
+                  BoolAttr::get(op->getContext(), hexOrBinaryValue == "b"),
+                  BoolAttr::get(op->getContext(), isInline)));
+
+  return success();
+}
+
 //===----------------------------------------------------------------------===//
 // Driving table
 //===----------------------------------------------------------------------===//
@@ -400,6 +456,11 @@ static const llvm::StringMap<AnnoRecord> annotationRecords{{
     {blackBoxTargetDirAnnoClass, NoTargetAnnotation},
     {traceNameAnnoClass, {stdResolve, applyTraceName}},
     {traceAnnoClass, {stdResolve, applyWithoutTarget<true>}},
+    {loadMemoryFromFileAnnoClass, {stdResolve, applyLoadMemoryAnno<false>}},
+    {loadMemoryFromFileInlineAnnoClass,
+     {stdResolve, applyLoadMemoryAnno<true>}},
+    {wiringSinkAnnoClass, {stdResolve, applyWiring}},
+    {wiringSourceAnnoClass, {stdResolve, applyWiring}},
 
 }};
 
@@ -428,6 +489,7 @@ struct LowerAnnotationsPass
     : public LowerFIRRTLAnnotationsBase<LowerAnnotationsPass> {
   void runOnOperation() override;
   LogicalResult applyAnnotation(DictionaryAttr anno, ApplyState &state);
+  LogicalResult legacyToWiringProblems(ApplyState &state);
   LogicalResult solveWiringProblems(ApplyState &state);
 
   bool ignoreUnhandledAnno = false;
@@ -475,12 +537,33 @@ LogicalResult LowerAnnotationsPass::applyAnnotation(DictionaryAttr anno,
   return success();
 }
 
+/// Convert consumed SourceAnnotation and SinkAnnotation into WiringProblems,
+/// using the pin attribute as newNameHint
+LogicalResult LowerAnnotationsPass::legacyToWiringProblems(ApplyState &state) {
+  for (const auto &[name, problem] : state.legacyWiringProblems) {
+    if (!problem.source)
+      return mlir::emitError(state.circuit.getLoc())
+             << "Unable to resolve source for pin: " << name;
+
+    if (problem.sinks.empty())
+      return mlir::emitError(state.circuit.getLoc())
+             << "Unable to resolve sink(s) for pin: " << name;
+
+    for (const auto &sink : problem.sinks) {
+      state.wiringProblems.push_back(
+          {problem.source, sink, {}, WiringProblem::RefTypeUsage::Never});
+    }
+  }
+  return success();
+}
+
 /// Modify the circuit to solve and apply all Wiring Problems in the circuit.  A
-/// Wiring Problem is a mapping from a source to a sink that should be connected
-/// via a RefType.  This uses a two-step approach.  First, all Wiring Problems
-/// are analyzed to compute pending modifications to modules.  Second, modules
-/// are visited from leaves to roots to apply module modifications.  Module
-/// modifications include addings ports and connecting things up.
+/// Wiring Problem is a mapping from a source to a sink that can be connected
+/// via a base Type or RefType as requested.  This uses a two-step approach.
+/// First, all Wiring Problems are analyzed to compute pending modifications to
+/// modules. Second, modules are visited from leaves to roots to apply module
+/// modifications.  Module modifications include addings ports and connecting
+/// things up.
 LogicalResult LowerAnnotationsPass::solveWiringProblems(ApplyState &state) {
   // Utility function to extract the defining module from a value which may be
   // either a BlockArgument or an Operation result.
@@ -690,12 +773,33 @@ LogicalResult LowerAnnotationsPass::solveWiringProblems(ApplyState &state) {
     moduleModifications[sourceModule].connectionMap[index] = source;
     moduleModifications[sinkModule].connectionMap[index] = sink;
 
-    // Record ports that should be added to each module along the LCA path.
-    RefType refType = TypeSwitch<Type, RefType>(problem.source.getType())
-                          .Case<FIRRTLBaseType>([](FIRRTLBaseType base) {
-                            return RefType::get(base);
-                          })
-                          .Case<RefType>([](RefType ref) { return ref; });
+    // Record port types that should be added to each module along the LCA path.
+    Type sourceType, sinkType;
+    auto useRefTypes =
+        !noRefTypePorts &&
+        problem.refTypeUsage == WiringProblem::RefTypeUsage::Prefer;
+    if (useRefTypes) {
+      // Use RefType ports if possible
+      RefType refType = TypeSwitch<Type, RefType>(source.getType())
+                            .Case<FIRRTLBaseType>([](FIRRTLBaseType base) {
+                              return RefType::get(base);
+                            })
+                            .Case<RefType>([](RefType ref) { return ref; });
+      sourceType = refType;
+      sinkType = refType.getType();
+    } else {
+      // Use base Type ports
+      sourceType = source.getType();
+      sinkType = sink.getType();
+
+      if (sourceType != sinkType) {
+        auto diag = mlir::emitError(source.getLoc())
+                    << "Wiring Problem source type " << sourceType
+                    << " does not match sink type " << sinkType;
+        diag.attachNote(sink.getLoc()) << "The sink is here.";
+        return failure();
+      }
+    }
 
     // Record module modifications related to adding ports to modules.
     auto addPorts = [&](ArrayRef<hw::HWInstanceLike> insts, Value val, Type tpe,
@@ -722,11 +826,8 @@ LogicalResult LowerAnnotationsPass::solveWiringProblems(ApplyState &state) {
     };
 
     // Record the addition of ports.
-    if (noRefTypePorts)
-      addPorts(sources, source, refType.getType(), Direction::Out);
-    else
-      addPorts(sources, source, refType, Direction::Out);
-    addPorts(sinks, sink, refType.getType(), Direction::In);
+    addPorts(sources, source, sourceType, Direction::Out);
+    addPorts(sinks, sink, sinkType, Direction::In);
   }
 
   // Iterate over modules from leaves to roots, applying ModuleModifications to
@@ -861,6 +962,9 @@ void LowerAnnotationsPass::runOnOperation() {
       ++numFailures;
   }
 
+  if (failed(legacyToWiringProblems(state)))
+    ++numFailures;
+
   if (failed(solveWiringProblems(state)))
     ++numFailures;
 
diff --git a/lib/Dialect/FIRRTL/Transforms/LowerCHIRRTL.cpp b/lib/Dialect/FIRRTL/Transforms/LowerCHIRRTL.cpp
index f98c38066..5bbdd837d 100644
--- a/lib/Dialect/FIRRTL/Transforms/LowerCHIRRTL.cpp
+++ b/lib/Dialect/FIRRTL/Transforms/LowerCHIRRTL.cpp
@@ -354,7 +354,7 @@ void LowerCHIRRTLPass::replaceMem(Operation *cmem, StringRef name,
       memBuilder.getArrayAttr(resultNames), name,
       cmem->getAttrOfType<firrtl::NameKindEnumAttr>("nameKind").getValue(),
       annotations, memBuilder.getArrayAttr(portAnnotations), hw::InnerSymAttr(),
-      IntegerAttr());
+      IntegerAttr(), cmem->getAttrOfType<firrtl::MemoryInitAttr>("init"));
   if (auto innerSym = cmem->getAttr("inner_sym"))
     memory->setAttr("inner_sym", innerSym);
   ++numCreatedMems;
diff --git a/lib/Dialect/FIRRTL/Transforms/LowerMemory.cpp b/lib/Dialect/FIRRTL/Transforms/LowerMemory.cpp
index 15a119042..6f55d0e77 100644
--- a/lib/Dialect/FIRRTL/Transforms/LowerMemory.cpp
+++ b/lib/Dialect/FIRRTL/Transforms/LowerMemory.cpp
@@ -79,7 +79,8 @@ FirMemory getSummary(MemOp op) {
           (size_t)width,        op.getDepth(),    op.getReadLatency(),
           op.getWriteLatency(), op.getMaskBits(), (size_t)op.getRuw(),
           hw::WUW::PortOrder,   writeClockIDs,    op.getNameAttr(),
-          op.getMaskBits() > 1, groupID,          op.getLoc()};
+          op.getMaskBits() > 1, groupID,          op.getInitAttr(),
+          op.getLoc()};
 }
 
 namespace {
diff --git a/lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp b/lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp
index 2da968cbf..fc5bf5e88 100644
--- a/lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp
+++ b/lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp
@@ -256,6 +256,7 @@ static MemOp cloneMemWithNewType(ImplicitLocOpBuilder *b, MemOp op,
                                  FlatBundleFieldEntry field) {
   SmallVector<Type, 8> ports;
   SmallVector<Attribute, 8> portNames;
+  SmallVector<Attribute, 8> portLocations;
 
   auto oldPorts = op.getPorts();
   for (size_t portIdx = 0, e = oldPorts.size(); portIdx < e; ++portIdx) {
@@ -335,6 +336,7 @@ struct AttrCache {
     sPortNames = StringAttr::get(context, "portNames");
     sPortTypes = StringAttr::get(context, "portTypes");
     sPortSyms = StringAttr::get(context, "portSyms");
+    sPortLocations = StringAttr::get(context, "portLocations");
     sPortAnnotations = StringAttr::get(context, "portAnnotations");
     sEmpty = StringAttr::get(context, "");
   }
@@ -342,7 +344,7 @@ struct AttrCache {
 
   Type i64ty;
   StringAttr innerSymAttr, nameAttr, nameKindAttr, sPortDirections, sPortNames,
-      sPortTypes, sPortSyms, sPortAnnotations, sEmpty;
+      sPortTypes, sPortSyms, sPortLocations, sPortAnnotations, sEmpty;
 };
 
 // The visitors all return true if the operation should be deleted, false if
@@ -950,20 +952,22 @@ bool TypeLoweringVisitor::visitDecl(FExtModuleOp extModule) {
     // handled differently below.
     if (attr.getName() != "portDirections" && attr.getName() != "portNames" &&
         attr.getName() != "portTypes" && attr.getName() != "portAnnotations" &&
-        attr.getName() != "portSyms")
+        attr.getName() != "portSyms" && attr.getName() != "portLocations")
       newModuleAttrs.push_back(attr);
 
   SmallVector<Direction> newArgDirections;
   SmallVector<Attribute> newArgNames;
-  SmallVector<Attribute, 8> newPortTypes;
+  SmallVector<Attribute, 8> newArgTypes;
   SmallVector<Attribute, 8> newArgSyms;
+  SmallVector<Attribute, 8> newArgLocations;
   SmallVector<Attribute, 8> newArgAnnotations;
 
   for (auto &port : newArgs) {
     newArgDirections.push_back(port.direction);
     newArgNames.push_back(port.name);
-    newPortTypes.push_back(TypeAttr::get(port.type));
+    newArgTypes.push_back(TypeAttr::get(port.type));
     newArgSyms.push_back(port.sym);
+    newArgLocations.push_back(port.loc);
     newArgAnnotations.push_back(port.annotations.getArrayAttr());
   }
 
@@ -975,7 +979,10 @@ bool TypeLoweringVisitor::visitDecl(FExtModuleOp extModule) {
       NamedAttribute(cache.sPortNames, builder.getArrayAttr(newArgNames)));
 
   newModuleAttrs.push_back(
-      NamedAttribute(cache.sPortTypes, builder.getArrayAttr(newPortTypes)));
+      NamedAttribute(cache.sPortTypes, builder.getArrayAttr(newArgTypes)));
+
+  newModuleAttrs.push_back(NamedAttribute(
+      cache.sPortLocations, builder.getArrayAttr(newArgLocations)));
 
   newModuleAttrs.push_back(NamedAttribute(
       cache.sPortAnnotations, builder.getArrayAttr(newArgAnnotations)));
@@ -1025,19 +1032,21 @@ bool TypeLoweringVisitor::visitDecl(FModuleOp module) {
     // handled differently below.
     if (attr.getName() != "portNames" && attr.getName() != "portDirections" &&
         attr.getName() != "portTypes" && attr.getName() != "portAnnotations" &&
-        attr.getName() != "portSyms")
+        attr.getName() != "portSyms" && attr.getName() != "portLocations")
       newModuleAttrs.push_back(attr);
 
   SmallVector<Direction> newArgDirections;
   SmallVector<Attribute> newArgNames;
   SmallVector<Attribute> newArgTypes;
   SmallVector<Attribute> newArgSyms;
+  SmallVector<Attribute> newArgLocations;
   SmallVector<Attribute, 8> newArgAnnotations;
   for (auto &port : newArgs) {
     newArgDirections.push_back(port.direction);
     newArgNames.push_back(port.name);
     newArgTypes.push_back(TypeAttr::get(port.type));
     newArgSyms.push_back(port.sym);
+    newArgLocations.push_back(port.loc);
     newArgAnnotations.push_back(port.annotations.getArrayAttr());
   }
 
@@ -1050,6 +1059,10 @@ bool TypeLoweringVisitor::visitDecl(FModuleOp module) {
 
   newModuleAttrs.push_back(
       NamedAttribute(cache.sPortTypes, builder->getArrayAttr(newArgTypes)));
+
+  newModuleAttrs.push_back(NamedAttribute(
+      cache.sPortLocations, builder->getArrayAttr(newArgLocations)));
+
   newModuleAttrs.push_back(NamedAttribute(
       cache.sPortAnnotations, builder->getArrayAttr(newArgAnnotations)));
 
diff --git a/lib/Dialect/FIRRTL/Transforms/LowerXMR.cpp b/lib/Dialect/FIRRTL/Transforms/LowerXMR.cpp
index bb557f059..57be707b2 100644
--- a/lib/Dialect/FIRRTL/Transforms/LowerXMR.cpp
+++ b/lib/Dialect/FIRRTL/Transforms/LowerXMR.cpp
@@ -489,7 +489,7 @@ class LowerXMRPass : public LowerXMRBase<LowerXMRPass> {
             builder.getArrayAttr(resultNames), mem.getNameAttr(),
             mem.getNameKind(), mem.getAnnotations(),
             builder.getArrayAttr(portAnnotations), mem.getInnerSymAttr(),
-            mem.getGroupIDAttr());
+            mem.getGroupIDAttr(), mem.getInitAttr());
         for (const auto &res : llvm::enumerate(oldResults))
           res.value().replaceAllUsesWith(newMem.getResult(res.index()));
         mem.erase();
diff --git a/lib/Dialect/HW/HWOps.cpp b/lib/Dialect/HW/HWOps.cpp
index 339eb3bf2..55602a819 100644
--- a/lib/Dialect/HW/HWOps.cpp
+++ b/lib/Dialect/HW/HWOps.cpp
@@ -362,8 +362,8 @@ void ConstantOp::getAsmResultNames(
   setNameFn(getResult(), specialName.str());
 }
 
-OpFoldResult ConstantOp::fold(ArrayRef<Attribute> constants) {
-  assert(constants.empty() && "constant has no operands");
+OpFoldResult ConstantOp::fold(FoldAdaptor adaptor) {
+  assert(adaptor.getOperands().empty() && "constant has no operands");
   return getValueAttr();
 }
 
@@ -431,9 +431,7 @@ LogicalResult AggregateConstantOp::verify() {
   return checkAttributes(*this, getFieldsAttr(), getType());
 }
 
-OpFoldResult AggregateConstantOp::fold(ArrayRef<Attribute> operands) {
-  return getFieldsAttr();
-}
+OpFoldResult AggregateConstantOp::fold(FoldAdaptor) { return getFieldsAttr(); }
 
 //===----------------------------------------------------------------------===//
 // ParamValueOp
@@ -459,8 +457,8 @@ LogicalResult ParamValueOp::verify() {
       getValue(), (*this)->getParentOfType<hw::HWModuleOp>(), *this);
 }
 
-OpFoldResult ParamValueOp::fold(ArrayRef<Attribute> constants) {
-  assert(constants.empty() && "hw.param.value has no operands");
+OpFoldResult ParamValueOp::fold(FoldAdaptor adaptor) {
+  assert(adaptor.getOperands().empty() && "hw.param.value has no operands");
   return getValueAttr();
 }
 
@@ -526,17 +524,47 @@ StringAttr hw::getModuleResultNameAttr(Operation *module, size_t resultNo) {
 void hw::setModuleArgumentNames(Operation *module, ArrayRef<Attribute> names) {
   assert(isAnyModule(module) && "Must be called on a module");
   assert(getModuleType(module).getNumInputs() == names.size() &&
-         "incorrect number of arguments names specified");
+         "incorrect number of argument names specified");
   module->setAttr("argNames", ArrayAttr::get(module->getContext(), names));
 }
 
 void hw::setModuleResultNames(Operation *module, ArrayRef<Attribute> names) {
   assert(isAnyModule(module) && "Must be called on a module");
   assert(getModuleType(module).getNumResults() == names.size() &&
-         "incorrect number of arguments names specified");
+         "incorrect number of argument names specified");
   module->setAttr("resultNames", ArrayAttr::get(module->getContext(), names));
 }
 
+LocationAttr hw::getModuleArgumentLocAttr(Operation *module, size_t argNo) {
+  auto argumentLocs = module->getAttrOfType<ArrayAttr>("argLocs");
+  // Tolerate malformed IR here to enable debug printing etc.
+  if (argumentLocs && argNo < argumentLocs.size())
+    return argumentLocs[argNo].cast<LocationAttr>();
+  return LocationAttr();
+}
+
+LocationAttr hw::getModuleResultLocAttr(Operation *module, size_t resultNo) {
+  auto resultLocs = module->getAttrOfType<ArrayAttr>("resultLocs");
+  // Tolerate malformed IR here to enable debug printing etc.
+  if (resultLocs && resultNo < resultLocs.size())
+    return resultLocs[resultNo].cast<LocationAttr>();
+  return LocationAttr();
+}
+
+void hw::setModuleArgumentLocs(Operation *module, ArrayRef<Attribute> locs) {
+  assert(isAnyModule(module) && "Must be called on a module");
+  assert(getModuleType(module).getNumInputs() == locs.size() &&
+         "incorrect number of argument locations specified");
+  module->setAttr("argLocs", ArrayAttr::get(module->getContext(), locs));
+}
+
+void hw::setModuleResultLocs(Operation *module, ArrayRef<Attribute> locs) {
+  assert(isAnyModule(module) && "Must be called on a module");
+  assert(getModuleType(module).getNumResults() == locs.size() &&
+         "incorrect number of result locations specified");
+  module->setAttr("resultLocs", ArrayAttr::get(module->getContext(), locs));
+}
+
 // Flag for parsing different module types
 enum ExternModKind { PlainMod, ExternMod, GenMod };
 
@@ -546,6 +574,7 @@ buildModule(OpBuilder &builder, OperationState &result, StringAttr name,
             const ModulePortInfo &ports, ArrayAttr parameters,
             ArrayRef<NamedAttribute> attributes, StringAttr comment) {
   using namespace mlir::function_interface_impl;
+  LocationAttr unknownLoc = builder.getUnknownLoc();
 
   // Add an attribute for the name.
   result.addAttribute(SymbolTable::getSymbolAttrName(), name);
@@ -553,6 +582,7 @@ buildModule(OpBuilder &builder, OperationState &result, StringAttr name,
   SmallVector<Attribute> argNames, resultNames;
   SmallVector<Type, 4> argTypes, resultTypes;
   SmallVector<Attribute> argAttrs, resultAttrs;
+  SmallVector<Attribute> argLocs, resultLocs;
   auto exportPortIdent = StringAttr::get(builder.getContext(), "hw.exportPort");
 
   for (auto elt : ports.inputs) {
@@ -560,6 +590,7 @@ buildModule(OpBuilder &builder, OperationState &result, StringAttr name,
       elt.type = hw::InOutType::get(elt.type);
     argTypes.push_back(elt.type);
     argNames.push_back(elt.name);
+    argLocs.push_back(elt.loc ? elt.loc : unknownLoc);
     Attribute attr;
     if (elt.sym && !elt.sym.empty())
       attr = builder.getDictionaryAttr({{exportPortIdent, elt.sym}});
@@ -571,6 +602,7 @@ buildModule(OpBuilder &builder, OperationState &result, StringAttr name,
   for (auto elt : ports.outputs) {
     resultTypes.push_back(elt.type);
     resultNames.push_back(elt.name);
+    resultLocs.push_back(elt.loc ? elt.loc : unknownLoc);
     Attribute attr;
     if (elt.sym && !elt.sym.empty())
       attr = builder.getDictionaryAttr({{exportPortIdent, elt.sym}});
@@ -589,6 +621,8 @@ buildModule(OpBuilder &builder, OperationState &result, StringAttr name,
                       TypeAttr::get(type));
   result.addAttribute("argNames", builder.getArrayAttr(argNames));
   result.addAttribute("resultNames", builder.getArrayAttr(resultNames));
+  result.addAttribute("argLocs", builder.getArrayAttr(argLocs));
+  result.addAttribute("resultLocs", builder.getArrayAttr(resultLocs));
   result.addAttribute(ModuleTy::getArgAttrsAttrName(result.name),
                       builder.getArrayAttr(argAttrs));
   result.addAttribute(ModuleTy::getResAttrsAttrName(result.name),
@@ -606,8 +640,9 @@ static void modifyModuleArgs(
     MLIRContext *context, ArrayRef<std::pair<unsigned, PortInfo>> insertArgs,
     ArrayRef<unsigned> removeArgs, ArrayRef<Attribute> oldArgNames,
     ArrayRef<Type> oldArgTypes, ArrayRef<Attribute> oldArgAttrs,
-    SmallVector<Attribute> &newArgNames, SmallVector<Type> &newArgTypes,
-    SmallVector<Attribute> &newArgAttrs, Block *body = nullptr) {
+    ArrayRef<Attribute> oldArgLocs, SmallVector<Attribute> &newArgNames,
+    SmallVector<Type> &newArgTypes, SmallVector<Attribute> &newArgAttrs,
+    SmallVector<Attribute> &newArgLocs, Block *body = nullptr) {
 
 #ifndef NDEBUG
   // Check that the `insertArgs` and `removeArgs` indices are in ascending
@@ -626,9 +661,11 @@ static void modifyModuleArgs(
   newArgNames.reserve(newArgCount);
   newArgTypes.reserve(newArgCount);
   newArgAttrs.reserve(newArgCount);
+  newArgLocs.reserve(newArgCount);
 
   auto exportPortAttrName = StringAttr::get(context, "hw.exportPort");
   auto emptyDictAttr = DictionaryAttr::get(context, {});
+  auto unknownLoc = UnknownLoc::get(context);
 
   BitVector erasedIndices;
   if (body)
@@ -648,8 +685,10 @@ static void modifyModuleArgs(
       newArgTypes.push_back(port.type);
       newArgAttrs.push_back(attr);
       insertArgs = insertArgs.drop_front();
+      LocationAttr loc = port.loc ? port.loc : unknownLoc;
+      newArgLocs.push_back(loc);
       if (body)
-        body->insertArgument(idx++, port.type, UnknownLoc::get(context));
+        body->insertArgument(idx++, port.type, loc);
     }
     if (argIdx == oldArgCount)
       break;
@@ -669,6 +708,7 @@ static void modifyModuleArgs(
       newArgTypes.push_back(oldArgTypes[argIdx]);
       newArgAttrs.push_back(oldArgAttrs.empty() ? emptyDictAttr
                                                 : oldArgAttrs[argIdx]);
+      newArgLocs.push_back(oldArgLocs[argIdx]);
     }
   }
 
@@ -678,6 +718,7 @@ static void modifyModuleArgs(
   assert(newArgNames.size() == newArgCount);
   assert(newArgTypes.size() == newArgCount);
   assert(newArgAttrs.size() == newArgCount);
+  assert(newArgLocs.size() == newArgCount);
 }
 
 /// Insert and remove ports of a module. The insertion and removal indices must
@@ -692,45 +733,48 @@ void hw::modifyModulePorts(
     ArrayRef<unsigned> removeInputs, ArrayRef<unsigned> removeOutputs,
     Block *body) {
   auto moduleOp = cast<mlir::FunctionOpInterface>(op);
+  auto *context = moduleOp.getContext();
 
   auto arrayOrEmpty = [](ArrayAttr attr) {
     return attr ? attr.getValue() : ArrayRef<Attribute>{};
   };
 
   // Dig up the old argument and result data.
-  ArrayRef<Attribute> oldArgNames =
-      moduleOp->getAttrOfType<ArrayAttr>("argNames").getValue();
-  ArrayRef<Type> oldArgTypes = moduleOp.getArgumentTypes();
-  ArrayRef<Attribute> oldArgAttrs = arrayOrEmpty(moduleOp.getArgAttrsAttr());
+  auto oldArgNames = moduleOp->getAttrOfType<ArrayAttr>("argNames").getValue();
+  auto oldArgTypes = moduleOp.getArgumentTypes();
+  auto oldArgAttrs = arrayOrEmpty(moduleOp.getArgAttrsAttr());
+  auto oldArgLocs = moduleOp->getAttrOfType<ArrayAttr>("argLocs").getValue();
 
-  ArrayRef<Attribute> oldResultNames =
+  auto oldResultNames =
       moduleOp->getAttrOfType<ArrayAttr>("resultNames").getValue();
-  ArrayRef<Type> oldResultTypes = moduleOp.getResultTypes();
-  ArrayRef<Attribute> oldResultAttrs = arrayOrEmpty(moduleOp.getResAttrsAttr());
+  auto oldResultTypes = moduleOp.getResultTypes();
+  auto oldResultAttrs = arrayOrEmpty(moduleOp.getResAttrsAttr());
+  auto oldResultLocs =
+      moduleOp->getAttrOfType<ArrayAttr>("resultLocs").getValue();
 
   // Modify the ports.
   SmallVector<Attribute> newArgNames, newResultNames;
   SmallVector<Type> newArgTypes, newResultTypes;
   SmallVector<Attribute> newArgAttrs, newResultAttrs;
+  SmallVector<Attribute> newArgLocs, newResultLocs;
 
-  modifyModuleArgs(moduleOp.getContext(), insertInputs, removeInputs,
-                   oldArgNames, oldArgTypes, oldArgAttrs, newArgNames,
-                   newArgTypes, newArgAttrs, body);
+  modifyModuleArgs(context, insertInputs, removeInputs, oldArgNames,
+                   oldArgTypes, oldArgAttrs, oldArgLocs, newArgNames,
+                   newArgTypes, newArgAttrs, newArgLocs, body);
 
-  modifyModuleArgs(moduleOp.getContext(), insertOutputs, removeOutputs,
-                   oldResultNames, oldResultTypes, oldResultAttrs,
-                   newResultNames, newResultTypes, newResultAttrs);
+  modifyModuleArgs(context, insertOutputs, removeOutputs, oldResultNames,
+                   oldResultTypes, oldResultAttrs, oldResultLocs,
+                   newResultNames, newResultTypes, newResultAttrs,
+                   newResultLocs);
 
   // Update the module operation types and attributes.
-  moduleOp.setType(
-      FunctionType::get(moduleOp.getContext(), newArgTypes, newResultTypes));
-  moduleOp->setAttr("argNames",
-                    ArrayAttr::get(moduleOp.getContext(), newArgNames));
-  moduleOp->setAttr("resultNames",
-                    ArrayAttr::get(moduleOp.getContext(), newResultNames));
-  moduleOp.setArgAttrsAttr(ArrayAttr::get(moduleOp.getContext(), newArgAttrs));
-  moduleOp.setResAttrsAttr(
-      ArrayAttr::get(moduleOp.getContext(), newResultAttrs));
+  moduleOp.setType(FunctionType::get(context, newArgTypes, newResultTypes));
+  moduleOp->setAttr("argNames", ArrayAttr::get(context, newArgNames));
+  moduleOp.setArgAttrsAttr(ArrayAttr::get(context, newArgAttrs));
+  moduleOp->setAttr("argLocs", ArrayAttr::get(context, newArgLocs));
+  moduleOp->setAttr("resultNames", ArrayAttr::get(context, newResultNames));
+  moduleOp.setResAttrsAttr(ArrayAttr::get(context, newResultAttrs));
+  moduleOp->setAttr("resultLocs", ArrayAttr::get(context, newResultLocs));
 }
 
 void HWModuleOp::build(OpBuilder &builder, OperationState &result,
@@ -747,8 +791,14 @@ void HWModuleOp::build(OpBuilder &builder, OperationState &result,
   bodyRegion->push_back(body);
 
   // Add arguments to the body block.
-  for (auto elt : ports.inputs)
-    body->addArgument(elt.type, builder.getUnknownLoc());
+  auto unknownLoc = builder.getUnknownLoc();
+  for (auto port : ports.inputs) {
+    auto loc = port.loc ? Location(port.loc) : unknownLoc;
+    auto type = port.type;
+    if (port.isInOut() && !type.isa<InOutType>())
+      type = InOutType::get(type);
+    body->addArgument(type, loc);
+  }
 
   if (shouldEnsureTerminator)
     HWModuleOp::ensureTerminator(*bodyRegion, builder, result.location);
@@ -876,9 +926,9 @@ ModulePortInfo hw::getModulePortInfo(Operation *op) {
          "Can only get module ports from an instance or module");
 
   SmallVector<PortInfo> inputs, outputs;
-  auto argTypes = getModuleType(op).getInputs();
-
   auto argNames = op->getAttrOfType<ArrayAttr>("argNames");
+  auto argTypes = getModuleType(op).getInputs();
+  auto argLocs = op->getAttrOfType<ArrayAttr>("argLocs");
   for (unsigned i = 0, e = argTypes.size(); i < e; ++i) {
     bool isInOut = false;
     auto type = argTypes[i];
@@ -889,15 +939,23 @@ ModulePortInfo hw::getModulePortInfo(Operation *op) {
     }
 
     auto direction = isInOut ? PortDirection::INOUT : PortDirection::INPUT;
-    inputs.push_back(
-        {argNames[i].cast<StringAttr>(), direction, type, i, getArgSym(op, i)});
+    LocationAttr loc;
+    if (argLocs)
+      loc = argLocs[i].cast<LocationAttr>();
+
+    inputs.push_back({argNames[i].cast<StringAttr>(), direction, type, i,
+                      getArgSym(op, i), loc});
   }
 
   auto resultNames = op->getAttrOfType<ArrayAttr>("resultNames");
   auto resultTypes = getModuleType(op).getResults();
+  auto resultLocs = op->getAttrOfType<ArrayAttr>("resultLocs");
   for (unsigned i = 0, e = resultTypes.size(); i < e; ++i) {
+    LocationAttr loc;
+    if (resultLocs)
+      loc = resultLocs[i].cast<LocationAttr>();
     outputs.push_back({resultNames[i].cast<StringAttr>(), PortDirection::OUTPUT,
-                       resultTypes[i], i, getResultSym(op, i)});
+                       resultTypes[i], i, getResultSym(op, i), loc});
   }
   return ModulePortInfo(inputs, outputs);
 }
@@ -912,6 +970,8 @@ SmallVector<PortInfo> hw::getAllModulePortInfos(Operation *op) {
   SmallVector<PortInfo> results;
   auto argTypes = getModuleType(op).getInputs();
   auto argNames = op->getAttrOfType<ArrayAttr>("argNames");
+  auto argLocs = op->getAttrOfType<ArrayAttr>("argLocs");
+
   for (unsigned i = 0, e = argTypes.size(); i < e; ++i) {
     bool isInOut = false;
     auto type = argTypes[i];
@@ -921,16 +981,28 @@ SmallVector<PortInfo> hw::getAllModulePortInfos(Operation *op) {
       type = inout.getElementType();
     }
 
+    // Instance ops will not have port location information.
+    LocationAttr argLoc;
+    if (argLocs)
+      argLoc = argLocs[i].cast<LocationAttr>();
+
     auto direction = isInOut ? PortDirection::INOUT : PortDirection::INPUT;
-    results.push_back(
-        {argNames[i].cast<StringAttr>(), direction, type, i, getArgSym(op, i)});
+    results.push_back({argNames[i].cast<StringAttr>(), direction, type, i,
+                       getArgSym(op, i), argLoc});
   }
 
   auto resultNames = op->getAttrOfType<ArrayAttr>("resultNames");
+  auto resultLocs = op->getAttrOfType<ArrayAttr>("resultLocs");
   auto resultTypes = getModuleType(op).getResults();
   for (unsigned i = 0, e = resultTypes.size(); i < e; ++i) {
+
+    // Instance ops will not have port location information.
+    LocationAttr resultLoc;
+    if (resultLocs)
+      resultLoc = resultLocs[i].cast<mlir::LocationAttr>();
+
     results.push_back({resultNames[i].cast<StringAttr>(), PortDirection::OUTPUT,
-                       resultTypes[i], i, getResultSym(op, i)});
+                       resultTypes[i], i, getResultSym(op, i), resultLoc});
   }
   return results;
 }
@@ -939,6 +1011,7 @@ SmallVector<PortInfo> hw::getAllModulePortInfos(Operation *op) {
 PortInfo hw::getModuleInOrInoutPort(Operation *op, size_t idx) {
   auto argTypes = getModuleType(op).getInputs();
   auto argNames = op->getAttrOfType<ArrayAttr>("argNames");
+  auto argLocs = op->getAttrOfType<ArrayAttr>("argLocs");
   bool isInOut = false;
   auto type = argTypes[idx];
 
@@ -948,17 +1021,26 @@ PortInfo hw::getModuleInOrInoutPort(Operation *op, size_t idx) {
   }
 
   auto direction = isInOut ? PortDirection::INOUT : PortDirection::INPUT;
-  return {argNames[idx].cast<StringAttr>(), direction, type, idx,
-          getArgSym(op, idx)};
+  return {argNames[idx].cast<StringAttr>(),
+          direction,
+          type,
+          idx,
+          getArgSym(op, idx),
+          argLocs[idx].cast<LocationAttr>()};
 }
 
 /// Return the PortInfo for the specified output port.
 PortInfo hw::getModuleOutputPort(Operation *op, size_t idx) {
   auto resultNames = op->getAttrOfType<ArrayAttr>("resultNames");
+  auto resultLocs = op->getAttrOfType<ArrayAttr>("resultLocs");
   auto resultTypes = getModuleType(op).getResults();
   assert(idx < resultNames.size() && "invalid result number");
-  return {resultNames[idx].cast<StringAttr>(), PortDirection::OUTPUT,
-          resultTypes[idx], idx, getResultSym(op, idx)};
+  return {resultNames[idx].cast<StringAttr>(),
+          PortDirection::OUTPUT,
+          resultTypes[idx],
+          idx,
+          getResultSym(op, idx),
+          resultLocs[idx].cast<LocationAttr>()};
 }
 
 static bool hasAttribute(StringRef name, ArrayRef<NamedAttribute> attrs) {
@@ -973,15 +1055,8 @@ static ParseResult parseHWModuleOp(OpAsmParser &parser, OperationState &result,
                                    ExternModKind modKind = PlainMod) {
 
   using namespace mlir::function_interface_impl;
-
   auto loc = parser.getCurrentLocation();
 
-  SmallVector<OpAsmParser::Argument, 4> entryArgs;
-  SmallVector<DictionaryAttr> resultAttrs;
-  SmallVector<Type, 4> resultTypes;
-  ArrayAttr parameters;
-  auto &builder = parser.getBuilder();
-
   // Parse the visibility attribute.
   (void)mlir::impl::parseOptionalVisibilityKeyword(parser, result.attributes);
 
@@ -991,6 +1066,7 @@ static ParseResult parseHWModuleOp(OpAsmParser &parser, OperationState &result,
                              result.attributes))
     return failure();
 
+  // Parse the generator information.
   FlatSymbolRefAttr kindAttr;
   if (modKind == GenMod) {
     if (parser.parseComma() ||
@@ -999,28 +1075,28 @@ static ParseResult parseHWModuleOp(OpAsmParser &parser, OperationState &result,
     }
   }
 
+  // Parse the parameters.
+  ArrayAttr parameters;
+  if (parseOptionalParameterList(parser, parameters))
+    return failure();
+
   // Parse the function signature.
   bool isVariadic = false;
+  SmallVector<OpAsmParser::Argument, 4> entryArgs;
+  SmallVector<Attribute> argNames;
+  SmallVector<Attribute> argLocs;
   SmallVector<Attribute> resultNames;
-  if (parseOptionalParameterList(parser, parameters) ||
-      module_like_impl::parseModuleFunctionSignature(
-          parser, entryArgs, isVariadic, resultTypes, resultAttrs,
-          resultNames) ||
-      // If function attributes are present, parse them.
-      parser.parseOptionalAttrDictWithKeyword(result.attributes))
+  SmallVector<DictionaryAttr> resultAttrs;
+  SmallVector<Attribute> resultLocs;
+  TypeAttr functionType;
+  if (failed(module_like_impl::parseModuleFunctionSignature(
+          parser, isVariadic, entryArgs, argNames, argLocs, resultNames,
+          resultAttrs, resultLocs, functionType)))
     return failure();
 
-  // Record the argument and result types as an attribute.  This is necessary
-  // for external modules.
-  SmallVector<Type> argTypes;
-  for (auto &arg : entryArgs)
-    argTypes.push_back(arg.type);
-
-  auto type = builder.getFunctionType(argTypes, resultTypes);
-  result.addAttribute(ModuleTy::getFunctionTypeAttrName(result.name),
-                      TypeAttr::get(type));
-
-  auto *context = result.getContext();
+  // Parse the attribute dict.
+  if (failed(parser.parseOptionalAttrDictWithKeyword(result.attributes)))
+    return failure();
 
   if (hasAttribute("resultNames", result.attributes) ||
       hasAttribute("parameters", result.attributes)) {
@@ -1029,16 +1105,7 @@ static ParseResult parseHWModuleOp(OpAsmParser &parser, OperationState &result,
     return failure();
   }
 
-  // Use the argument and result names if not already specified.
-  SmallVector<Attribute> argNames;
-  if (!entryArgs.empty()) {
-    for (auto &arg : entryArgs)
-      argNames.push_back(
-          module_like_impl::getPortNameAttr(context, arg.ssaName.name));
-  } else if (!argTypes.empty()) {
-    // The parser returns empty names in a special way.
-    argNames.assign(argTypes.size(), StringAttr::get(context, ""));
-  }
+  auto *context = result.getContext();
 
   // An explicit `argNames` attribute overrides the MLIR names.  This is how
   // we represent port names that aren't valid MLIR identifiers.  Result and
@@ -1046,15 +1113,17 @@ static ParseResult parseHWModuleOp(OpAsmParser &parser, OperationState &result,
   // they don't need this affordance.
   if (!hasAttribute("argNames", result.attributes))
     result.addAttribute("argNames", ArrayAttr::get(context, argNames));
+  result.addAttribute("argLocs", ArrayAttr::get(context, argLocs));
   result.addAttribute("resultNames", ArrayAttr::get(context, resultNames));
+  result.addAttribute("resultLocs", ArrayAttr::get(context, resultLocs));
   result.addAttribute("parameters", parameters);
   if (!hasAttribute("comment", result.attributes))
     result.addAttribute("comment", StringAttr::get(context, ""));
-
-  assert(resultAttrs.size() == resultTypes.size());
+  result.addAttribute(ModuleTy::getFunctionTypeAttrName(result.name),
+                      functionType);
 
   // Add the attributes to the function arguments.
-  addArgAndResultAttrs(builder, result, entryArgs, resultAttrs,
+  addArgAndResultAttrs(parser.getBuilder(), result, entryArgs, resultAttrs,
                        ModuleTy::getArgAttrsAttrName(result.name),
                        ModuleTy::getResAttrsAttrName(result.name));
 
@@ -1124,10 +1193,12 @@ static void printModuleOp(OpAsmPrinter &p, Operation *op,
     omittedAttrs.push_back("generatorKind");
   if (!needArgNamesAttr)
     omittedAttrs.push_back("argNames");
+  omittedAttrs.push_back("argLocs");
   omittedAttrs.push_back(ModuleTy::getFunctionTypeAttrName(op->getName()));
   omittedAttrs.push_back(ModuleTy::getArgAttrsAttrName(op->getName()));
   omittedAttrs.push_back(ModuleTy::getResAttrsAttrName(op->getName()));
   omittedAttrs.push_back("resultNames");
+  omittedAttrs.push_back("resultLocs");
   omittedAttrs.push_back("parameters");
   omittedAttrs.push_back(visibilityAttrName);
   if (op->getAttrOfType<StringAttr>("comment").getValue().empty())
@@ -1160,13 +1231,23 @@ static LogicalResult verifyModuleCommon(Operation *module) {
          "verifier hook should only be called on modules");
 
   auto moduleType = getModuleType(module);
+
   auto argNames = module->getAttrOfType<ArrayAttr>("argNames");
-  auto resultNames = module->getAttrOfType<ArrayAttr>("resultNames");
   if (argNames.size() != moduleType.getNumInputs())
     return module->emitOpError("incorrect number of argument names");
+
+  auto resultNames = module->getAttrOfType<ArrayAttr>("resultNames");
   if (resultNames.size() != moduleType.getNumResults())
     return module->emitOpError("incorrect number of result names");
 
+  auto argLocs = module->getAttrOfType<ArrayAttr>("argLocs");
+  if (argLocs.size() != moduleType.getNumInputs())
+    return module->emitOpError("incorrect number of argument locations");
+
+  auto resultLocs = module->getAttrOfType<ArrayAttr>("resultLocs");
+  if (resultLocs.size() != moduleType.getNumResults())
+    return module->emitOpError("incorrect number of result locations");
+
   SmallPtrSet<Attribute, 4> paramNames;
 
   // Check parameter default values are sensible.
@@ -1204,7 +1285,31 @@ static LogicalResult verifyModuleCommon(Operation *module) {
   return success();
 }
 
-LogicalResult HWModuleOp::verify() { return verifyModuleCommon(*this); }
+LogicalResult HWModuleOp::verify() {
+  if (failed(verifyModuleCommon(*this)))
+    return failure();
+
+  auto type = getFunctionType();
+  auto *body = getBodyBlock();
+
+  // Verify the number of block arguments.
+  auto numInputs = type.getNumInputs();
+  if (body->getNumArguments() != numInputs)
+    return emitOpError("entry block must have")
+           << numInputs << " arguments to match module signature";
+
+  // Verify that the block arguments match the op's attributes.
+  for (auto [arg, type, loc] :
+       llvm::zip(getArguments(), type.getInputs(), getArgLocs())) {
+    if (arg.getType() != type)
+      return emitOpError("block argument types should match signature types");
+    if (arg.getLoc() != loc.cast<LocationAttr>())
+      return emitOpError(
+          "block argument locations should match signature locations");
+  }
+
+  return success();
+}
 
 LogicalResult HWModuleExternOp::verify() { return verifyModuleCommon(*this); }
 
@@ -1629,10 +1734,10 @@ LogicalResult ArrayCreateOp::verify() {
   return success();
 }
 
-OpFoldResult ArrayCreateOp::fold(ArrayRef<Attribute> constants) {
-  if (llvm::any_of(constants, [](Attribute attr) { return !attr; }))
+OpFoldResult ArrayCreateOp::fold(FoldAdaptor adaptor) {
+  if (llvm::any_of(adaptor.getInputs(), [](Attribute attr) { return !attr; }))
     return {};
-  return ArrayAttr::get(getContext(), constants);
+  return ArrayAttr::get(getContext(), adaptor.getInputs());
 }
 
 // Check whether an integer value is an offset from a base.
@@ -1750,7 +1855,7 @@ LogicalResult ArraySliceOp::verify() {
   return success();
 }
 
-OpFoldResult ArraySliceOp::fold(ArrayRef<Attribute> constants) {
+OpFoldResult ArraySliceOp::fold(FoldAdaptor adaptor) {
   // If we are slicing the entire input, then return it.
   if (getType() == getInput().getType())
     return getInput();
@@ -1912,12 +2017,13 @@ void ArrayConcatOp::build(OpBuilder &b, OperationState &state,
   build(b, state, ArrayType::get(elemTy, resultSize), values);
 }
 
-OpFoldResult ArrayConcatOp::fold(ArrayRef<Attribute> constants) {
+OpFoldResult ArrayConcatOp::fold(FoldAdaptor adaptor) {
+  auto inputs = adaptor.getInputs();
   SmallVector<Attribute> array;
   for (size_t i = 0, e = getNumOperands(); i < e; ++i) {
-    if (!constants[i])
+    if (!inputs[i])
       return {};
-    llvm::copy(constants[i].cast<ArrayAttr>(), std::back_inserter(array));
+    llvm::copy(inputs[i].cast<ArrayAttr>(), std::back_inserter(array));
   }
   return ArrayAttr::get(getContext(), array);
 }
@@ -2074,8 +2180,8 @@ void EnumConstantOp::getAsmResultNames(
   setNameFn(getResult(), getField().getField().str());
 }
 
-OpFoldResult EnumConstantOp::fold(ArrayRef<Attribute> constants) {
-  assert(constants.empty() && "constant has no operands");
+OpFoldResult EnumConstantOp::fold(FoldAdaptor adaptor) {
+  assert(adaptor.getOperands().empty() && "constant has no operands");
   return getFieldAttr();
 }
 
@@ -2130,10 +2236,11 @@ LogicalResult StructCreateOp::verify() {
   return success();
 }
 
-OpFoldResult StructCreateOp::fold(ArrayRef<Attribute> constants) {
-  if (llvm::any_of(constants, [](Attribute attr) { return !attr; }))
+OpFoldResult StructCreateOp::fold(FoldAdaptor adaptor) {
+  auto inputs = adaptor.getInput();
+  if (llvm::any_of(inputs, [](Attribute attr) { return !attr; }))
     return {};
-  return ArrayAttr::get(getContext(), constants);
+  return ArrayAttr::get(getContext(), inputs);
 }
 
 //===----------------------------------------------------------------------===//
@@ -2170,11 +2277,12 @@ void StructExplodeOp::print(OpAsmPrinter &printer) {
   printer << " : " << getInput().getType();
 }
 
-LogicalResult StructExplodeOp::fold(ArrayRef<Attribute> operands,
+LogicalResult StructExplodeOp::fold(FoldAdaptor adaptor,
                                     SmallVectorImpl<OpFoldResult> &results) {
-  if (!operands[0])
+  auto input = adaptor.getInput();
+  if (!input)
     return failure();
-  llvm::copy(operands[0].cast<ArrayAttr>(), std::back_inserter(results));
+  llvm::copy(input.cast<ArrayAttr>(), std::back_inserter(results));
   return success();
 }
 
@@ -2266,7 +2374,7 @@ void StructExtractOp::build(OpBuilder &builder, OperationState &odsState,
   build(builder, odsState, resultType, input, fieldAttr);
 }
 
-OpFoldResult StructExtractOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult StructExtractOp::fold(FoldAdaptor) {
   if (auto foldResult =
           foldStructExtract(getInput().getDefiningOp(), getField()))
     return foldResult;
@@ -2343,14 +2451,16 @@ void StructInjectOp::print(OpAsmPrinter &printer) {
   printer << " : " << getInput().getType();
 }
 
-OpFoldResult StructInjectOp::fold(ArrayRef<Attribute> operands) {
-  if (!operands[0] || !operands[1])
+OpFoldResult StructInjectOp::fold(FoldAdaptor adaptor) {
+  auto input = adaptor.getInput();
+  auto newValue = adaptor.getNewValue();
+  if (!input || !newValue)
     return {};
   SmallVector<Attribute> array;
-  llvm::copy(operands[0].cast<ArrayAttr>(), std::back_inserter(array));
+  llvm::copy(input.cast<ArrayAttr>(), std::back_inserter(array));
   StructType structType = getInput().getType();
   auto index = *structType.getFieldIndex(getField());
-  array[index] = operands[1];
+  array[index] = newValue;
   return ArrayAttr::get(getContext(), array);
 }
 
@@ -2473,18 +2583,23 @@ void ArrayGetOp::build(OpBuilder &builder, OperationState &result, Value input,
 // single uniform value for each element, just return that value regardless of
 // the index. If the array is constructed from a constant by a bitcast
 // operation, we can fold into a constant.
-OpFoldResult ArrayGetOp::fold(ArrayRef<Attribute> operands) {
-  if (operands[0]) {
-    auto arrayAttr = operands[0].cast<ArrayAttr>();
+OpFoldResult ArrayGetOp::fold(FoldAdaptor adaptor) {
+  auto inputCst = adaptor.getInput().dyn_cast_or_null<ArrayAttr>();
+  auto indexCst = adaptor.getIndex().dyn_cast_or_null<IntegerAttr>();
+
+  if (inputCst) {
     // Constant array index.
-    if (operands[1]) {
-      auto index = operands[1].cast<IntegerAttr>().getValue();
-      return arrayAttr[arrayAttr.size() - 1 - index.getZExtValue()];
+    if (indexCst) {
+      auto indexVal = indexCst.getValue();
+      if (indexVal.getBitWidth() < 64) {
+        auto index = indexVal.getZExtValue();
+        return inputCst[inputCst.size() - 1 - index];
+      }
     }
     // If all elements of the array are the same, we can return any element of
     // array.
-    if (!arrayAttr.empty() && llvm::all_equal(arrayAttr))
-      return arrayAttr[0];
+    if (!inputCst.empty() && llvm::all_equal(inputCst))
+      return inputCst[0];
   }
 
   // array_get(bitcast(c), i) -> c[i*w+w-1:i*w]
@@ -2492,39 +2607,36 @@ OpFoldResult ArrayGetOp::fold(ArrayRef<Attribute> operands) {
     auto intTy = getType().dyn_cast<IntegerType>();
     if (!intTy)
       return {};
-    auto inputConsatnt = bitcast.getInput().getDefiningOp<hw::ConstantOp>();
-    if (!inputConsatnt)
+    auto bitcastInputOp = bitcast.getInput().getDefiningOp<hw::ConstantOp>();
+    if (!bitcastInputOp)
       return {};
-    IntegerAttr constIdx = operands[1].dyn_cast_or_null<IntegerAttr>();
-    if (!constIdx)
+    if (!indexCst)
       return {};
-    auto constant = inputConsatnt.getValue();
+    auto bitcastInputCst = bitcastInputOp.getValue();
     // Calculate the index. Make sure to zero-extend the index value before
     // multiplying the element width.
-    auto startIdx = constIdx.getValue().zext(constant.getBitWidth()) *
+    auto startIdx = indexCst.getValue().zext(bitcastInputCst.getBitWidth()) *
                     getType().getIntOrFloatBitWidth();
     // Extract [startIdx + width - 1: startIdx].
-    return IntegerAttr::get(
-        intTy, constant.lshr(startIdx).trunc(intTy.getIntOrFloatBitWidth()));
+    return IntegerAttr::get(intTy, bitcastInputCst.lshr(startIdx).trunc(
+                                       intTy.getIntOrFloatBitWidth()));
   }
 
-  auto inputCreate =
-      dyn_cast_or_null<ArrayCreateOp>(getInput().getDefiningOp());
+  auto inputCreate = getInput().getDefiningOp<ArrayCreateOp>();
   if (!inputCreate)
     return {};
 
   if (auto uniformValue = inputCreate.getUniformElement())
     return uniformValue;
 
-  IntegerAttr constIdx = operands[1].dyn_cast_or_null<IntegerAttr>();
-  if (!constIdx || constIdx.getValue().getBitWidth() > 64)
+  if (!indexCst || indexCst.getValue().getBitWidth() > 64)
     return {};
 
-  uint64_t idx = constIdx.getValue().getLimitedValue();
+  uint64_t index = indexCst.getValue().getLimitedValue();
   auto createInputs = inputCreate.getInputs();
-  if (idx >= createInputs.size())
+  if (index >= createInputs.size())
     return {};
-  return createInputs[createInputs.size() - idx - 1];
+  return createInputs[createInputs.size() - index - 1];
 }
 
 LogicalResult ArrayGetOp::canonicalize(ArrayGetOp op,
@@ -2592,7 +2704,7 @@ Type TypedeclOp::getAliasType() {
 // BitcastOp
 //===----------------------------------------------------------------------===//
 
-OpFoldResult BitcastOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult BitcastOp::fold(FoldAdaptor) {
   // Identity.
   // bitcast(%a) : A -> A ==> %a
   if (getOperand().getType() == getType())
diff --git a/lib/Dialect/HW/ModuleImplementation.cpp b/lib/Dialect/HW/ModuleImplementation.cpp
index e5bf478cd..9503d0588 100644
--- a/lib/Dialect/HW/ModuleImplementation.cpp
+++ b/lib/Dialect/HW/ModuleImplementation.cpp
@@ -13,6 +13,7 @@
 #include "mlir/IR/Builders.h"
 #include "mlir/IR/DialectImplementation.h"
 #include "mlir/IR/FunctionImplementation.h"
+#include <mlir/IR/BuiltinAttributes.h>
 
 using namespace circt;
 using namespace circt::hw;
@@ -40,26 +41,40 @@ StringAttr module_like_impl::getPortNameAttr(MLIRContext *context,
 ///   function-result-list-no-parens ::= function-result (`,` function-result)*
 ///   function-result ::= (percent-identifier `:`) type attribute-dict?
 ///
-ParseResult module_like_impl::parseFunctionResultList(
-    OpAsmParser &parser, SmallVectorImpl<Type> &resultTypes,
-    SmallVectorImpl<DictionaryAttr> &resultAttrs,
-    SmallVectorImpl<Attribute> &resultNames) {
+static ParseResult
+parseFunctionResultList(OpAsmParser &parser,
+                        SmallVectorImpl<Attribute> &resultNames,
+                        SmallVectorImpl<Type> &resultTypes,
+                        SmallVectorImpl<DictionaryAttr> &resultAttrs,
+                        SmallVectorImpl<Attribute> &resultLocs) {
 
   auto parseElt = [&]() -> ParseResult {
+    // Stash the current location parser location.
+    auto irLoc = parser.getCurrentLocation();
+
+    // Parse the result name.
     std::string portName;
     if (parser.parseKeywordOrString(&portName))
       return failure();
     resultNames.push_back(StringAttr::get(parser.getContext(), portName));
 
+    // Parse the results type.
     resultTypes.emplace_back();
-    resultAttrs.emplace_back();
+    if (parser.parseColonType(resultTypes.back()))
+      return failure();
 
+    // Parse the result attributes.
     NamedAttrList attrs;
-    if (parser.parseColonType(resultTypes.back()) ||
-        parser.parseOptionalAttrDict(attrs))
+    if (failed(parser.parseOptionalAttrDict(attrs)))
       return failure();
+    resultAttrs.push_back(attrs.getDictionary(parser.getContext()));
 
-    resultAttrs.back() = attrs.getDictionary(parser.getContext());
+    // Parse the result location.
+    llvm::Optional<Location> maybeLoc;
+    if (failed(parser.parseOptionalLocationSpecifier(maybeLoc)))
+      return failure();
+    Location loc = maybeLoc ? *maybeLoc : parser.getEncodedSourceLoc(irLoc);
+    resultLocs.push_back(loc);
 
     return success();
   };
@@ -68,22 +83,41 @@ ParseResult module_like_impl::parseFunctionResultList(
                                         parseElt);
 }
 
-/// This is a variant of mlir::parseFunctionSignature that allows names on
-/// result arguments.
 ParseResult module_like_impl::parseModuleFunctionSignature(
-    OpAsmParser &parser, SmallVectorImpl<OpAsmParser::Argument> &args,
-    bool &isVariadic, SmallVectorImpl<Type> &resultTypes,
+    OpAsmParser &parser, bool &isVariadic,
+    SmallVectorImpl<OpAsmParser::Argument> &args,
+    SmallVectorImpl<Attribute> &argNames, SmallVectorImpl<Attribute> &argLocs,
+    SmallVectorImpl<Attribute> &resultNames,
     SmallVectorImpl<DictionaryAttr> &resultAttrs,
-    SmallVectorImpl<Attribute> &resultNames) {
+    SmallVectorImpl<Attribute> &resultLocs, TypeAttr &type) {
 
   using namespace mlir::function_interface_impl;
+  auto *context = parser.getContext();
+
+  // Parse the argument list.
   if (parser.parseArgumentList(args, OpAsmParser::Delimiter::Paren,
                                /*allowTypes=*/true, /*allowAttrs=*/true))
     return failure();
 
+  // Parse the result list.
+  SmallVector<Type> resultTypes;
   if (succeeded(parser.parseOptionalArrow()))
-    return parseFunctionResultList(parser, resultTypes, resultAttrs,
-                                   resultNames);
+    if (failed(parseFunctionResultList(parser, resultNames, resultTypes,
+                                       resultAttrs, resultLocs)))
+      return failure();
+
+  // Process the ssa args for the information we're looking for.
+  SmallVector<Type> argTypes;
+  for (auto &arg : args) {
+    argNames.push_back(getPortNameAttr(context, arg.ssaName.name));
+    argTypes.push_back(arg.type);
+    if (!arg.sourceLoc)
+      arg.sourceLoc = parser.getEncodedSourceLoc(arg.ssaName.location);
+    argLocs.push_back(*arg.sourceLoc);
+  }
+
+  type = TypeAttr::get(FunctionType::get(context, argTypes, resultTypes));
+
   return success();
 }
 
@@ -97,6 +131,7 @@ void module_like_impl::printModuleSignature(OpAsmPrinter &p, Operation *op,
   Region &body = op->getRegion(0);
   bool isExternal = body.empty();
   SmallString<32> resultNameStr;
+  mlir::OpPrintingFlags flags;
 
   p << '(';
   for (unsigned i = 0, e = argTypes.size(); i < e; ++i) {
@@ -123,6 +158,13 @@ void module_like_impl::printModuleSignature(OpAsmPrinter &p, Operation *op,
 
     p.printType(argTypes[i]);
     p.printOptionalAttrDict(getArgAttrs(op, i));
+
+    // TODO: `printOptionalLocationSpecifier` will emit aliases for locations,
+    // even if they are not printed.  This will have to be fixed upstream.  For
+    // now, use what was specified on the command line.
+    if (flags.shouldPrintDebugInfo())
+      if (auto loc = getModuleArgumentLocAttr(op, i))
+        p.printOptionalLocationSpecifier(loc);
   }
 
   if (isVariadic) {
@@ -143,6 +185,13 @@ void module_like_impl::printModuleSignature(OpAsmPrinter &p, Operation *op,
       p << ": ";
       p.printType(resultTypes[i]);
       p.printOptionalAttrDict(getResultAttrs(op, i));
+
+      // TODO: `printOptionalLocationSpecifier` will emit aliases for locations,
+      // even if they are not printed.  This will have to be fixed upstream. For
+      // now, use what was specified on the command line.
+      if (flags.shouldPrintDebugInfo())
+        if (auto loc = getModuleResultLocAttr(op, i))
+          p.printOptionalLocationSpecifier(loc);
     }
     p << ')';
   }
diff --git a/lib/Dialect/HW/Transforms/FlattenIO.cpp b/lib/Dialect/HW/Transforms/FlattenIO.cpp
index 6041918a6..111472ddd 100644
--- a/lib/Dialect/HW/Transforms/FlattenIO.cpp
+++ b/lib/Dialect/HW/Transforms/FlattenIO.cpp
@@ -216,6 +216,43 @@ static void updateNameAttribute(FunctionOpInterface op, StringRef attrName,
                              ArrayAttr::get(op.getContext(), newNames));
 }
 
+static void updateLocAttribute(FunctionOpInterface op, StringRef attrName,
+                               DenseMap<unsigned, hw::StructType> &structMap) {
+  llvm::SmallVector<Attribute> newLocs;
+  auto oldLocs = op.getOperation()->getAttrOfType<ArrayAttr>(attrName);
+  if (!oldLocs)
+    return;
+  for (auto [i, oldLoc] : llvm::enumerate(oldLocs)) {
+    // Was this arg/res index a struct?
+    auto it = structMap.find(i);
+    if (it == structMap.end()) {
+      // No, keep old name.
+      newLocs.push_back(oldLoc);
+      continue;
+    }
+
+    auto structType = it->second;
+    for (size_t i = 0, e = structType.getElements().size(); i < e; ++i)
+      newLocs.push_back(oldLoc);
+  }
+  op.getOperation()->setAttr(attrName,
+                             ArrayAttr::get(op.getContext(), newLocs));
+}
+
+/// The conversion framework seems to throw away block argument locations.  We
+/// use this function to copy the location from the original argument to the
+/// set of flattened arguments.
+static void
+updateBlockLocations(FunctionOpInterface op, StringRef attrName,
+                     DenseMap<unsigned, hw::StructType> &structMap) {
+  auto locs = op.getOperation()->getAttrOfType<ArrayAttr>(attrName);
+  if (!locs)
+    return;
+  for (auto [arg, loc] :
+       llvm::zip(op.getArguments(), locs.getAsRange<LocationAttr>()))
+    arg.setLoc(loc);
+}
+
 template <typename T>
 static DenseMap<Operation *, IOInfo> populateIOInfoMap(mlir::ModuleOp module) {
   DenseMap<Operation *, IOInfo> ioInfoMap;
@@ -273,6 +310,9 @@ static LogicalResult flattenOpsOfType(ModuleOp module, bool recursive) {
       auto ioInfo = ioInfoMap[op];
       updateNameAttribute(op, "argNames", ioInfo.argStructs);
       updateNameAttribute(op, "resultNames", ioInfo.resStructs);
+      updateLocAttribute(op, "argLocs", ioInfo.argStructs);
+      updateLocAttribute(op, "resultLocs", ioInfo.resStructs);
+      updateBlockLocations(op, "argLocs", ioInfo.argStructs);
     }
 
     // Break if we've only lowering a single level of structs.
diff --git a/lib/Dialect/HWArith/HWArithOps.cpp b/lib/Dialect/HWArith/HWArithOps.cpp
index f246a5f12..aa2711355 100644
--- a/lib/Dialect/HWArith/HWArithOps.cpp
+++ b/lib/Dialect/HWArith/HWArithOps.cpp
@@ -60,8 +60,8 @@ void CastOp::getCanonicalizationPatterns(RewritePatternSet &results,
 
 APSInt ConstantOp::getConstantValue() { return getRawValueAttr().getAPSInt(); }
 
-OpFoldResult ConstantOp::fold(ArrayRef<Attribute> constants) {
-  assert(constants.empty() && "constant has no operands");
+OpFoldResult ConstantOp::fold(FoldAdaptor adaptor) {
+  assert(adaptor.getOperands().empty() && "constant has no operands");
   return getRawValueAttr();
 }
 
diff --git a/lib/Dialect/LLHD/IR/LLHDOps.cpp b/lib/Dialect/LLHD/IR/LLHDOps.cpp
index 5a910aad0..3b640e8c0 100644
--- a/lib/Dialect/LLHD/IR/LLHDOps.cpp
+++ b/lib/Dialect/LLHD/IR/LLHDOps.cpp
@@ -159,8 +159,8 @@ Type circt::llhd::getLLHDElementType(Type type) {
 // ConstantTimeOp
 //===----------------------------------------------------------------------===//
 
-OpFoldResult llhd::ConstantTimeOp::fold(ArrayRef<Attribute> operands) {
-  assert(operands.empty() && "const has no operands");
+OpFoldResult llhd::ConstantTimeOp::fold(FoldAdaptor adaptor) {
+  assert(adaptor.getOperands().empty() && "const has no operands");
   return getValueAttr();
 }
 
@@ -190,12 +190,12 @@ static OpFoldResult foldSigPtrExtractOp(Op op, ArrayRef<Attribute> operands) {
   return nullptr;
 }
 
-OpFoldResult llhd::SigExtractOp::fold(ArrayRef<Attribute> operands) {
-  return foldSigPtrExtractOp(*this, operands);
+OpFoldResult llhd::SigExtractOp::fold(FoldAdaptor adaptor) {
+  return foldSigPtrExtractOp(*this, adaptor.getOperands());
 }
 
-OpFoldResult llhd::PtrExtractOp::fold(ArrayRef<Attribute> operands) {
-  return foldSigPtrExtractOp(*this, operands);
+OpFoldResult llhd::PtrExtractOp::fold(FoldAdaptor adaptor) {
+  return foldSigPtrExtractOp(*this, adaptor.getOperands());
 }
 
 //===----------------------------------------------------------------------===//
@@ -216,12 +216,12 @@ static OpFoldResult foldSigPtrArraySliceOp(Op op,
   return nullptr;
 }
 
-OpFoldResult llhd::SigArraySliceOp::fold(ArrayRef<Attribute> operands) {
-  return foldSigPtrArraySliceOp(*this, operands);
+OpFoldResult llhd::SigArraySliceOp::fold(FoldAdaptor adaptor) {
+  return foldSigPtrArraySliceOp(*this, adaptor.getOperands());
 }
 
-OpFoldResult llhd::PtrArraySliceOp::fold(ArrayRef<Attribute> operands) {
-  return foldSigPtrArraySliceOp(*this, operands);
+OpFoldResult llhd::PtrArraySliceOp::fold(FoldAdaptor adaptor) {
+  return foldSigPtrArraySliceOp(*this, adaptor.getOperands());
 }
 
 template <class Op>
@@ -306,7 +306,7 @@ LogicalResult llhd::PtrStructExtractOp::inferReturnTypes(
 // DrvOp
 //===----------------------------------------------------------------------===//
 
-LogicalResult llhd::DrvOp::fold(ArrayRef<Attribute> operands,
+LogicalResult llhd::DrvOp::fold(FoldAdaptor adaptor,
                                 SmallVectorImpl<OpFoldResult> &result) {
   if (!getEnable())
     return failure();
diff --git a/lib/Dialect/MSFT/MSFTOps.cpp b/lib/Dialect/MSFT/MSFTOps.cpp
index 19acc77ab..291080784 100644
--- a/lib/Dialect/MSFT/MSFTOps.cpp
+++ b/lib/Dialect/MSFT/MSFTOps.cpp
@@ -44,6 +44,7 @@ static bool hasAttribute(StringRef name, ArrayRef<NamedAttribute> attrs) {
 static void buildModule(OpBuilder &builder, OperationState &result,
                         StringAttr name, const hw::ModulePortInfo &ports) {
   using namespace mlir::function_interface_impl;
+  LocationAttr unknownLoc = builder.getUnknownLoc();
 
   // Add an attribute for the name.
   result.addAttribute(SymbolTable::getSymbolAttrName(), name);
@@ -51,6 +52,7 @@ static void buildModule(OpBuilder &builder, OperationState &result,
   SmallVector<Attribute> argNames, resultNames;
   SmallVector<Type, 4> argTypes, resultTypes;
   SmallVector<Attribute> argAttrs, resultAttrs;
+  SmallVector<Attribute> argLocs, resultLocs;
   auto exportPortIdent = StringAttr::get(builder.getContext(), "hw.exportPort");
 
   for (auto elt : ports.inputs) {
@@ -59,6 +61,7 @@ static void buildModule(OpBuilder &builder, OperationState &result,
       elt.type = hw::InOutType::get(elt.type);
     argTypes.push_back(elt.type);
     argNames.push_back(elt.name);
+    argLocs.push_back(elt.loc ? elt.loc : unknownLoc);
     Attribute attr;
     if (elt.sym && !elt.sym.empty())
       attr = builder.getDictionaryAttr({{exportPortIdent, elt.sym}});
@@ -70,6 +73,7 @@ static void buildModule(OpBuilder &builder, OperationState &result,
   for (auto elt : ports.outputs) {
     resultTypes.push_back(elt.type);
     resultNames.push_back(elt.name);
+    resultLocs.push_back(elt.loc ? elt.loc : unknownLoc);
     Attribute attr;
     if (elt.sym && !elt.sym.empty())
       attr = builder.getDictionaryAttr({{exportPortIdent, elt.sym}});
@@ -84,6 +88,8 @@ static void buildModule(OpBuilder &builder, OperationState &result,
                       TypeAttr::get(type));
   result.addAttribute("argNames", builder.getArrayAttr(argNames));
   result.addAttribute("resultNames", builder.getArrayAttr(resultNames));
+  result.addAttribute("argLocs", builder.getArrayAttr(argLocs));
+  result.addAttribute("resultLocs", builder.getArrayAttr(resultLocs));
   result.addAttribute("parameters", builder.getDictionaryAttr({}));
   result.addAttribute(MSFTModuleOp::getArgAttrsAttrName(result.name),
                       builder.getArrayAttr(argAttrs));
@@ -232,14 +238,8 @@ static ParseResult parseModuleLikeOp(OpAsmParser &parser,
                                      OperationState &result,
                                      bool withParameters = false) {
   using namespace mlir::function_interface_impl;
-
   auto loc = parser.getCurrentLocation();
 
-  SmallVector<OpAsmParser::Argument, 4> entryArgs;
-  SmallVector<DictionaryAttr, 4> resultAttrs;
-  SmallVector<Type, 4> resultTypes;
-  auto &builder = parser.getBuilder();
-
   // Parse the name as a symbol.
   StringAttr nameAttr;
   if (parser.parseSymbolName(nameAttr, SymbolTable::getSymbolAttrName(),
@@ -256,26 +256,22 @@ static ParseResult parseModuleLikeOp(OpAsmParser &parser,
 
   // Parse the function signature.
   bool isVariadic = false;
+  SmallVector<OpAsmParser::Argument, 4> entryArgs;
+  SmallVector<Attribute> argNames;
+  SmallVector<Attribute> argLocs;
   SmallVector<Attribute> resultNames;
+  SmallVector<DictionaryAttr, 4> resultAttrs;
+  SmallVector<Attribute> resultLocs;
+  TypeAttr functionType;
   if (hw::module_like_impl::parseModuleFunctionSignature(
-          parser, entryArgs, isVariadic, resultTypes, resultAttrs, resultNames))
+          parser, isVariadic, entryArgs, argNames, argLocs, resultNames,
+          resultAttrs, resultLocs, functionType))
     return failure();
 
-  // Record the argument and result types as an attribute.  This is necessary
-  // for external modules.
-  SmallVector<Type> argTypes;
-  for (auto arg : entryArgs)
-    argTypes.push_back(arg.type);
-  auto type = builder.getFunctionType(argTypes, resultTypes);
-  result.addAttribute(MSFTModuleOp::getFunctionTypeAttrName(result.name),
-                      TypeAttr::get(type));
-
   // If function attributes are present, parse them.
   if (parser.parseOptionalAttrDictWithKeyword(result.attributes))
     return failure();
 
-  auto *context = result.getContext();
-
   if (hasAttribute("argNames", result.attributes) ||
       hasAttribute("resultNames", result.attributes)) {
     parser.emitError(
@@ -283,21 +279,16 @@ static ParseResult parseModuleLikeOp(OpAsmParser &parser,
     return failure();
   }
 
-  // Use the argument and result names if not already specified.
-  SmallVector<Attribute> argNames;
-  if (!entryArgs.empty()) {
-    for (auto &arg : entryArgs)
-      argNames.push_back(
-          hw::module_like_impl::getPortNameAttr(context, arg.ssaName.name));
-  }
-
+  auto *context = result.getContext();
   result.addAttribute("argNames", ArrayAttr::get(context, argNames));
+  result.addAttribute("argLocs", ArrayAttr::get(context, argLocs));
   result.addAttribute("resultNames", ArrayAttr::get(context, resultNames));
-
-  assert(resultAttrs.size() == resultTypes.size());
+  result.addAttribute("resultLocs", ArrayAttr::get(context, resultLocs));
+  result.addAttribute(MSFTModuleOp::getFunctionTypeAttrName(result.name),
+                      functionType);
 
   // Add the attributes to the module arguments.
-  addArgAndResultAttrs(builder, result, entryArgs, resultAttrs,
+  addArgAndResultAttrs(parser.getBuilder(), result, entryArgs, resultAttrs,
                        MSFTModuleOp::getArgAttrsAttrName(result.name),
                        MSFTModuleOp::getResAttrsAttrName(result.name));
 
@@ -337,7 +328,9 @@ static void printModuleLikeOp(mlir::FunctionOpInterface moduleLike,
   SmallVector<StringRef, 3> omittedAttrs;
   if (!needArgNamesAttr)
     omittedAttrs.push_back("argNames");
+  omittedAttrs.push_back("argLocs");
   omittedAttrs.push_back("resultNames");
+  omittedAttrs.push_back("resultLocs");
   omittedAttrs.push_back("parameters");
   omittedAttrs.push_back(
       ModuleTy::getFunctionTypeAttrName(moduleLike->getName()));
@@ -462,28 +455,34 @@ void InstanceOp::build(OpBuilder &builder, OperationState &state,
 /// Consider adding a `HasModulePorts` op interface to facilitate.
 hw::ModulePortInfo MSFTModuleOp::getPorts() {
   SmallVector<hw::PortInfo> inputs, outputs;
+  auto argNames = this->getArgNames();
   auto argTypes = getArgumentTypes();
+  auto argLocs = getArgLocs();
 
-  auto argNames = this->getArgNames();
   for (unsigned i = 0, e = argTypes.size(); i < e; ++i) {
     bool isInOut = false;
+    auto argName = argNames[i].cast<StringAttr>();
+    auto direction =
+        isInOut ? hw::PortDirection::INOUT : hw::PortDirection::INPUT;
     auto type = argTypes[i];
-
     if (auto inout = type.dyn_cast<hw::InOutType>()) {
       isInOut = true;
       type = inout.getElementType();
     }
-
-    auto direction =
-        isInOut ? hw::PortDirection::INOUT : hw::PortDirection::INPUT;
-    inputs.push_back({argNames[i].cast<StringAttr>(), direction, type, i});
+    auto argLoc = argLocs[i].cast<LocationAttr>();
+    inputs.push_back({argName, direction, type, i, {}, argLoc});
   }
 
   auto resultNames = this->getResultNames();
   auto resultTypes = getResultTypes();
+  auto resultLocs = getResultLocs();
   for (unsigned i = 0, e = resultTypes.size(); i < e; ++i) {
     outputs.push_back({resultNames[i].cast<StringAttr>(),
-                       hw::PortDirection::OUTPUT, resultTypes[i], i});
+                       hw::PortDirection::OUTPUT,
+                       resultTypes[i],
+                       i,
+                       {},
+                       resultLocs[i].cast<LocationAttr>()});
   }
   return hw::ModulePortInfo(inputs, outputs);
 }
@@ -499,28 +498,36 @@ MSFTModuleOp::addPorts(ArrayRef<std::pair<StringAttr, Type>> inputs,
                                      getArgumentTypes().end());
   SmallVector<Attribute> modifiedArgNames(
       getArgNames().getAsRange<Attribute>());
+  SmallVector<Attribute> modifiedArgLocs(getArgLocs().getAsRange<Attribute>());
   SmallVector<BlockArgument> newBlockArgs;
+  Location unknownLoc = UnknownLoc::get(ctxt);
   for (auto ttPair : inputs) {
     modifiedArgNames.push_back(ttPair.first);
     modifiedArgs.push_back(ttPair.second);
+    modifiedArgLocs.push_back(unknownLoc);
     newBlockArgs.push_back(
         body->addArgument(ttPair.second, Builder(ctxt).getUnknownLoc()));
   }
   setArgNamesAttr(ArrayAttr::get(ctxt, modifiedArgNames));
+  setArgLocsAttr(ArrayAttr::get(ctxt, modifiedArgLocs));
 
   // Append new outputs.
   SmallVector<Type, 32> modifiedResults(getResultTypes().begin(),
                                         getResultTypes().end());
   SmallVector<Attribute> modifiedResultNames(
       getResultNames().getAsRange<Attribute>());
+  SmallVector<Attribute> modifiedResultLocs(
+      getResultLocs().getAsRange<Attribute>());
   Operation *terminator = body->getTerminator();
   SmallVector<Value, 32> modifiedOutputs(terminator->getOperands());
   for (auto tvPair : outputs) {
     modifiedResultNames.push_back(tvPair.first);
     modifiedResults.push_back(tvPair.second.getType());
+    modifiedResultLocs.push_back(unknownLoc);
     modifiedOutputs.push_back(tvPair.second);
   }
   setResultNamesAttr(ArrayAttr::get(ctxt, modifiedResultNames));
+  setResultLocsAttr(ArrayAttr::get(ctxt, modifiedResultLocs));
   terminator->setOperands(modifiedOutputs);
 
   // Finalize and return.
@@ -538,31 +545,39 @@ SmallVector<unsigned> MSFTModuleOp::removePorts(llvm::BitVector inputs,
 
   SmallVector<Type, 4> newInputTypes;
   SmallVector<Attribute, 4> newArgNames;
+  SmallVector<Attribute, 4> newArgLocs;
   unsigned originalNumArgs = ftype.getNumInputs();
   ArrayRef<Attribute> origArgNames = getArgNamesAttr().getValue();
+  ArrayRef<Attribute> origArgLocs = getArgLocsAttr().getValue();
   assert(origArgNames.size() == originalNumArgs);
   for (size_t i = 0; i < originalNumArgs; ++i) {
     if (!inputs.test(i)) {
       newInputTypes.emplace_back(ftype.getInput(i));
       newArgNames.emplace_back(origArgNames[i]);
+      newArgLocs.emplace_back(origArgLocs[i]);
     }
   }
 
   SmallVector<Type, 4> newResultTypes;
   SmallVector<Attribute, 4> newResultNames;
+  SmallVector<Attribute, 4> newResultLocs;
   unsigned originalNumResults = getNumResults();
   ArrayRef<Attribute> origResNames = getResultNamesAttr().getValue();
+  ArrayRef<Attribute> origResLocs = getResultLocsAttr().getValue();
   assert(origResNames.size() == originalNumResults);
   for (size_t i = 0; i < originalNumResults; ++i) {
     if (!outputs.test(i)) {
       newResultTypes.emplace_back(ftype.getResult(i));
       newResultNames.emplace_back(origResNames[i]);
+      newResultLocs.emplace_back(origResLocs[i]);
     }
   }
 
   setType(FunctionType::get(ctxt, newInputTypes, newResultTypes));
   setResultNamesAttr(ArrayAttr::get(ctxt, newResultNames));
+  setResultLocsAttr(ArrayAttr::get(ctxt, newResultLocs));
   setArgNamesAttr(ArrayAttr::get(ctxt, newArgNames));
+  setArgLocsAttr(ArrayAttr::get(ctxt, newArgLocs));
 
   // Build new operand list for output op. Construct an output mapping to
   // return as a side-effect.
@@ -612,10 +627,16 @@ void MSFTModuleOp::build(OpBuilder &builder, OperationState &result,
   auto *bodyRegion = result.regions[0].get();
   Block *body = new Block();
   bodyRegion->push_back(body);
+  auto unknownLoc = builder.getUnknownLoc();
 
   // Add arguments to the body block.
-  for (auto elt : ports.inputs)
-    body->addArgument(elt.type, builder.getUnknownLoc());
+  for (auto port : ports.inputs) {
+    auto type = port.type;
+    if (port.isInOut() && !type.isa<hw::InOutType>())
+      type = hw::InOutType::get(type);
+    auto loc = port.loc ? Location(port.loc) : unknownLoc;
+    body->addArgument(type, loc);
+  }
 
   MSFTModuleOp::ensureTerminator(*bodyRegion, builder, result.location);
 }
@@ -628,14 +649,41 @@ void MSFTModuleOp::print(OpAsmPrinter &p) {
   printModuleLikeOp<MSFTModuleOp>(*this, p, getParametersAttr());
 }
 
+LogicalResult MSFTModuleOp::verify() {
+  auto &body = getBody();
+  if (body.empty())
+    return success();
+
+  // Verify the number of block arguments.
+  auto type = getFunctionType();
+  auto numInputs = type.getNumInputs();
+  auto *bodyBlock = &body.front();
+  if (bodyBlock->getNumArguments() != numInputs)
+    return emitOpError("entry block must have")
+           << numInputs << " arguments to match module signature";
+
+  // Verify that the block arguments match the op's attributes.
+  for (auto [arg, type, loc] :
+       llvm::zip(getArguments(), type.getInputs(), getArgLocs())) {
+    if (arg.getType() != type)
+      return emitOpError("block argument types should match signature types");
+    if (arg.getLoc() != loc.cast<LocationAttr>())
+      return emitOpError(
+          "block argument locations should match signature locations");
+  }
+
+  return success();
+}
+
 //===----------------------------------------------------------------------===//
 // MSFTModuleExternOp
 //===----------------------------------------------------------------------===//
 
-/// Check parameter specified by `value` to see if it is valid within the scope
-/// of the specified module `module`.  If not, emit an error at the location of
-/// `usingOp` and return failure, otherwise return success.  If `usingOp` is
-/// null, then no diagnostic is generated. Same format as HW dialect.
+/// Check parameter specified by `value` to see if it is valid within the
+/// scope of the specified module `module`.  If not, emit an error at the
+/// location of `usingOp` and return failure, otherwise return success.  If
+/// `usingOp` is null, then no diagnostic is generated. Same format as HW
+/// dialect.
 ///
 /// If `disallowParamRefs` is true, then parameter references are not allowed.
 static LogicalResult checkParameterInContext(Attribute value, Operation *module,
@@ -656,8 +704,8 @@ static LogicalResult checkParameterInContext(Attribute value, Operation *module,
     return success();
   }
 
-  // Parameter references need more analysis to make sure they are valid within
-  // this module.
+  // Parameter references need more analysis to make sure they are valid
+  // within this module.
   if (auto parameterRef = value.dyn_cast<hw::ParamDeclRefAttr>()) {
     auto nameAttr = parameterRef.getName();
 
@@ -704,43 +752,36 @@ static LogicalResult checkParameterInContext(Attribute value, Operation *module,
 ParseResult MSFTModuleExternOp::parse(OpAsmParser &parser,
                                       OperationState &result) {
   using namespace mlir::function_interface_impl;
-
   auto loc = parser.getCurrentLocation();
 
-  SmallVector<OpAsmParser::Argument, 4> entryArgs;
-  SmallVector<DictionaryAttr, 4> resultAttrs;
-  SmallVector<Type, 4> resultTypes;
-  SmallVector<Attribute> parameters;
-  auto &builder = parser.getBuilder();
-
   // Parse the name as a symbol.
   StringAttr nameAttr;
   if (parser.parseSymbolName(nameAttr, SymbolTable::getSymbolAttrName(),
                              result.attributes))
     return failure();
 
+  // Parse the parameters.
+  SmallVector<Attribute> parameters;
+  if (parseParameterList(parser, parameters))
+    return failure();
+
   // Parse the function signature.
   bool isVariadic = false;
+  SmallVector<OpAsmParser::Argument, 4> entryArgs;
+  SmallVector<Attribute> argNames;
+  SmallVector<Attribute> argLocs;
   SmallVector<Attribute> resultNames;
-  if (parseParameterList(parser, parameters) ||
-      hw::module_like_impl::parseModuleFunctionSignature(
-          parser, entryArgs, isVariadic, resultTypes, resultAttrs,
-          resultNames) ||
-      // If function attributes are present, parse them.
-      parser.parseOptionalAttrDictWithKeyword(result.attributes))
+  SmallVector<DictionaryAttr> resultAttrs;
+  SmallVector<Attribute> resultLocs;
+  TypeAttr functionType;
+  if (failed(hw::module_like_impl::parseModuleFunctionSignature(
+          parser, isVariadic, entryArgs, argNames, argLocs, resultNames,
+          resultAttrs, resultLocs, functionType)))
     return failure();
 
-  // Record the argument and result types as an attribute.  This is necessary
-  // for external modules.
-  SmallVector<Type> argTypes;
-  for (auto arg : entryArgs)
-    argTypes.push_back(arg.type);
-
-  auto type = builder.getFunctionType(argTypes, resultTypes);
-  result.addAttribute(MSFTModuleExternOp::getFunctionTypeAttrName(result.name),
-                      TypeAttr::get(type));
-
-  auto *context = result.getContext();
+  // Parse the attribute dict.
+  if (failed(parser.parseOptionalAttrDictWithKeyword(result.attributes)))
+    return failure();
 
   if (hasAttribute("resultNames", result.attributes) ||
       hasAttribute("parameters", result.attributes)) {
@@ -749,13 +790,7 @@ ParseResult MSFTModuleExternOp::parse(OpAsmParser &parser,
     return failure();
   }
 
-  // Use the argument and result names if not already specified.
-  SmallVector<Attribute> argNames;
-  if (!entryArgs.empty()) {
-    for (auto &arg : entryArgs)
-      argNames.push_back(
-          hw::module_like_impl::getPortNameAttr(context, arg.ssaName.name));
-  }
+  auto *context = result.getContext();
 
   // An explicit `argNames` attribute overrides the MLIR names.  This is how
   // we represent port names that aren't valid MLIR identifiers.  Result and
@@ -763,17 +798,20 @@ ParseResult MSFTModuleExternOp::parse(OpAsmParser &parser,
   // they don't need this affordance.
   if (!hasAttribute("argNames", result.attributes))
     result.addAttribute("argNames", ArrayAttr::get(context, argNames));
+  result.addAttribute("argLocs", ArrayAttr::get(context, argLocs));
   result.addAttribute("resultNames", ArrayAttr::get(context, resultNames));
+  result.addAttribute("resultLocs", ArrayAttr::get(context, resultLocs));
   result.addAttribute("parameters", ArrayAttr::get(context, parameters));
-
-  assert(resultAttrs.size() == resultTypes.size());
+  result.addAttribute(MSFTModuleExternOp::getFunctionTypeAttrName(result.name),
+                      functionType);
 
   // Add the attributes to the function arguments.
-  addArgAndResultAttrs(builder, result, entryArgs, resultAttrs,
+  addArgAndResultAttrs(parser.getBuilder(), result, entryArgs, resultAttrs,
                        MSFTModuleExternOp::getArgAttrsAttrName(result.name),
                        MSFTModuleExternOp::getResAttrsAttrName(result.name));
 
-  // Extern modules carry an empty region to work with HWModuleImplementation.h.
+  // Extern modules carry an empty region to work with
+  // HWModuleImplementation.h.
   result.addRegion();
 
   return success();
@@ -795,13 +833,16 @@ void MSFTModuleExternOp::print(OpAsmPrinter &p) {
   printParameterList(p, *this, (*this)->getAttrOfType<ArrayAttr>("parameters"));
 
   bool needArgNamesAttr = false;
-  hw::module_like_impl::printModuleSignature(
-      p, *this, argTypes, /*isVariadic=*/false, resultTypes, needArgNamesAttr);
+  hw::module_like_impl::printModuleSignature(p, *this, argTypes,
+                                             /*isVariadic=*/false, resultTypes,
+                                             needArgNamesAttr);
 
   SmallVector<StringRef, 3> omittedAttrs;
   if (!needArgNamesAttr)
     omittedAttrs.push_back("argNames");
+  omittedAttrs.push_back("argLocs");
   omittedAttrs.push_back("resultNames");
+  omittedAttrs.push_back("resultLocs");
   omittedAttrs.push_back("parameters");
   omittedAttrs.push_back(getFunctionTypeAttrName());
   omittedAttrs.push_back(getArgAttrsAttrName());
@@ -828,7 +869,8 @@ LogicalResult MSFTModuleExternOp::verify() {
     auto paramAttr = param.cast<hw::ParamDeclAttr>();
 
     // Check that we don't have any redundant parameter names.  These are
-    // resolved by string name: reuse of the same name would cause ambiguities.
+    // resolved by string name: reuse of the same name would cause
+    // ambiguities.
     if (!paramNames.insert(paramAttr.getName()).second)
       return emitOpError("parameter ")
              << paramAttr << " has the same name as a previous parameter";
@@ -870,9 +912,12 @@ hw::ModulePortInfo MSFTModuleExternOp::getPorts() {
   auto resultTypes = moduleType.getResults();
 
   auto argNames = getOperation()->getAttrOfType<ArrayAttr>("argNames");
+  auto argLocs = getOperation()->getAttrOfType<ArrayAttr>("argLocs");
   for (unsigned i = 0, e = argTypes.size(); i < e; ++i) {
     bool isInOut = false;
     auto type = argTypes[i];
+    auto name = argNames[i].cast<StringAttr>();
+    auto loc = argLocs[i].cast<LocationAttr>();
 
     if (auto inout = type.dyn_cast<hw::InOutType>()) {
       isInOut = true;
@@ -882,13 +927,17 @@ hw::ModulePortInfo MSFTModuleExternOp::getPorts() {
     auto direction =
         isInOut ? hw::PortDirection::INOUT : hw::PortDirection::INPUT;
 
-    inputs.push_back({argNames[i].cast<StringAttr>(), direction, type, i});
+    inputs.push_back({name, direction, type, i, {}, loc});
   }
 
   auto resultNames = getOperation()->getAttrOfType<ArrayAttr>("resultNames");
-  for (unsigned i = 0, e = resultTypes.size(); i < e; ++i)
-    outputs.push_back({resultNames[i].cast<StringAttr>(),
-                       hw::PortDirection::OUTPUT, resultTypes[i], i});
+  auto resultLocs = getOperation()->getAttrOfType<ArrayAttr>("resultLocs");
+  for (unsigned i = 0, e = resultTypes.size(); i < e; ++i) {
+    auto name = resultNames[i].cast<StringAttr>();
+    auto loc = resultLocs[i].cast<LocationAttr>();
+    outputs.push_back(
+        {name, hw::PortDirection::OUTPUT, resultTypes[i], i, {}, loc});
+  }
 
   return hw::ModulePortInfo(inputs, outputs);
 }
diff --git a/lib/Dialect/MSFT/Transforms/MSFTPartition.cpp b/lib/Dialect/MSFT/Transforms/MSFTPartition.cpp
index 28e990fad..e750efebc 100644
--- a/lib/Dialect/MSFT/Transforms/MSFTPartition.cpp
+++ b/lib/Dialect/MSFT/Transforms/MSFTPartition.cpp
@@ -699,7 +699,7 @@ MSFTModuleOp PartitionPass::partition(DesignPartitionOp partOp,
                 ctxt, opName + (portName.empty() ? "" : "." + portName)),
             /*direction*/ hw::PortDirection::INPUT,
             /*type*/ v.getType(),
-            /*argNum*/ inputPorts.size()});
+            /*argNum*/ inputPorts.size(), /*sym*/ {}, /*location*/ loc});
       } else {
         // There's already an existing port. Just set it.
         oper.set(partBlock->getArgument(existingF->second));
diff --git a/lib/Dialect/SV/SVOps.cpp b/lib/Dialect/SV/SVOps.cpp
index 092b7fd75..9677462d2 100644
--- a/lib/Dialect/SV/SVOps.cpp
+++ b/lib/Dialect/SV/SVOps.cpp
@@ -1570,7 +1570,7 @@ LogicalResult IndexedPartSelectInOutOp::verify() {
   return success();
 }
 
-OpFoldResult IndexedPartSelectInOutOp::fold(ArrayRef<Attribute> constants) {
+OpFoldResult IndexedPartSelectInOutOp::fold(FoldAdaptor) {
   if (getType() == getInput().getType())
     return getInput();
   return {};
diff --git a/lib/Dialect/SV/Transforms/HWLegalizeModules.cpp b/lib/Dialect/SV/Transforms/HWLegalizeModules.cpp
index 79784d026..025d86625 100644
--- a/lib/Dialect/SV/Transforms/HWLegalizeModules.cpp
+++ b/lib/Dialect/SV/Transforms/HWLegalizeModules.cpp
@@ -56,33 +56,46 @@ private:
 /// This returns a replacement operation if lowering was successful, null
 /// otherwise.
 Operation *HWLegalizeModulesPass::tryLoweringArrayGet(hw::ArrayGetOp getOp) {
-  // If the operand is an array_create, then we can lower this into a casez.
-  auto createOp = getOp.getInput().getDefiningOp<hw::ArrayCreateOp>();
-  if (!createOp)
+  SmallVector<Value> caseValues;
+  OpBuilder builder(&thisHWModule.getBodyBlock()->front());
+  // If the operand is an array_create or aggregate constant, then we can lower
+  // this into a casez.
+  if (auto createOp = getOp.getInput().getDefiningOp<hw::ArrayCreateOp>())
+    caseValues = SmallVector<Value>(llvm::reverse(createOp.getOperands()));
+  else if (auto aggregateConstant =
+               getOp.getInput().getDefiningOp<hw::AggregateConstantOp>()) {
+    for (auto elem : llvm::reverse(aggregateConstant.getFields())) {
+      if (auto intAttr = dyn_cast<IntegerAttr>(elem))
+        caseValues.push_back(builder.create<hw::ConstantOp>(
+            aggregateConstant.getLoc(), intAttr));
+      else
+        caseValues.push_back(builder.create<hw::AggregateConstantOp>(
+            aggregateConstant.getLoc(), getOp.getType(),
+            elem.cast<ArrayAttr>()));
+    }
+  } else {
     return nullptr;
+  }
 
   // array_get(idx, array_create(a,b,c,d)) ==> casez(idx).
   Value index = getOp.getIndex();
 
   // Create the wire for the result of the casez in the hw.module.
-  OpBuilder builder(&thisHWModule.getBodyBlock()->front());
-
   auto theWire = builder.create<sv::RegOp>(getOp.getLoc(), getOp.getType(),
                                            builder.getStringAttr("casez_tmp"));
   builder.setInsertionPoint(getOp);
 
+  auto loc = getOp.getInput().getDefiningOp()->getLoc();
   // A casez is a procedural operation, so if we're in a non-procedural region
   // we need to inject an always_comb block.
   if (!getOp->getParentOp()->hasTrait<sv::ProceduralRegion>()) {
-    auto alwaysComb = builder.create<sv::AlwaysCombOp>(createOp.getLoc());
+    auto alwaysComb = builder.create<sv::AlwaysCombOp>(loc);
     builder.setInsertionPointToEnd(alwaysComb.getBodyBlock());
   }
 
   // If we are missing elements in the array (it is non-power of two), then
   // add a default 'X' value.
-  SmallVector<Value> caseValues(llvm::reverse(createOp.getOperands()));
-  if (1ULL << index.getType().getIntOrFloatBitWidth() !=
-      createOp.getNumOperands()) {
+  if (1ULL << index.getType().getIntOrFloatBitWidth() != caseValues.size()) {
     caseValues.push_back(
         builder.create<sv::ConstantXOp>(getOp.getLoc(), getOp.getType()));
   }
@@ -92,7 +105,7 @@ Operation *HWLegalizeModulesPass::tryLoweringArrayGet(hw::ArrayGetOp getOp) {
 
   // Create the casez itself.
   builder.create<sv::CaseOp>(
-      createOp.getLoc(), CaseStmtType::CaseZStmt, index, caseValues.size(),
+      loc, CaseStmtType::CaseZStmt, index, caseValues.size(),
       [&](size_t caseIdx) -> std::unique_ptr<sv::CasePattern> {
         // Use a default pattern for the last value, even if we are complete.
         // This avoids tools thinking they need to insert a latch due to
@@ -106,7 +119,7 @@ Operation *HWLegalizeModulesPass::tryLoweringArrayGet(hw::ArrayGetOp getOp) {
         else
           thePattern = std::make_unique<sv::CaseBitPattern>(caseValue, context);
         ++caseValue;
-        builder.create<sv::BPAssignOp>(createOp.getLoc(), theWire, theValue);
+        builder.create<sv::BPAssignOp>(loc, theWire, theValue);
         return thePattern;
       });
 
@@ -149,9 +162,10 @@ void HWLegalizeModulesPass::processPostOrder(Block &body) {
           continue;
         }
 
-      // If this is a dead array_create, then we can just delete it.  This is
+      // If this is a dead array, then we can just delete it.  This is
       // probably left over from get/create lowering.
-      if (isa<hw::ArrayCreateOp>(op) && op.use_empty()) {
+      if (isa<hw::ArrayCreateOp, hw::AggregateConstantOp>(op) &&
+          op.use_empty()) {
         op.erase();
         continue;
       }
@@ -163,6 +177,7 @@ void HWLegalizeModulesPass::processPostOrder(Block &body) {
       for (auto value : op.getResults()) {
         if (value.getType().isa<hw::ArrayType>()) {
           op.emitError("unsupported packed array expression");
+          signalPassFailure();
         }
       }
     }
diff --git a/lib/Dialect/SV/Transforms/HWMemSimImpl.cpp b/lib/Dialect/SV/Transforms/HWMemSimImpl.cpp
index 30e7040a7..b613e2f1d 100644
--- a/lib/Dialect/SV/Transforms/HWMemSimImpl.cpp
+++ b/lib/Dialect/SV/Transforms/HWMemSimImpl.cpp
@@ -15,10 +15,12 @@
 #include "circt/Dialect/Comb/CombOps.h"
 #include "circt/Dialect/HW/HWAttributes.h"
 #include "circt/Dialect/HW/HWOps.h"
+#include "circt/Dialect/HW/HWSymCache.h"
 #include "circt/Dialect/HW/Namespace.h"
 #include "circt/Dialect/SV/SVPasses.h"
 #include "mlir/IR/ImplicitLocOpBuilder.h"
 #include "llvm/ADT/TypeSwitch.h"
+#include "llvm/Support/Path.h"
 
 using namespace circt;
 using namespace hw;
@@ -40,6 +42,9 @@ struct FirMemory {
   size_t readUnderWrite;
   WUW writeUnderWrite;
   SmallVector<int32_t> writeClockIDs;
+  StringRef initFilename;
+  bool initIsBinary;
+  bool initIsInline;
 };
 } // end anonymous namespace
 
@@ -60,14 +65,18 @@ class HWMemSimImpl {
   sv::AlwaysOp lastPipelineAlwaysOp;
 
 public:
+  Namespace &mlirModuleNamespace;
+
   HWMemSimImpl(bool ignoreReadEnableMem, bool addMuxPragmas,
                bool disableMemRandomization, bool disableRegRandomization,
-               bool addVivadoRAMAddressConflictSynthesisBugWorkaround)
+               bool addVivadoRAMAddressConflictSynthesisBugWorkaround,
+               Namespace &mlirModuleNamespace)
       : ignoreReadEnableMem(ignoreReadEnableMem), addMuxPragmas(addMuxPragmas),
         disableMemRandomization(disableMemRandomization),
         disableRegRandomization(disableRegRandomization),
         addVivadoRAMAddressConflictSynthesisBugWorkaround(
-            addVivadoRAMAddressConflictSynthesisBugWorkaround) {}
+            addVivadoRAMAddressConflictSynthesisBugWorkaround),
+        mlirModuleNamespace(mlirModuleNamespace) {}
 
   void generateMemory(HWModuleOp op, FirMemory mem);
 };
@@ -108,6 +117,9 @@ static FirMemory analyzeMemOp(HWModuleGeneratedOp op) {
     for (auto clockID : clockIDsAttr)
       mem.writeClockIDs.push_back(
           clockID.cast<IntegerAttr>().getValue().getZExtValue());
+  mem.initFilename = op->getAttrOfType<StringAttr>("initFilename").getValue();
+  mem.initIsBinary = op->getAttrOfType<BoolAttr>("initIsBinary").getValue();
+  mem.initIsInline = op->getAttrOfType<BoolAttr>("initIsInline").getValue();
   return mem;
 }
 
@@ -441,6 +453,74 @@ void HWMemSimImpl::generateMemory(HWModuleOp op, FirMemory mem) {
   auto *outputOp = op.getBodyBlock()->getTerminator();
   outputOp->setOperands(outputs);
 
+  // Add logic to initialize the memory based on a file emission request.  This
+  // disables randomization.
+  if (!mem.initFilename.empty()) {
+    // Set an inner symbol on the register if one does not exist.
+    if (!reg.getInnerSymAttr())
+      reg.setInnerSymAttr(
+          b.getStringAttr(moduleNamespace.newName(reg.getName())));
+
+    if (mem.initIsInline) {
+      b.create<sv::IfDefOp>("SYNTHESIS", std::function<void()>(), [&]() {
+        b.create<sv::InitialOp>([&]() {
+          b.create<sv::ReadMemOp>(reg, mem.initFilename,
+                                  mem.initIsBinary
+                                      ? MemBaseTypeAttr::MemBaseBin
+                                      : MemBaseTypeAttr::MemBaseHex);
+        });
+      });
+    } else {
+      OpBuilder::InsertionGuard guard(b);
+
+      // Create a new module with the readmem op.
+      b.setInsertionPointAfter(op);
+      auto boundModule = b.create<HWModuleOp>(
+          b.getStringAttr(mlirModuleNamespace.newName(op.getName() + "_init")),
+          ArrayRef<PortInfo>());
+
+      auto filename = op->getAttrOfType<OutputFileAttr>("output_file");
+      if (filename) {
+        if (!filename.isDirectory()) {
+          SmallString<128> dir(filename.getFilename().getValue());
+          llvm::sys::path::remove_filename(dir);
+          filename = hw::OutputFileAttr::getFromDirectoryAndFilename(
+              b.getContext(), dir, boundModule.getName() + ".sv");
+        }
+      } else {
+        filename = hw::OutputFileAttr::getFromFilename(
+            b.getContext(), boundModule.getName() + ".sv");
+      }
+
+      boundModule->setAttr("output_file", filename);
+      b.setInsertionPointToStart(op.getBodyBlock());
+      b.setInsertionPointToStart(boundModule.getBodyBlock());
+      b.create<sv::InitialOp>([&]() {
+        auto xmr = b.create<sv::XMRRefOp>(
+            reg.getType(),
+            hw::InnerRefAttr::get(op.getNameAttr(), reg.getInnerSymAttr()));
+        b.create<sv::ReadMemOp>(xmr, mem.initFilename,
+                                mem.initIsBinary ? MemBaseTypeAttr::MemBaseBin
+                                                 : MemBaseTypeAttr::MemBaseHex);
+      });
+
+      // Instantiate this new module inside the memory module.
+      b.setInsertionPointAfter(reg);
+      auto boundInstance = b.create<hw::InstanceOp>(
+          boundModule, boundModule.getName(), ArrayRef<Value>());
+      boundInstance->setAttr("inner_sym",
+                             b.getStringAttr(moduleNamespace.newName(
+                                 boundInstance.getName().getValue())));
+      boundInstance->setAttr("doNotPrint", b.getBoolAttr(true));
+
+      // Bind the new module.
+      b.setInsertionPointAfter(boundModule);
+      auto bind = b.create<sv::BindOp>(hw::InnerRefAttr::get(
+          op.getNameAttr(), boundInstance.getInnerSymAttr()));
+      bind->setAttr("output_file", filename);
+    }
+  }
+
   // Add logic to initialize the memory and any internal registers to random
   // values.
   if (disableMemRandomization && disableRegRandomization)
@@ -453,7 +533,7 @@ void HWMemSimImpl::generateMemory(HWModuleOp op, FirMemory mem) {
     StringRef initvar;
 
     // Declare variables for use by memory randomization logic.
-    if (!disableMemRandomization) {
+    if (!disableMemRandomization || !mem.initFilename.empty()) {
       b.create<sv::IfDefOp>("RANDOMIZE_MEM_INIT", [&]() {
         initvar = moduleNamespace.newName("initvar");
         b.create<sv::VerbatimOp>("integer " + Twine(initvar) + ";\n");
@@ -588,13 +668,21 @@ void HWMemSimImpl::generateMemory(HWModuleOp op, FirMemory mem) {
 }
 
 void HWMemSimImplPass::runOnOperation() {
-  auto topModule = getOperation().getBody();
+  auto topModule = getOperation();
+
+  // Populate a namespace from the symbols visible to the top-level MLIR module.
+  // Memories with initializations create modules and these need to be legal
+  // symbols.
+  SymbolCache symbolCache;
+  symbolCache.addDefinitions(topModule);
+  Namespace mlirModuleNamespace;
+  mlirModuleNamespace.add(symbolCache);
 
   SmallVector<HWModuleGeneratedOp> toErase;
   bool anythingChanged = false;
 
   for (auto op :
-       llvm::make_early_inc_range(topModule->getOps<HWModuleGeneratedOp>())) {
+       llvm::make_early_inc_range(topModule.getOps<HWModuleGeneratedOp>())) {
     auto oldModule = cast<HWModuleGeneratedOp>(op);
     auto gen = oldModule.getGeneratorKind();
     auto genOp = cast<HWGeneratorSchemaOp>(
@@ -626,7 +714,8 @@ void HWMemSimImplPass::runOnOperation() {
 
         HWMemSimImpl(ignoreReadEnableMem, addMuxPragmas,
                      disableMemRandomization, disableRegRandomization,
-                     addVivadoRAMAddressConflictSynthesisBugWorkaround)
+                     addVivadoRAMAddressConflictSynthesisBugWorkaround,
+                     mlirModuleNamespace)
             .generateMemory(newModule, mem);
       }
 
diff --git a/lib/Dialect/SV/Transforms/PrettifyVerilog.cpp b/lib/Dialect/SV/Transforms/PrettifyVerilog.cpp
index 53b9f55b0..e6a73c664 100644
--- a/lib/Dialect/SV/Transforms/PrettifyVerilog.cpp
+++ b/lib/Dialect/SV/Transforms/PrettifyVerilog.cpp
@@ -22,6 +22,7 @@
 #include "circt/Dialect/Comb/CombOps.h"
 #include "circt/Dialect/HW/HWOps.h"
 #include "circt/Dialect/SV/SVPasses.h"
+#include "circt/Support/LoweringOptions.h"
 #include "mlir/IR/ImplicitLocOpBuilder.h"
 #include "mlir/IR/Matchers.h"
 #include "llvm/ADT/TypeSwitch.h"
@@ -51,6 +52,7 @@ private:
   bool splitAssignment(OpBuilder &builder, Value dst, Value src);
 
   bool anythingChanged;
+  LoweringOptions options;
 
   DenseSet<Operation *> toDelete;
 };
@@ -337,6 +339,9 @@ bool PrettifyVerilogPass::prettifyUnaryOperator(Operation *op) {
   for (auto *user : op->getUsers()) {
     if (isa<comb::ExtractOp, hw::ArraySliceOp>(user))
       return false;
+    if (!options.allowExprInEventControl &&
+        isa<sv::AlwaysFFOp, sv::AlwaysOp>(user))
+      return false;
   }
 
   // Duplicating unary operations can move them across blocks (down the region
@@ -531,6 +536,7 @@ void PrettifyVerilogPass::processPostOrder(Block &body) {
 
 void PrettifyVerilogPass::runOnOperation() {
   hw::HWModuleOp thisModule = getOperation();
+  options = LoweringOptions(thisModule->getParentOfType<mlir::ModuleOp>());
 
   // Keeps track if anything changed during this pass, used to determine if
   // the analyses were preserved.
diff --git a/lib/Dialect/Seq/SeqOps.cpp b/lib/Dialect/Seq/SeqOps.cpp
index b3dcecd19..77365cb00 100644
--- a/lib/Dialect/Seq/SeqOps.cpp
+++ b/lib/Dialect/Seq/SeqOps.cpp
@@ -559,7 +559,7 @@ LogicalResult FirRegOp::canonicalize(FirRegOp op, PatternRewriter &rewriter) {
   return failure();
 }
 
-OpFoldResult FirRegOp::fold(ArrayRef<Attribute> constants) {
+OpFoldResult FirRegOp::fold(FoldAdaptor adaptor) {
   // If the register has a symbol, we can't optimize it away.
   if (getInnerSymAttr())
     return {};
@@ -580,7 +580,8 @@ OpFoldResult FirRegOp::fold(ArrayRef<Attribute> constants) {
   // register is never clocked, we can replace the register with a constant
   // value.
   bool isTrivialFeedback = (getNext() == getResult());
-  bool isNeverClocked = !!constants[1]; // clock operand is constant
+  bool isNeverClocked =
+      adaptor.getClk() != nullptr; // clock operand is constant
   if (!isTrivialFeedback && !isNeverClocked)
     return {};
 
diff --git a/lib/Dialect/SystemC/SystemCOps.cpp b/lib/Dialect/SystemC/SystemCOps.cpp
index c0abccabb..572728e14 100644
--- a/lib/Dialect/SystemC/SystemCOps.cpp
+++ b/lib/Dialect/SystemC/SystemCOps.cpp
@@ -137,48 +137,47 @@ StringRef SCModuleOp::getModuleName() {
 }
 
 ParseResult SCModuleOp::parse(OpAsmParser &parser, OperationState &result) {
-  StringAttr moduleName;
-  SmallVector<OpAsmParser::Argument, 4> args;
-  SmallVector<Type, 4> argTypes;
-  SmallVector<Type, 4> resultTypes;
-  SmallVector<Attribute> argNames;
-  SmallVector<DictionaryAttr> resultAttrs;
 
   // Parse the visibility attribute.
   (void)mlir::impl::parseOptionalVisibilityKeyword(parser, result.attributes);
 
+  // Parse the name as a symbol.
+  StringAttr moduleName;
   if (parser.parseSymbolName(moduleName, SymbolTable::getSymbolAttrName(),
                              result.attributes))
     return failure();
 
+  // Parse the function signature.
   bool isVariadic = false;
-  if (hw::module_like_impl::parseModuleFunctionSignature(
-          parser, args, isVariadic, resultTypes, resultAttrs, argNames))
+  SmallVector<OpAsmParser::Argument, 4> entryArgs;
+  SmallVector<Attribute> argNames;
+  SmallVector<Attribute> argLocs;
+  SmallVector<Attribute> resultNames;
+  SmallVector<DictionaryAttr> resultAttrs;
+  SmallVector<Attribute> resultLocs;
+  TypeAttr functionType;
+  if (failed(hw::module_like_impl::parseModuleFunctionSignature(
+          parser, isVariadic, entryArgs, argNames, argLocs, resultNames,
+          resultAttrs, resultLocs, functionType)))
     return failure();
 
+  // Parse the attribute dict.
   if (parser.parseOptionalAttrDictWithKeyword(result.attributes))
     return failure();
 
-  for (auto &arg : args) {
-    argNames.push_back(
-        StringAttr::get(parser.getContext(), arg.ssaName.name.drop_front()));
-    argTypes.push_back(arg.type);
-  }
-
   result.addAttribute("portNames",
                       ArrayAttr::get(parser.getContext(), argNames));
 
-  auto type = parser.getBuilder().getFunctionType(argTypes, resultTypes);
   result.addAttribute(SCModuleOp::getFunctionTypeAttrName(result.name),
-                      TypeAttr::get(type));
+                      functionType);
 
   mlir::function_interface_impl::addArgAndResultAttrs(
-      parser.getBuilder(), result, args, resultAttrs,
+      parser.getBuilder(), result, entryArgs, resultAttrs,
       SCModuleOp::getArgAttrsAttrName(result.name),
       SCModuleOp::getResAttrsAttrName(result.name));
 
   auto &body = *result.addRegion();
-  if (parser.parseRegion(body, args))
+  if (parser.parseRegion(body, entryArgs))
     return failure();
   if (body.empty())
     body.push_back(std::make_unique<Block>().release());
@@ -348,7 +347,7 @@ void SignalOp::getAsmResultNames(OpAsmSetValueNameFn setNameFn) {
 // ConvertOp
 //===----------------------------------------------------------------------===//
 
-OpFoldResult ConvertOp::fold(ArrayRef<Attribute> operands) {
+OpFoldResult ConvertOp::fold(FoldAdaptor) {
   if (getInput().getType() == getResult().getType())
     return getInput();
 
diff --git a/lib/Transforms/StripDebugInfoWithPred.cpp b/lib/Transforms/StripDebugInfoWithPred.cpp
index 810544c71..db5b6fc15 100644
--- a/lib/Transforms/StripDebugInfoWithPred.cpp
+++ b/lib/Transforms/StripDebugInfoWithPred.cpp
@@ -47,6 +47,20 @@ struct StripDebugInfoWithPred
     return loc;
   }
 
+  void updateLocArray(Operation *op, StringRef attributeName) {
+    SmallVector<Attribute> newLocs;
+    if (auto resLocs = op->getAttrOfType<ArrayAttr>(attributeName)) {
+      bool changed = false;
+      for (auto loc : resLocs.getAsRange<LocationAttr>()) {
+        auto newLoc = getStrippedLoc(loc);
+        changed |= newLoc != loc;
+        newLocs.push_back(newLoc);
+      }
+      if (changed)
+        op->setAttr(attributeName, ArrayAttr::get(&getContext(), newLocs));
+    }
+  }
+
 private:
   std::function<bool(mlir::Location)> pred;
 };
@@ -73,7 +87,8 @@ void StripDebugInfoWithPred::runOnOperation() {
       &getContext(), getOperation().getOps(), [&](Operation &toplevelOp) {
         toplevelOp.walk([&](Operation *op) {
           updateLocIfChanged(op, getStrippedLoc(op->getLoc()));
-
+          updateLocArray(op, "argLocs");
+          updateLocArray(op, "resultLocs");
           // Strip block arguments debug info.
           for (Region &region : op->getRegions())
             for (Block &block : region.getBlocks())
diff --git a/test/Conversion/AffineToPipeline/loops.mlir b/test/Conversion/AffineToPipeline/loops.mlir
index c002597f8..88610d40a 100644
--- a/test/Conversion/AffineToPipeline/loops.mlir
+++ b/test/Conversion/AffineToPipeline/loops.mlir
@@ -98,3 +98,83 @@ func.func @affine_dimension(%arg0: i32) -> i32 {
   }
   return %1 : i32
 }
+
+// CHECK-LABEL: func @dot_mul_accumulate
+func.func @dot_mul_accumulate(%arg0: memref<64xi32>, %arg1: memref<64xi32>) -> i32 {
+  // Pipeline boilerplate checked above, just check the stages computations.
+
+  // CHECK: pipeline.while II = 3
+  // First stage.
+  // CHECK: %[[STAGE0:.+]]:3 = pipeline.while.stage
+  // CHECK-DAG: %[[STAGE0_0:.+]] = memref.load %arg0[%arg2]
+  // CHECK-DAG: %[[STAGE0_1:.+]] = memref.load %arg1[%arg2]
+  // CHECK-DAG: %[[STAGE0_2:.+]] = arith.addi %arg2, %c1
+  // CHECK: pipeline.register %[[STAGE0_0]], %[[STAGE0_1]], %[[STAGE0_2]]
+
+  // Second stage.
+  // CHECK: %[[STAGE1:.+]] = pipeline.while.stage
+  // CHECK: %[[STAGE1_0:.+]] = arith.muli %[[STAGE0]]#0, %[[STAGE0]]#1 : i32
+  // CHECK: pipeline.register %[[STAGE1_0]]
+
+  // Third stage.
+  // CHECK: %[[STAGE2:.+]] = pipeline.while.stage
+  // CHECK: %[[STAGE2_0:.+]] = arith.muli %arg3, %[[STAGE1]]
+  // CHECK: pipeline.register %[[STAGE2_0]]
+
+  // Pipeline terminator.
+  // CHECK: pipeline.terminator iter_args(%[[STAGE0]]#2, %[[STAGE2]]), results(%[[STAGE2]])
+
+  %c0_i32 = arith.constant 0 : i32
+  %0 = affine.for %arg2 = 0 to 64 iter_args(%arg3 = %c0_i32) -> (i32) {
+    %1 = affine.load %arg0[%arg2] : memref<64xi32>
+    %2 = affine.load %arg1[%arg2] : memref<64xi32>
+    %3 = arith.muli %1, %2 : i32
+    %4 = arith.muli %arg3, %3 : i32
+    affine.yield %4 : i32
+  }
+
+  return %0 : i32
+}
+
+// CHECK-LABEL: func @dot_shared_mem
+func.func @dot_shared_mem(%arg0: memref<128xi32>) -> i32 {
+  // Pipeline boilerplate checked above, just check the stages computations.
+
+  // CHECK: pipeline.while II = 2
+  // First stage.
+  // CHECK: %[[STAGE0:.+]]:3 = pipeline.while.stage
+  // CHECK-DAG: %[[STAGE0_0:.+]] = memref.load %arg0[%arg1] : memref<128xi32>
+  // CHECK-DAG: %[[STAGE0_1:.+]] = arith.addi %arg1, %c64 : index
+  // CHECK-DAG: %[[STAGE0_2:.+]] = arith.addi %arg1, %c1 : index
+  // CHECK: pipeline.register %[[STAGE0_0]], %[[STAGE0_1]], %[[STAGE0_2]]
+
+  // Second stage.
+  // CHECK: %[[STAGE1:.+]]:2 = pipeline.while.stage
+  // CHECK: %[[STAGE1_0:.+]] = memref.load %arg0[%[[STAGE0]]#1] : memref<128xi32>
+  // CHECK: pipeline.register %[[STAGE0]]#0, %[[STAGE1_0]]
+
+  // Third stage.
+  // CHECK: %[[STAGE2:.+]] = pipeline.while.stage
+  // CHECK: %[[STAGE2_0:.+]] = arith.muli %[[STAGE1]]#0, %[[STAGE1]]#1 : i32
+  // CHECK: pipeline.register %[[STAGE2_0]]
+
+  // Fourth stage.
+  // CHECK: %[[STAGE3:.+]] = pipeline.while.stage
+  // CHECK: %[[STAGE3_0:.+]] = arith.addi %arg2, %[[STAGE2]] : i32
+  // CHECK: pipeline.register %[[STAGE3_0]]
+
+  // Pipeline terminator.
+  // CHECK: pipeline.terminator iter_args(%[[STAGE0]]#2, %[[STAGE3]]), results(%[[STAGE3]])
+
+  %c0_i32 = arith.constant 0 : i32
+  %c64_index = arith.constant 64 : index
+  %0 = affine.for %arg2 = 0 to 64 iter_args(%arg3 = %c0_i32) -> (i32) {
+    %1 = affine.load %arg0[%arg2] : memref<128xi32>
+    %2 = affine.load %arg0[%arg2 + %c64_index] : memref<128xi32>
+    %3 = arith.muli %1, %2 : i32
+    %4 = arith.addi %arg3, %3 : i32
+    affine.yield %4 : i32
+  }
+
+  return %0 : i32
+}
diff --git a/test/Conversion/ExportVerilog/hw-dialect.mlir b/test/Conversion/ExportVerilog/hw-dialect.mlir
index c89bbb0d9..e61bbc830 100644
--- a/test/Conversion/ExportVerilog/hw-dialect.mlir
+++ b/test/Conversion/ExportVerilog/hw-dialect.mlir
@@ -156,7 +156,8 @@ hw.module @TESTSIMPLE(%a: i4, %b: i4, %c: i2, %cond: i1,
 // CHECK-NEXT:      output struct packed {logic [1:0] foo; logic [3:0] bar; } r44,
 // CHECK-NEXT:                                                                r45,
 // CHECK-NEXT:                                                                r46,
-// CHECK-NEXT:      output                                                    r47);
+// CHECK-NEXT:      output                                                    r47
+// CHECK-NEXT: );
 // CHECK{LITERAL}:  wire [8:0][3:0] name_hint = {9{4'hF}};
 // CHECK-NEXT:      wire [2:0][3:0] [[WIRE0:.+]] = {{[{}][{}]}}4'hF}, {a + b}, {4'hF}};
 // CHECK-NEXT:      wire struct packed {logic [1:0] foo; logic [3:0] bar; } [[WIRE1:.+]] = '{foo: c, bar: a};
@@ -228,9 +229,10 @@ hw.module @B(%a: i1) -> (b: i1, c: i1) {
   hw.output %0, %1 : i1, i1
 }
 // CHECK-LABEL: module B(
-// CHECK-NEXT:   input  a,
-// CHECK-NEXT:   output b,
-// CHECK-NEXT:          c);
+// CHECK-NEXT:   input  a, //
+// CHECK-NEXT:   output b, //
+// CHECK-NEXT:          c //
+// CHECK-NEXT:  );
 // CHECK-EMPTY:
 // CHECK-NEXT:   assign b = a | a;
 // CHECK-NEXT:   assign c = a & a;
@@ -243,7 +245,8 @@ hw.module @A(%d: i1, %e: i1) -> (f: i1) {
 // CHECK-LABEL: module A(
 // CHECK-NEXT:  input  d,
 // CHECK-NEXT:         e,
-// CHECK-NEXT:  output f);
+// CHECK-NEXT:  output f
+// CHECK-NEXT:  );
 // CHECK-EMPTY:
 // CHECK-NEXT:  assign f = d ? d : e;
 // CHECK-NEXT: endmodule
@@ -255,7 +258,8 @@ hw.module @AAA(%d: i1, %e: i1) -> (f: i1) {
 // CHECK-LABEL: module AAA(
 // CHECK-NEXT:  input  d,
 // CHECK-NEXT:         e,
-// CHECK-NEXT:  output f);
+// CHECK-NEXT:  output f
+// CHECK-NEXT:  );
 // CHECK-EMPTY:
 // CHECK-NEXT:  assign f = 1'h0;
 // CHECK-NEXT: endmodule
@@ -290,7 +294,8 @@ hw.module @AB(%w: i1, %x: i1, %i2: i2, %i3: i0) -> (y: i1, z: i1, p: i1, p2: i1)
 // CHECK-NEXT:      output                y,
 // CHECK-NEXT:                            z,
 // CHECK-NEXT:                            p,
-// CHECK-NEXT:                            p2);
+// CHECK-NEXT:                            p2
+// CHECK-NEXT:   );
 // CHECK-EMPTY:
 // CHECK-NEXT:   wire _b1_b;
 // CHECK-NEXT:   wire _a1_f;
@@ -331,7 +336,8 @@ hw.module @shl(%a: i1) -> (b: i1) {
 }
 // CHECK-LABEL:  module shl(
 // CHECK-NEXT:   input  a,
-// CHECK-NEXT:   output b);
+// CHECK-NEXT:   output b
+// CHECK-NEXT:   );
 // CHECK-EMPTY:
 // CHECK-NEXT:   assign b = a << a;
 // CHECK-NEXT: endmodule
@@ -343,7 +349,8 @@ hw.module @inout_0(%a: !hw.inout<i42>) -> (out: i42) {
 }
 // CHECK-LABEL:  module inout_0(
 // CHECK-NEXT:     inout  [41:0] a,
-// CHECK-NEXT:     output [41:0] out);
+// CHECK-NEXT:     output [41:0] out
+// CHECK-NEXT:   );
 // CHECK-EMPTY:
 // CHECK-NEXT:     assign out = a;
 // CHECK-NEXT:   endmodule
@@ -365,12 +372,13 @@ hw.module @extract_all(%tmp85: i1) -> (tmp106: i1) {
 // CHECK:  assign tmp106 = tmp85;
 
 hw.module @wires(%in4: i4, %in8: i8) -> (a: i4, b: i8, c: i8) {
-  // CHECK-LABEL: module wires(
-  // CHECK-NEXT:   input  [3:0] in4,
-  // CHECK-NEXT:   input  [7:0] in8,
-  // CHECK-NEXT:   output [3:0] a,
-  // CHECK-NEXT:   output [7:0] b,
-  // CHECK-NEXT:                c);
+  // CHECK-LABEL: module wires( //
+  // CHECK-NEXT:   input  [3:0] in4, //
+  // CHECK-NEXT:   input  [7:0] in8, //
+  // CHECK-NEXT:   output [3:0] a, //
+  // CHECK-NEXT:   output [7:0] b, //
+  // CHECK-NEXT:                c //
+  // CHECK-NEXT:  );
 
   // CHECK-EMPTY:
 
@@ -457,7 +465,8 @@ hw.module @signs(%in1: i4, %in2: i4, %in3: i4, %in4: i4)  {
 // CHECK-NEXT: input  [6:0]      in1,
 // CHECK-NEXT: input  [7:0][3:0] in2,
 // CHECK-NEXT: output [6:0]      r1,
-// CHECK-NEXT: output [31:0]     r2);
+// CHECK-NEXT: output [31:0]     r2
+// CHECK-NEXT: );
 hw.module @casts(%in1: i7, %in2: !hw.array<8xi4>) -> (r1: !hw.array<7xi1>, r2: i32) {
   // CHECK-EMPTY:
   %r1 = hw.bitcast %in1 : (i7) -> !hw.array<7xi1>
@@ -475,7 +484,7 @@ hw.module @casts(%in1: i7, %in2: !hw.array<8xi4>) -> (r1: !hw.array<7xi1>, r2: i
 // CHECK-NEXT:      output [3:0]               r0
 // CHECK-NEXT:   // output /*Zero Width*/      rZero
 // CHECK-NEXT:   // output [2:0]/*Zero Width*/ arrZero_0
-// CHECK-NEXT:    );
+// CHECK-NEXT:   );
 // CHECK-EMPTY:
 hw.module @TestZero(%a: i4, %zeroBit: i0, %arrZero: !hw.array<3xi0>)
   -> (r0: i4, rZero: i0, arrZero_0: !hw.array<3xi0>) {
@@ -526,7 +535,8 @@ hw.module @TestZeroStruct(%structZero: !hw.struct<>, %structZeroNest: !hw.struct
 // CHECK-LABEL: module zeroElements
 // CHECK-NEXT:   // input  /*Zero Width*/                                                                                              in0,
 // CHECK-NEXT:      input  [31:0]                                                                                                      in1,
-// CHECK-NEXT:      output struct packed {/*z1: Zero Width;*/ logic [31:0] a; /*z2: Zero Width;*/ logic [31:0] b; /*c: Zero Width;*/ struct packed {logic [31:0] d1; /*z: Zero Width;*/ } d; } out0)
+// CHECK-NEXT:      output struct packed {/*z1: Zero Width;*/ logic [31:0] a; /*z2: Zero Width;*/ logic [31:0] b; /*c: Zero Width;*/ struct packed {logic [31:0] d1; /*z: Zero Width;*/ } d; } out0
+// CHECK-NEXT:  );
 hw.module @zeroElements(%in0: i0, %in1: i32) -> (out0: !hw.struct<z1: i0, a: i32, z2: i0, b: i32, c: !hw.struct<z: i0>, d: !hw.struct<d1:i32, z:i0>>) {
   // CHECK:      // Zero width: wire /*Zero Width*/
   // CHECK-SAME: _GEN = '{};
@@ -566,6 +576,7 @@ hw.module @TestZeroStructInstance(%structZero: !hw.struct<>, %structZeroNest: !h
 // CHECK-NEXT:      output [31:0]         out,
 // CHECK-NEXT:                            out1
 // CHECK-NEXT:   // output /*Zero Width*/ out2
+// CHECK-NEXT:  );
 
 // CHECK:   assign out = arg1[/*Zero width*/ 1'b0];	
 // CHECK-NEXT:   assign out1 = arg1[/*Zero width*/ 1'b0];	
@@ -649,7 +660,8 @@ hw.module @longvariadic(%a: i8) -> (b: i8) {
 // CHECK-NEXT:              c,
 // CHECK-NEXT: input  [3:0] d,
 // CHECK-NEXT:              e,
-// CHECK-NEXT: output       r);
+// CHECK-NEXT: output       r
+// CHECK-NEXT: );
 // CHECK-EMPTY:
 // CHECK-NEXT: assign r = a == c == (d == e);
   hw.module @eqIssue(%a: i9, %c :i9, %d: i4, %e: i4) -> (r : i1){
@@ -662,7 +674,8 @@ hw.module @longvariadic(%a: i8) -> (b: i8) {
 // https://github.com/llvm/circt/issues/750
 // Always get array indexes on the lhs
 // CHECK-LABEL: module ArrayLHS
-// CHECK-NEXT:    input clock);
+// CHECK-NEXT:    input clock
+// CHECK-NEXT:  );
 // CHECK-EMPTY:
 // CHECK-NEXT:   reg memory_r_en_pipe[0:0];
 // CHECK:        always_ff @(posedge clock)
@@ -1015,7 +1028,8 @@ hw.module @structExplodeLowering(%a: !hw.struct<a: i1, b: i1>) -> (outA: i1, out
 // Rename field names
 // CHECK-LABEL: renameKeyword(
 // CHECK-NEXT:  input  struct packed {logic repeat_0; logic repeat_0_0; } a,
-// CHECK-NEXT:  output struct packed {logic repeat_0; logic repeat_0_0; } r1);
+// CHECK-NEXT:  output struct packed {logic repeat_0; logic repeat_0_0; } r1
+// CHECK-NEXT:  );
 hw.module @renameKeyword(%a: !hw.struct<repeat: i1, repeat_0: i1>) -> (r1: !hw.struct<repeat: i1, repeat_0: i1>){
   hw.output %a : !hw.struct<repeat: i1, repeat_0: i1>
 }
@@ -1024,7 +1038,8 @@ hw.module @renameKeyword(%a: !hw.struct<repeat: i1, repeat_0: i1>) -> (r1: !hw.s
 // CHECK-NEXT:  inout  struct packed {logic repeat_0; logic repeat_0_0; } a,
 // CHECK-NEXT:  output                                                    r1,
 // CHECK-NEXT:                                                            r2,
-// CHECK-NEXT:  output struct packed {logic repeat_0; logic repeat_0_0; } r3);
+// CHECK-NEXT:  output struct packed {logic repeat_0; logic repeat_0_0; } r3
+// CHECK-NEXT:  );
 hw.module @useRenamedStruct(%a: !hw.inout<struct<repeat: i1, repeat_0: i1>>) -> (r1: i1, r2: i1, r3: !hw.struct<repeat: i1, repeat_0: i1>) {
   // CHECK: wire struct packed {logic repeat_0; logic repeat_0_0; } _inst1_r1;
   %read = sv.read_inout %a : !hw.inout<struct<repeat: i1, repeat_0: i1>>
@@ -1111,7 +1126,8 @@ hw.module.extern @parameters2<p1: i42 = 17, p2: i1 = 0>(%arg0: i8) -> (out: i8)
 // CHECK-LABEL: module parameters3
 // CHECK-NEXT:   #(parameter [41:0] p1 = 42'd17) (
 // CHECK-NEXT:   input  [p1 - 1:0] arg0,
-// CHECK-NEXT:   output [p1 - 1:0] out);
+// CHECK-NEXT:   output [p1 - 1:0] out
+// CHECK-NEXT:  );
 // CHECK:   assign out = arg0;
 hw.module @parameters3<p1: i42 = 17>(%arg0: !hw.int<#hw.param.decl.ref<"p1">>) -> (out: !hw.int<#hw.param.decl.ref<"p1">>) {
   hw.output %arg0 : !hw.int<#hw.param.decl.ref<"p1">>
@@ -1221,9 +1237,9 @@ hw.module @VerilogCompatParameters<p1: i42, p2: i32, p3: f64 = 1.5,
 hw.module @parameterizedTypes<param: i32 = 1, wire: i32 = 2>
   // CHECK: input [16:0]{{ *}}a,
   (%a: !hw.int<17>,
-  // CHECK: input [param - 1:0]{{ *}}b,
+  // CHECK: input [param - 1:0]{{ *}}b
    %b: !hw.int<#hw.param.decl.ref<"param">>,
-  // CHECK: input [$clog2($unsigned(param)) - 1:0]{{ *}}c);
+  // CHECK: input [$clog2($unsigned(param)) - 1:0]{{ *}}c
    %c: !hw.int<#hw.param.expr.clog2<#hw.param.decl.ref<"param">>>) {
 
   // Check that the parameter name renamification propagates.
@@ -1253,7 +1269,8 @@ hw.module @Foo(%a: i1, %b: i1) -> (r1: i1, r2: i1) {
 // CHECK-NEXT:     parameter /*integer*/ N) (
 // CHECK-NEXT:   input  [41:0][param - 1:0]        a,
 // CHECK-NEXT:   input  [N - 64'd1:0][param - 1:0] b,
-// CHECK-NEXT:   output [N - 64'd1:0][param - 1:0] c);
+// CHECK-NEXT:   output [N - 64'd1:0][param - 1:0] c
+// CHECK-NEXT:  );
 hw.module @parameterizedArrays<param: i32, N: i32>
   (%a: !hw.array<42x!hw.int<#hw.param.decl.ref<"param">>>,
    %b: !hw.array<#hw.param.decl.ref<"N"> x !hw.int<#hw.param.decl.ref<"param">>>) ->
@@ -1263,7 +1280,8 @@ hw.module @parameterizedArrays<param: i32, N: i32>
 
 // CHECK-LABEL: module UseParameterizedArrays(
 // CHECK-NEXT: input [41:0][11:0] a,
-// CHECK-NEXT: input [23:0][11:0] b);
+// CHECK-NEXT: input [23:0][11:0] b
+// CHECK-NEXT: );
 hw.module @UseParameterizedArrays(%a: !hw.array<42xint<12>>, %b: !hw.array<24xint<12>>) {
 // CHECK:  wire [23:0][11:0] _inst_c;
 // CHECK:  parameterizedArrays #(
@@ -1325,7 +1343,8 @@ hw.module @UniformArrayCreate() -> (arr: !hw.array<5xi8>) {
 }
 
 // CHECK-LABEL: module Issue4485(
-// CHECK-NEXT:    input [3:0] in);
+// CHECK-NEXT:    input [3:0] in
+// CHECK-NEXT:  );
 // CHECK-EMPTY:
 // CHECK-NEXT:  endmodule
 hw.module @Issue4485(%in: i4) {
@@ -1338,7 +1357,8 @@ hw.module @Issue4485(%in: i4) {
 // CHECK-LABEL: module inline_bitcast_in_concat(
 // CHECK-NEXT:    input  [6:0]      in1,
 // CHECK-NEXT:    input  [7:0][3:0] in2,
-// CHECK-NEXT:    output [38:0]     out);
+// CHECK-NEXT:    output [38:0]     out
+// CHECK-NEXT:  );
 // CHECK-EMPTY:
 // CHECK-NEXT:    assign out = {in1, /*cast(bit[31:0])*/in2};
 // CHECK-NEXT:  endmodule
diff --git a/test/Conversion/ExportVerilog/location-style.mlir b/test/Conversion/ExportVerilog/location-style.mlir
index 8e117e019..a3a004f04 100644
--- a/test/Conversion/ExportVerilog/location-style.mlir
+++ b/test/Conversion/ExportVerilog/location-style.mlir
@@ -1,10 +1,12 @@
 // RUN: circt-opt %s -export-verilog --split-input-file | FileCheck %s
 
 module attributes {circt.loweringOptions = "locationInfoStyle=wrapInAtSquareBracket"}{
-// CHECK: module Foo();
-// CHECK-SAME: // @[dummy:1:1]
-// CHECK-NEXT: endmodule
-hw.module @Foo() -> () {
+// CHECK-LABEL: module Foo(
+// CHECK-SAME:    // @[dummy:1:1]
+// CHECK-NEXT:    input a
+// CHECK-NOT:     //
+// CHECK:       endmodule
+hw.module @Foo(%a: i1 loc("")) -> () {
   hw.output
 } loc("dummy":1:1)
 }
diff --git a/test/Conversion/ExportVerilog/name-legalize.mlir b/test/Conversion/ExportVerilog/name-legalize.mlir
index 5f44db66c..fb65c3f1d 100644
--- a/test/Conversion/ExportVerilog/name-legalize.mlir
+++ b/test/Conversion/ExportVerilog/name-legalize.mlir
@@ -2,7 +2,8 @@
 
 // CHECK: module namechange(
 // CHECK: input  [3:0] casex_0,
-// CHECK: output [3:0] if_0);
+// CHECK: output [3:0] if_0
+// CHECK: );
 hw.module @namechange(%casex: i4) -> (if: i4) {
   // CHECK: assign if_0 = casex_0;
   hw.output %casex : i4
@@ -13,7 +14,8 @@ hw.module.extern @module_with_bool<bparam: i1>() -> ()
 // CHECK-LABEL: module parametersNameConflict
 // CHECK-NEXT:    #(parameter [41:0] p2 = 42'd17,
 // CHECK-NEXT:      parameter [0:0]  wire_0) (
-// CHECK-NEXT:    input [7:0] p1);
+// CHECK-NEXT:    input [7:0] p1
+// CHECK-NEXT: );
 hw.module @parametersNameConflict<p2: i42 = 17, wire: i1>(%p1: i8) {
   %myWire = sv.wire : !hw.inout<i1>
 
@@ -61,7 +63,8 @@ hw.module @useParametersNameConflict(%xxx: i8) {
 // Rename keywords used in variable/module names
 // CHECK-LABEL: module inout_0(
 // CHECK:         input  inout_0,
-// CHECK:         output output_0);
+// CHECK:         output output_0
+// CHECK:       );
 hw.module @inout(%inout: i1) -> (output: i1) {
 // CHECK:       assign output_0 = inout_0;
   hw.output %inout : i1
@@ -80,7 +83,8 @@ hw.module @inout_inst(%a: i1) {
 // Rename keywords used in variable/module names
 // CHECK-LABEL: module reg_0(
 // CHECK-NEXT:    input  inout_0,
-// CHECK-NEXT:    output output_0);
+// CHECK-NEXT:    output output_0
+// CHECK-NEXT:  );
 hw.module @reg(%inout: i1) -> (output: i1) {
   // CHECK: assign output_0 = inout_0;
   hw.output %inout : i1
@@ -90,7 +94,8 @@ hw.module @reg(%inout: i1) -> (output: i1) {
 // CHECK-LABEL: module issue525(
 // CHECK-NEXT:    input  [1:0] struct_0,
 // CHECK-NEXT:                 else_0,
-// CHECK-NEXT:    output [1:0] casex_0);
+// CHECK-NEXT:    output [1:0] casex_0
+// CHECK-NEXT:  );
 hw.module @issue525(%struct: i2, %else: i2) -> (casex: i2) {
   // CHECK: assign casex_0 = struct_0 + else_0;
   %2 = comb.add %struct, %else : i2
diff --git a/test/Conversion/ExportVerilog/port-decl-sharing.mlir b/test/Conversion/ExportVerilog/port-decl-sharing.mlir
index aef3133e8..d3af7b3ac 100644
--- a/test/Conversion/ExportVerilog/port-decl-sharing.mlir
+++ b/test/Conversion/ExportVerilog/port-decl-sharing.mlir
@@ -1,13 +1,13 @@
 // RUN: circt-opt %s -export-verilog --split-input-file | FileCheck %s --match-full-lines
 
 module attributes {circt.loweringOptions = "disallowPortDeclSharing"}{
-// CHECK: module Foo( // dummy:1:1
-// CHECK-NEXT:  input        a,
-// CHECK-NEXT:  input        b,
-// CHECK-NEXT:  output [1:0] a_0,
-// CHECK-NEXT:  output [1:0] b_0);
-// CHECK: endmodule
-hw.module @Foo(%a: i1, %b: i1) -> (a: i2, b: i2) {
+// CHECK:      module Foo(     // dummy:1:1
+// CHECK-NEXT:   input        a,       // dummy:1:2
+// CHECK-NEXT:   input        b,       // dummy:1:3
+// CHECK-NEXT:   output [1:0] a_0,     // dummy:1:4
+// CHECK-NEXT:   output [1:0] b_0      // dummy:1:5
+// CHECK-NEXT: );
+hw.module @Foo(%a: i1 loc("dummy":1:2), %b: i1 loc("dummy":1:3)) -> (a: i2 loc("dummy":1:4), b: i2 loc("dummy":1:5)) {
   %ao = comb.concat %a, %b: i1, i1
   %bo = comb.concat %a, %a: i1, i1
   hw.output %ao, %bo : i2, i2
@@ -17,15 +17,72 @@ hw.module @Foo(%a: i1, %b: i1) -> (a: i2, b: i2) {
 // -----
 
 module {
-// CHECK: module Foo( // dummy:1:1
-// CHECK-NEXT:  input        a,
-// CHECK-NEXT:               b,
-// CHECK-NEXT:  output [1:0] a_0,
-// CHECK-NEXT:               b_0);
-// CHECK: endmodule
-hw.module @Foo(%a: i1, %b: i1) -> (a: i2, b: i2) {
+// CHECK:      module Foo(     // dummy:1:1
+// CHECK-NEXT:   input        a,       // dummy:1:2
+// CHECK-NEXT:                b,       // dummy:1:3
+// CHECK-NEXT:   output [1:0] a_0,     // dummy:1:4
+// CHECK-NEXT:                b_0      // dummy:1:5
+// CHECK-NEXT: );
+hw.module @Foo(%a: i1 loc("dummy":1:2), %b: i1 loc("dummy":1:3)) -> (a: i2 loc("dummy":1:4), b: i2 loc("dummy":1:5)) {
   %ao = comb.concat %a, %b: i1, i1
   %bo = comb.concat %a, %a: i1, i1
   hw.output %ao, %bo : i2, i2
 } loc("dummy":1:1)
 }
+
+// -----
+// CHECK:      module Foo(     // dummy:1:1
+// CHECK-NEXT:   // input  /*Zero Width*/ a,   // dummy:1:2
+// CHECK-NEXT:   // input  /*Zero Width*/ b,   // dummy:1:3
+// CHECK-NEXT:   // output /*Zero Width*/ a_0, // dummy:1:4
+// CHECK-NEXT:   // output /*Zero Width*/ b_0  // dummy:1:5
+// CHECK-NEXT: );
+module attributes {circt.loweringOptions = "disallowPortDeclSharing"}{
+hw.module @Foo(%a: i0 loc("dummy":1:2), %b: i0 loc("dummy":1:3)) -> (a: i0 loc("dummy":1:4), b: i0 loc("dummy":1:5)) {
+  hw.output %a, %b : i0, i0
+} loc("dummy":1:1)
+}
+
+// -----
+
+module {
+// CHECK:      module Foo(     // dummy:1:1
+// CHECK-NEXT:   // input  /*Zero Width*/ a,   // dummy:1:2
+// CHECK-NEXT:   //                       b,   // dummy:1:3
+// CHECK-NEXT:   // output /*Zero Width*/ a_0, // dummy:1:4
+// CHECK-NEXT:   //                       b_0  // dummy:1:5
+// CHECK-NEXT: );
+hw.module @Foo(%a: i0 loc("dummy":1:2), %b: i0 loc("dummy":1:3)) -> (a: i0 loc("dummy":1:4), b: i0 loc("dummy":1:5)) {
+  hw.output %a, %b : i0, i0
+} loc("dummy":1:1)
+}
+
+// -----
+
+module attributes {circt.loweringOptions = "disallowPortDeclSharing"}{
+// CHECK:      module Foo(     // dummy:1:1
+// CHECK-NEXT:   // input  /*Zero Width*/ a,   // dummy:1:2
+// CHECK-NEXT:   // input  /*Zero Width*/ b,   // dummy:1:3
+// CHECK-NEXT:      input  [99:0]         c    // new:1:1
+// CHECK-NEXT:   // output /*Zero Width*/ a_0, // dummy:1:4
+// CHECK-NEXT:   // output /*Zero Width*/ b_0  // dummy:1:5
+// CHECK-NEXT: );
+hw.module @Foo(%a: i0 loc("dummy":1:2), %b: i0 loc("dummy":1:3), %c : i100 loc("new":1:1)) -> (a: i0 loc("dummy":1:4), b: i0 loc("dummy":1:5)) {
+  hw.output %a, %b : i0, i0
+} loc("dummy":1:1)
+}
+
+// -----
+
+module {
+// CHECK:      module Foo(     // dummy:1:1
+// CHECK-NEXT:   // input  /*Zero Width*/ a,   // dummy:1:2
+// CHECK-NEXT:   //                       b,   // dummy:1:3
+// CHECK-NEXT:      input  [99:0]         c    // new:1:1
+// CHECK-NEXT:   // output /*Zero Width*/ a_0, // dummy:1:4
+// CHECK-NEXT:   //                       b_0  // dummy:1:5
+// CHECK-NEXT: );
+hw.module @Foo(%a: i0 loc("dummy":1:2), %b: i0 loc("dummy":1:3), %c : i100 loc("new":1:1)) -> (a: i0 loc("dummy":1:4), b: i0 loc("dummy":1:5)) {
+  hw.output %a, %b : i0, i0
+} loc("dummy":1:1)
+}
diff --git a/test/Conversion/ExportVerilog/sv-always-wire.mlir b/test/Conversion/ExportVerilog/sv-always-wire.mlir
index ecbcc43c5..671b39fe3 100644
--- a/test/Conversion/ExportVerilog/sv-always-wire.mlir
+++ b/test/Conversion/ExportVerilog/sv-always-wire.mlir
@@ -1,4 +1,5 @@
-// RUN: circt-opt %s --export-verilog --verify-diagnostics -o %t | FileCheck %s --strict-whitespace
+// RUN: circt-opt %s -prettify-verilog --export-verilog --verify-diagnostics -o %t | FileCheck %s --strict-whitespace
+// RUN: circt-opt %s -test-apply-lowering-options='options=exprInEventControl' -prettify-verilog -export-verilog | FileCheck %s --check-prefix=INLINE
 
 // CHECK-LABEL: module AlwaysSpill(
 hw.module @AlwaysSpill(%port: i1) {
@@ -23,17 +24,33 @@ hw.module @AlwaysSpill(%port: i1) {
 
   // Constant values should cause a spill.
   // CHECK: always @(posedge [[TMP1]])
+  // INLINE: always @(posedge 1'h0)
   sv.always posedge %false {}
   // CHECK: always_ff @(posedge [[TMP2]])
+  // INLINE: always_ff @(posedge 1'h1)
   sv.alwaysff(posedge %true) {}
 }
 
 // CHECK-LABEL: module Foo
-hw.module @Foo(%clock: i1, %reset0: i1, %reset1: i1) -> () {
+// INLINE-LABEL: module Foo
+hw.module @Foo(%reset0: i1, %reset1: i1) -> () {
   %0 = comb.or %reset0, %reset1 : i1
-// CHECK-NOT: _GEN_0
+  // CHECK:      wire [[TMP0:.*]] = reset0 | reset1;
+  // CHECK-NEXT: always @(posedge [[TMP0]])
+  // CHECK-NEXT:   if ([[TMP0]])
   sv.always posedge %0 {
     sv.if %0 {
     }
   }
+  %true = hw.constant true
+  %1 = comb.xor %reset0, %true : i1
+  // CHECK:      wire [[TMP1:.*]] = ~reset0;
+  // CHECK-NEXT: always @(posedge [[TMP1]])
+  // CHECK-NEXT:   if ([[TMP1]])
+  // INLINE:     always @(posedge ~reset0)
+  // INLINE-NEXT:   if (~reset0)
+  sv.always posedge %1 {
+    sv.if %1 {
+    }
+  }
 }
diff --git a/test/Conversion/ExportVerilog/sv-dialect.mlir b/test/Conversion/ExportVerilog/sv-dialect.mlir
index 04f40b36a..373152504 100644
--- a/test/Conversion/ExportVerilog/sv-dialect.mlir
+++ b/test/Conversion/ExportVerilog/sv-dialect.mlir
@@ -1,4 +1,4 @@
-// RUN: circt-opt %s -test-apply-lowering-options='options=exprInEventControl,explicitBitcast,maximumNumberOfTermsPerExpression=10' -export-verilog -verify-diagnostics | FileCheck %s
+// RUN: circt-opt %s -test-apply-lowering-options='options=explicitBitcast,maximumNumberOfTermsPerExpression=10' -export-verilog -verify-diagnostics | FileCheck %s
 
 // CHECK-LABEL: module M1
 // CHECK-NEXT:    #(parameter [41:0] param1) (
@@ -457,9 +457,10 @@ hw.module @M1<param1: i42>(%clock : i1, %cond : i1, %val : i8) {
 }
 
 // CHECK-LABEL: module Aliasing(
-// CHECK-NEXT:             inout [41:0] a,
-// CHECK-NEXT:                          b,
-// CHECK-NEXT:                          c)
+// CHECK-NEXT:    inout [41:0] a, //
+// CHECK-NEXT:                 b, //
+// CHECK-NEXT:                 c //
+// CHECK-NEXT:  );
 hw.module @Aliasing(%a : !hw.inout<i42>, %b : !hw.inout<i42>,
                       %c : !hw.inout<i42>) {
 
@@ -471,10 +472,11 @@ hw.module @Aliasing(%a : !hw.inout<i42>, %b : !hw.inout<i42>,
 
 hw.module @reg_0(%in4: i4, %in8: i8) -> (a: i8, b: i8) {
   // CHECK-LABEL: module reg_0(
-  // CHECK-NEXT:   input  [3:0] in4,
-  // CHECK-NEXT:   input  [7:0] in8,
-  // CHECK-NEXT:   output [7:0] a,
-  // CHECK-NEXT:                b);
+  // CHECK-NEXT:   input  [3:0] in4, //
+  // CHECK-NEXT:   input  [7:0] in8, //
+  // CHECK-NEXT:   output [7:0] a, //
+  // CHECK-NEXT:                b //
+  // CHECK-NEXT:  );
 
   // CHECK-EMPTY:
   // CHECK-NEXT: (* dont_merge *)
@@ -526,8 +528,9 @@ hw.module @reg_1(%in4: i4, %in8: i8) -> (a : i3, b : i5) {
 }
 
 // CHECK-LABEL: module struct_field_inout1(
+// CHECK-NEXT:   inout struct packed {logic b; } a
+// CHECK-NEXT:  );
 hw.module @struct_field_inout1(%a : !hw.inout<struct<b: i1>>) {
-  // CHECK: inout struct packed {logic b; } a);
   // CHECK: assign a.b = 1'h1;
   %true = hw.constant true
   %0 = sv.struct_field_inout %a["b"] : !hw.inout<struct<b: i1>>
@@ -535,8 +538,9 @@ hw.module @struct_field_inout1(%a : !hw.inout<struct<b: i1>>) {
 }
 
 // CHECK-LABEL: module struct_field_inout2(
+// CHECK-NEXT:    inout struct packed {struct packed {logic c; } b; } a
+// CHECK-NEXT:  );
 hw.module @struct_field_inout2(%a: !hw.inout<struct<b: !hw.struct<c: i1>>>) {
-  // CHECK: inout struct packed {struct packed {logic c; } b; } a);
   // CHECK: assign a.b.c = 1'h1;
   %true = hw.constant true
   %0 = sv.struct_field_inout %a["b"] : !hw.inout<struct<b: !hw.struct<c: i1>>>
@@ -1562,9 +1566,10 @@ hw.module @ElseIfLocations(%clock: i1, %flag1 : i1, %flag2: i1, %flag3: i1) {
 }
 
 // CHECK-LABEL: ReuseExistingInOut
-// CHECK: input {{.+}},
-// CHECK:        [[INPUT:[:alnum:]+]],
-// CHECK: output [[OUTPUT:.+]])
+// CHECK: input {{.+}}, //
+// CHECK:        [[INPUT:[:alnum:]+]], //
+// CHECK: output [[OUTPUT:.+]] //
+// CHECK: );
 hw.module @ReuseExistingInOut(%clock: i1, %a: i1) -> (out1: i1) {
   %expr1 = comb.or %a, %a : i1
   %expr2 = comb.and %a, %a : i1
@@ -1796,4 +1801,3 @@ sv.bind #hw.innerNameRef<@InlineBind::@foo2>
 // CHECK-LABEL:  hw.module @remoteInstDut
 // CHECK:    %signed = sv.wire  {hw.verilogName = "signed_0"} : !hw.inout<i1>
 // CHECK:    %output = sv.reg  {hw.verilogName = "output_0"} : !hw.inout<i1>
-
diff --git a/test/Conversion/ExportVerilog/verilog-basic.mlir b/test/Conversion/ExportVerilog/verilog-basic.mlir
index 7706046c9..8df557626 100644
--- a/test/Conversion/ExportVerilog/verilog-basic.mlir
+++ b/test/Conversion/ExportVerilog/verilog-basic.mlir
@@ -1,8 +1,9 @@
 // RUN: circt-opt %s -export-verilog -verify-diagnostics | FileCheck %s --strict-whitespace
 
 // CHECK-LABEL: module inputs_only(
-// CHECK-NEXT: input a,
-// CHECK-NEXT:       b);
+// CHECK-NEXT:   input a,{{.*}}
+// CHECK-NEXT:         b
+// CHECK-NEXT:  );
 hw.module @inputs_only(%a: i1, %b: i1) {
   hw.output
 }
@@ -27,7 +28,8 @@ hw.module @no_ports() {
 // CHECK-NEXT:    output [15:0] out16,
 // CHECK-NEXT:                  out16s,
 // CHECK-NEXT:    output [16:0] sext17,
-// CHECK-NEXT:    output [1:0]  orvout);
+// CHECK-NEXT:    output [1:0]  orvout
+// CHECK-NEXT:  );
 
 hw.module @Expressions(%in4: i4, %clock: i1) ->
   (out1a: i1, out1b: i1, out1c: i1, out1d: i1, out1e: i1, out1f: i1, out1g: i1,
@@ -313,7 +315,8 @@ hw.module @MultiUseExpr(%a: i4) -> (b0: i1, b1: i1, b2: i1, b3: i1, b4: i2) {
 
 // CHECK-LABEL: module SimpleConstPrint(
 // CHECK-NEXT:    input  [3:0] in4,
-// CHECK-NEXT:    output [3:0] out4);
+// CHECK-NEXT:    output [3:0] out4
+// CHECK-NEXT: );
 // CHECK:  wire [3:0] w = 4'h1;
 // CHECK:  assign out4 = in4 + 4'h1;
 // CHECK-NEXT: endmodule
@@ -347,6 +350,7 @@ hw.module @SimpleConstPrintReset(%clock: i1, %reset: i1, %in4: i4) -> () {
 
 // CHECK-LABEL: module ordered_region
 // CHECK-NEXT: input a
+// CHECK-NEXT: );
 // CHECK-EMPTY:
 hw.module @ordered_region(%a: i1) {
   sv.ordered {
@@ -417,7 +421,8 @@ hw.module @NestedParameterUsage<param: i32>(
   %in: !hw.int<#hw.param.decl.ref<"param">>) -> (out: !hw.int<#hw.param.decl.ref<"param">>) {
   // CHECK: #(parameter /*integer*/ param) (
   // CHECK: input  [param - 1:0] in,
-  // CHECK: output [param - 1:0] out);
+  // CHECK: output [param - 1:0] out
+  // CHECK: );
   // CHECK: ExternParametricWidth #(
   // CHECK:   .width(param)
   // CHECK: ) externWidth (
@@ -476,18 +481,40 @@ hw.module @Print(%clock: i1, %reset: i1, %a: i4, %b: i4) {
 
 // CHECK-LABEL: module ReadMem()
 hw.module @ReadMem() {
-
-  // CHECK:      initial begin
-  // CHECK-NEXT:   reg [31:0] memForReadMem[0:7];
-  // CHECK-NEXT:   $readmemb("file1.txt", memForReadMem);
-  // CHECK-NEXT:   $readmemh("file2.txt", memForReadMem);
+  // CHECK:      reg [31:0] mem[0:7];
+  %mem = sv.reg sym @mem : !hw.inout<uarray<8xi32>>
+  // CHECK-NEXT: initial begin
+  // CHECK-NEXT:   $readmemb("file1.txt", mem);
+  // CHECK-NEXT:   $readmemh("file2.txt", mem);
   // CHECK-NEXT: end
   sv.initial {
-    %memForReadMem = sv.reg sym @MemForReadMem : !hw.inout<uarray<8xi32>>
-    sv.readmem @MemForReadMem, "file1.txt", MemBaseBin
-    sv.readmem @MemForReadMem, "file2.txt", MemBaseHex
+    sv.readmem %mem, "file1.txt", MemBaseBin : !hw.inout<uarray<8xi32>>
+    sv.readmem %mem, "file2.txt", MemBaseHex : !hw.inout<uarray<8xi32>>
+  }
+
+}
+
+// CHECK: module ReadMemXMR()
+hw.module @ReadMemXMR() {
+  hw.instance "ReadMem" sym @ReadMem_sym @ReadMem() -> ()
+  // CHECK:      initial
+  // CHECK-NEXT:   $readmemb("file3.txt", ReadMem.mem)
+  sv.initial {
+    %xmr = sv.xmr.ref #hw.innerNameRef<@ReadMem::@mem> {} : !hw.inout<uarray<8xi32>>
+    sv.readmem %xmr, "file3.txt", MemBaseBin : !hw.inout<uarray<8xi32>>
   }
+}
 
+hw.hierpath @ReadMem_path [@ReadMemXMRHierPath::@ReadMemXMR_sym, @ReadMemXMR::@ReadMem_sym, @ReadMem::@mem]
+// CHECK: module ReadMemXMRHierPath()
+hw.module @ReadMemXMRHierPath() {
+  hw.instance "ReadMemXMR" sym @ReadMemXMR_sym @ReadMemXMR() -> ()
+  // CHECK:      initial
+  // CHECK-NEXT:   $readmemb("file4.txt", ReadMemXMRHierPath.ReadMemXMR.ReadMem.mem)
+  sv.initial {
+    %xmr = sv.xmr.ref @ReadMem_path : !hw.inout<uarray<8xi32>>
+    sv.readmem %xmr, "file4.txt", MemBaseBin : !hw.inout<uarray<8xi32>>
+  }
 }
 
 // CHECK-LABEL: module UninitReg1(
diff --git a/test/Conversion/FIRRTLToHW/lower-to-hw.mlir b/test/Conversion/FIRRTLToHW/lower-to-hw.mlir
index 0eac57895..65185c213 100644
--- a/test/Conversion/FIRRTLToHW/lower-to-hw.mlir
+++ b/test/Conversion/FIRRTLToHW/lower-to-hw.mlir
@@ -48,14 +48,14 @@ firrtl.circuit "Simple"   attributes {annotations = [{class =
   // CHECK-NEXT: }
 
   //These come from MemSimple, IncompleteRead, and MemDepth1
-  // CHECK-LABEL: hw.generator.schema @FIRRTLMem, "FIRRTL_Memory", ["depth", "numReadPorts", "numWritePorts", "numReadWritePorts", "readLatency", "writeLatency", "width", "maskGran", "readUnderWrite", "writeUnderWrite", "writeClockIDs"]
-  // CHECK: hw.module.generated @aa_combMem, @FIRRTLMem(%W0_addr: i4, %W0_en: i1, %W0_clk: i1, %W0_data: i8, %W1_addr: i4, %W1_en: i1, %W1_clk: i1, %W1_data: i8) attributes {depth = 16 : i64, maskGran = 8 : ui32, numReadPorts = 0 : ui32, numReadWritePorts = 0 : ui32, numWritePorts = 2 : ui32, readLatency = 1 : ui32, readUnderWrite = 0 : ui32, width = 8 : ui32, writeClockIDs = [0 : i32, 0 : i32], writeLatency = 1 : ui32, writeUnderWrite = 1 : i32}
-  // CHECK: hw.module.generated @ab_combMem, @FIRRTLMem(%W0_addr: i4, %W0_en: i1, %W0_clk: i1, %W0_data: i8, %W1_addr: i4, %W1_en: i1, %W1_clk: i1, %W1_data: i8) attributes {depth = 16 : i64, maskGran = 8 : ui32, numReadPorts = 0 : ui32, numReadWritePorts = 0 : ui32, numWritePorts = 2 : ui32, readLatency = 1 : ui32, readUnderWrite = 0 : ui32, width = 8 : ui32, writeClockIDs = [0 : i32, 1 : i32], writeLatency = 1 : ui32, writeUnderWrite = 1 : i32}
-  // CHECK: hw.module.generated @mem0_combMem, @FIRRTLMem(%R0_addr: i1, %R0_en: i1, %R0_clk: i1) -> (R0_data: i32) attributes {depth = 1 : i64, maskGran = 32 : ui32, numReadPorts = 1 : ui32, numReadWritePorts = 0 : ui32, numWritePorts = 0 : ui32, readLatency = 0 : ui32, readUnderWrite = 1 : ui32, width = 32 : ui32, writeClockIDs = [], writeLatency = 1 : ui32, writeUnderWrite = 1 : i32}
-  // CHECK: hw.module.generated @_M_combMem, @FIRRTLMem(%R0_addr: i4, %R0_en: i1, %R0_clk: i1) -> (R0_data: i42) attributes {depth = 12 : i64, maskGran = 42 : ui32, numReadPorts = 1 : ui32, numReadWritePorts = 0 : ui32, numWritePorts = 0 : ui32, readLatency = 0 : ui32, readUnderWrite = 0 : ui32, width = 42 : ui32, writeClockIDs = [], writeLatency = 1 : ui32, writeUnderWrite = 1 : i32}
-  // CHECK: hw.module.generated @tbMemoryKind1_combMem, @FIRRTLMem(%R0_addr: i4, %R0_en: i1, %R0_clk: i1, %W0_addr: i4, %W0_en: i1, %W0_clk: i1, %W0_data: i8) -> (R0_data: i8) attributes {depth = 16 : i64, maskGran = 8 : ui32, numReadPorts = 1 : ui32, numReadWritePorts = 0 : ui32, numWritePorts = 1 : ui32, readLatency = 1 : ui32, readUnderWrite = 0 : ui32, width = 8 : ui32, writeClockIDs = [0 : i32], writeLatency = 1 : ui32, writeUnderWrite = 1 : i32}
-  // CHECK: hw.module.generated @_M_mask_combMem, @FIRRTLMem(%R0_addr: i10, %R0_en: i1, %R0_clk: i1, %RW0_addr: i10, %RW0_en: i1, %RW0_clk: i1, %RW0_wmode: i1, %RW0_wdata: i40, %RW0_wmask: i4, %W0_addr: i10, %W0_en: i1, %W0_clk: i1, %W0_data: i40, %W0_mask: i4) -> (R0_data: i40, RW0_rdata: i40) attributes {depth = 1022 : i64, maskGran = 10 : ui32, numReadPorts = 1 : ui32, numReadWritePorts = 1 : ui32, numWritePorts = 1 : ui32, readLatency = 1 : ui32, readUnderWrite = 0 : ui32, width = 40 : ui32, writeClockIDs = [0 : i32], writeLatency = 1 : ui32, writeUnderWrite = 1 : i32}
-  // CHECK: hw.module.generated @_M_combMem_0, @FIRRTLMem(%R0_addr: i4, %R0_en: i1, %R0_clk: i1, %RW0_addr: i4, %RW0_en: i1, %RW0_clk: i1, %RW0_wmode: i1, %RW0_wdata: i42, %W0_addr: i4, %W0_en: i1, %W0_clk: i1, %W0_data: i42) -> (R0_data: i42, RW0_rdata: i42) attributes {depth = 12 : i64, maskGran = 42 : ui32, numReadPorts = 1 : ui32, numReadWritePorts = 1 : ui32, numWritePorts = 1 : ui32, readLatency = 0 : ui32, readUnderWrite = 0 : ui32, width = 42 : ui32, writeClockIDs = [0 : i32], writeLatency = 1 : ui32, writeUnderWrite = 1 : i32}
+  // CHECK-LABEL: hw.generator.schema @FIRRTLMem, "FIRRTL_Memory", ["depth", "numReadPorts", "numWritePorts", "numReadWritePorts", "readLatency", "writeLatency", "width", "maskGran", "readUnderWrite", "writeUnderWrite", "writeClockIDs", "initFilename", "initIsBinary", "initIsInline"]
+  // CHECK: hw.module.generated @aa_combMem, @FIRRTLMem(%W0_addr: i4, %W0_en: i1, %W0_clk: i1, %W0_data: i8, %W1_addr: i4, %W1_en: i1, %W1_clk: i1, %W1_data: i8) attributes {depth = 16 : i64, initFilename = "", initIsBinary = false, initIsInline = false, maskGran = 8 : ui32, numReadPorts = 0 : ui32, numReadWritePorts = 0 : ui32, numWritePorts = 2 : ui32, readLatency = 1 : ui32, readUnderWrite = 0 : ui32, width = 8 : ui32, writeClockIDs = [0 : i32, 0 : i32], writeLatency = 1 : ui32, writeUnderWrite = 1 : i32}
+  // CHECK: hw.module.generated @ab_combMem, @FIRRTLMem(%W0_addr: i4, %W0_en: i1, %W0_clk: i1, %W0_data: i8, %W1_addr: i4, %W1_en: i1, %W1_clk: i1, %W1_data: i8) attributes {depth = 16 : i64, initFilename = "", initIsBinary = false, initIsInline = false, maskGran = 8 : ui32, numReadPorts = 0 : ui32, numReadWritePorts = 0 : ui32, numWritePorts = 2 : ui32, readLatency = 1 : ui32, readUnderWrite = 0 : ui32, width = 8 : ui32, writeClockIDs = [0 : i32, 1 : i32], writeLatency = 1 : ui32, writeUnderWrite = 1 : i32}
+  // CHECK: hw.module.generated @mem0_combMem, @FIRRTLMem(%R0_addr: i1, %R0_en: i1, %R0_clk: i1) -> (R0_data: i32) attributes {depth = 1 : i64, initFilename = "", initIsBinary = false, initIsInline = false, maskGran = 32 : ui32, numReadPorts = 1 : ui32, numReadWritePorts = 0 : ui32, numWritePorts = 0 : ui32, readLatency = 0 : ui32, readUnderWrite = 1 : ui32, width = 32 : ui32, writeClockIDs = [], writeLatency = 1 : ui32, writeUnderWrite = 1 : i32}
+  // CHECK: hw.module.generated @_M_combMem, @FIRRTLMem(%R0_addr: i4, %R0_en: i1, %R0_clk: i1) -> (R0_data: i42) attributes {depth = 12 : i64, initFilename = "", initIsBinary = false, initIsInline = false, maskGran = 42 : ui32, numReadPorts = 1 : ui32, numReadWritePorts = 0 : ui32, numWritePorts = 0 : ui32, readLatency = 0 : ui32, readUnderWrite = 0 : ui32, width = 42 : ui32, writeClockIDs = [], writeLatency = 1 : ui32, writeUnderWrite = 1 : i32}
+  // CHECK: hw.module.generated @tbMemoryKind1_combMem, @FIRRTLMem(%R0_addr: i4, %R0_en: i1, %R0_clk: i1, %W0_addr: i4, %W0_en: i1, %W0_clk: i1, %W0_data: i8) -> (R0_data: i8) attributes {depth = 16 : i64, initFilename = "", initIsBinary = false, initIsInline = false, maskGran = 8 : ui32, numReadPorts = 1 : ui32, numReadWritePorts = 0 : ui32, numWritePorts = 1 : ui32, readLatency = 1 : ui32, readUnderWrite = 0 : ui32, width = 8 : ui32, writeClockIDs = [0 : i32], writeLatency = 1 : ui32, writeUnderWrite = 1 : i32}
+  // CHECK: hw.module.generated @_M_mask_combMem, @FIRRTLMem(%R0_addr: i10, %R0_en: i1, %R0_clk: i1, %RW0_addr: i10, %RW0_en: i1, %RW0_clk: i1, %RW0_wmode: i1, %RW0_wdata: i40, %RW0_wmask: i4, %W0_addr: i10, %W0_en: i1, %W0_clk: i1, %W0_data: i40, %W0_mask: i4) -> (R0_data: i40, RW0_rdata: i40) attributes {depth = 1022 : i64, initFilename = "", initIsBinary = false, initIsInline = false, maskGran = 10 : ui32, numReadPorts = 1 : ui32, numReadWritePorts = 1 : ui32, numWritePorts = 1 : ui32, readLatency = 1 : ui32, readUnderWrite = 0 : ui32, width = 40 : ui32, writeClockIDs = [0 : i32], writeLatency = 1 : ui32, writeUnderWrite = 1 : i32}
+  // CHECK: hw.module.generated @_M_combMem_0, @FIRRTLMem(%R0_addr: i4, %R0_en: i1, %R0_clk: i1, %RW0_addr: i4, %RW0_en: i1, %RW0_clk: i1, %RW0_wmode: i1, %RW0_wdata: i42, %W0_addr: i4, %W0_en: i1, %W0_clk: i1, %W0_data: i42) -> (R0_data: i42, RW0_rdata: i42) attributes {depth = 12 : i64, initFilename = "", initIsBinary = false, initIsInline = false, maskGran = 42 : ui32, numReadPorts = 1 : ui32, numReadWritePorts = 1 : ui32, numWritePorts = 1 : ui32, readLatency = 0 : ui32, readUnderWrite = 0 : ui32, width = 42 : ui32, writeClockIDs = [0 : i32], writeLatency = 1 : ui32, writeUnderWrite = 1 : i32}
 
   // CHECK-LABEL: hw.module @Simple
   firrtl.module @Simple(in %in1: !firrtl.uint<4>,
@@ -1788,11 +1788,13 @@ firrtl.circuit "Simple"   attributes {annotations = [{class =
   }
 
   // CHECK-LABEL: hw.module @aggregateconstant
-  firrtl.module @aggregateconstant(out %out : !firrtl.vector<uint<8>, 2>) {
-    %0 = firrtl.aggregateconstant [1 : ui8, 0: ui8] : !firrtl.vector<uint<8>, 2>
-    firrtl.strictconnect %out, %0 : !firrtl.vector<uint<8>, 2>
-    // CHECK:      %0 = hw.aggregate_constant [0 : i8, 1 : i8] : !hw.array<2xi8>
-    // CHECK-NEXT: hw.output %0 : !hw.array<2xi8>
+  firrtl.module @aggregateconstant(out %out : !firrtl.bundle<a: vector<vector<uint<8>, 2>, 2>, b: vector<vector<uint<8>, 2>, 2>>) {
+    %0 = firrtl.aggregateconstant [[[0 : ui8, 1: ui8], [2 : ui8, 3: ui8]], [[4: ui8, 5: ui8], [6: ui8, 7:ui8]]] :
+      !firrtl.bundle<a: vector<vector<uint<8>, 2>, 2>, b: vector<vector<uint<8>, 2>, 2>>
+    firrtl.strictconnect %out, %0 : !firrtl.bundle<a: vector<vector<uint<8>, 2>, 2>, b: vector<vector<uint<8>, 2>, 2>>
+    // CHECK{LITERAL}:   %0 = hw.aggregate_constant [[[3 : i8, 2 : i8], [1 : i8, 0 : i8]], [[7 : i8, 6 : i8], [5 : i8, 4 : i8]]]
+    // CHECK-SAME: !hw.struct<a: !hw.array<2xarray<2xi8>>, b: !hw.array<2xarray<2xi8>>>
+    // CHECK: hw.output %0
   }
 
   // CHECK-LABEL: hw.module @intrinsic
@@ -1813,7 +1815,7 @@ firrtl.circuit "Simple"   attributes {annotations = [{class =
     // CHECK: %[[foo:.*]] = sv.constantStr "foo"
     // CHECK: %[[tmp:.*]] = sv.wire : !hw.inout<i5>
     // CHECK: sv.system "value$plusargs"(%[[foo]], %[[tmp]])
-    
+
   }
 
   // An internal-only analog connection between two instances should be implemented with a wire
diff --git a/test/Dialect/ESI/structure.mlir b/test/Dialect/ESI/structure.mlir
new file mode 100644
index 000000000..9972f316c
--- /dev/null
+++ b/test/Dialect/ESI/structure.mlir
@@ -0,0 +1,9 @@
+// RUN: circt-opt %s  | circt-opt | FileCheck %s
+
+msft.module @Foo {} (%in0 : !esi.channel<i1>) -> (out: !esi.channel<i1>)
+
+// CHECK-LABEL:  esi.pure_module @top {
+// CHECK-NEXT:     %foo.out = msft.instance @foo @Foo(%foo.out)  : (!esi.channel<i1>) -> !esi.channel<i1>
+esi.pure_module @top {
+  %loopback = msft.instance @foo @Foo(%loopback) : (!esi.channel<i1>) -> (!esi.channel<i1>)
+}
diff --git a/test/Dialect/ESI/structure_errors.mlir b/test/Dialect/ESI/structure_errors.mlir
new file mode 100644
index 000000000..1b1d7aa6c
--- /dev/null
+++ b/test/Dialect/ESI/structure_errors.mlir
@@ -0,0 +1,28 @@
+// RUN: circt-opt %s -split-input-file --verify-diagnostics
+
+msft.module @Foo {} (%in0: i1) -> (out: i1)
+esi.pure_module @top {
+  // expected-error @+1 {{'msft.instance' op instances in ESI pure modules can only contain channel ports}}
+  %loopback = msft.instance @foo @Foo(%loopback) : (i1) -> (i1)
+}
+
+// -----
+
+msft.module @Foo{} () -> (out: i1)
+
+esi.pure_module @top {
+  // expected-error @+1 {{'msft.instance' op instances in ESI pure modules can only contain channel ports}}
+  msft.instance @foo @Foo() : () -> (i1)
+}
+
+// -----
+
+msft.module @Foo {} (%in0 : !esi.channel<i1>) -> (out: !esi.channel<i1>)
+
+esi.pure_module @top {
+  %loopback = msft.instance @foo @Foo(%loopbackDouble) : (!esi.channel<i1>) -> (!esi.channel<i1>)
+  %data, %valid = esi.unwrap.vr %loopback, %ready : i1
+  // expected-error @+1 {{'comb.add' op operation not allowed in ESI pure modules}}
+  %double = comb.add %data, %data : i1
+  %loopbackDouble, %ready = esi.wrap.vr %double, %valid : i1
+}
diff --git a/test/Dialect/FIRRTL/SFCTests/GrandCentralInterfaces/HWRename.fir b/test/Dialect/FIRRTL/SFCTests/GrandCentralInterfaces/HWRename.fir
index 8403838a0..5bed6fa11 100644
--- a/test/Dialect/FIRRTL/SFCTests/GrandCentralInterfaces/HWRename.fir
+++ b/test/Dialect/FIRRTL/SFCTests/GrandCentralInterfaces/HWRename.fir
@@ -27,7 +27,8 @@ circuit Top:
     b <= signed.b
 
     ; CHECK:      module Companion(
-    ; CHECK:        input [[port:[a-zA-Z0-9_]+]]);
+    ; CHECK:        input [[port:[a-zA-Z0-9_]+]]
+    ; CHECK:      );
     ; CHECK:        MyInterface MyView();
     ; CHECK-NEXT:   assign MyView.[[elementName:.+]] = [[port]];
     ; CHECK-NEXT: endmodule
diff --git a/test/Dialect/FIRRTL/SFCTests/GrandCentralInterfaces/InstantiateCompanionOnly.fir b/test/Dialect/FIRRTL/SFCTests/GrandCentralInterfaces/InstantiateCompanionOnly.fir
index 866d2764e..9f3a95353 100644
--- a/test/Dialect/FIRRTL/SFCTests/GrandCentralInterfaces/InstantiateCompanionOnly.fir
+++ b/test/Dialect/FIRRTL/SFCTests/GrandCentralInterfaces/InstantiateCompanionOnly.fir
@@ -34,6 +34,10 @@ circuit Foo : %[[
     "class": "sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation",
     "directory": "Wire/firrtl/gct",
     "filename": "Wire/firrtl/bindings.sv"
+  },
+  {
+    "class": "sifive.enterprise.grandcentral.GrandCentralHierarchyFileAnnotation",
+    "filename": "gct.yaml"
   }
 ]]
   module Companion :
@@ -57,3 +61,7 @@ circuit Foo : %[[
     ; CHECK-NOT:   emitted as a bind statement
     ; CHECK:       Companion companion
     ; CHECK:     endmodule
+
+; Verify that an empty yaml file is created.
+; CHECK: FILE "gct.yaml"
+; CHECK: []  
\ No newline at end of file
diff --git a/test/Dialect/FIRRTL/SFCTests/data-taps-errors.fir b/test/Dialect/FIRRTL/SFCTests/data-taps-errors.fir
index 330f4d48f..0570e1bf3 100644
--- a/test/Dialect/FIRRTL/SFCTests/data-taps-errors.fir
+++ b/test/Dialect/FIRRTL/SFCTests/data-taps-errors.fir
@@ -57,3 +57,117 @@ circuit NoSafeInsertionPoint : %[[
     wire tap: UInt<3>
     tap is invalid
     o <= tap
+
+; // -----
+
+; expected-error @below {{Unable to apply annotation}}
+circuit Top : %[[
+  {
+    "class": "firrtl.passes.wiring.SinkAnnotation",
+    "target": "Top.BlackBox.sink",
+    "pin": "test_pin"
+  },
+  {
+    "class": "firrtl.passes.wiring.SourceAnnotation",
+    "target": "Top.Top.legacy_tap",
+    "pin": "test_pin"
+  },
+  {
+    "class": "sifive.enterprise.grandcentral.DataTapsAnnotation",
+    "keys": [
+      {
+        "class": "sifive.enterprise.grandcentral.ReferenceDataTapKey",
+        "source": "~Top|Top/foo:Foo/b:Bar>inv",
+        "sink": "~Top|Top>tap"
+      },
+      {
+        "class":"sifive.enterprise.grandcentral.DataTapModuleSignalKey",
+        "module":"~Top|BlackBox",
+        "internalPath":"random.something",
+        "sink": "~Top|Top>tap2"
+      },
+      {
+        "class":"sifive.enterprise.grandcentral.DataTapModuleSignalKey",
+        "module":"~Top|BlackBox",
+        "internalPath":"random.something_else",
+        "sink": "~Top|Top>tap3"
+      },
+      {
+        "class":"sifive.enterprise.grandcentral.DataTapModuleSignalKey",
+        "module":"~Top|InternalPathChild",
+        "internalPath":"io_out",
+        "sink": "~Top|Top/unsigned:ChildWrapper/signed:Child>tap"
+      }
+    ]
+  },
+  {
+    "class": "firrtl.transforms.DontTouchAnnotation",
+    "target": "~Top|Top>tap"
+  },
+  {
+    "class": "firrtl.transforms.DontTouchAnnotation",
+    "target": "~Top|Top>tap2"
+  },
+  {
+    "class": "firrtl.transforms.DontTouchAnnotation",
+    "target": "~Top|Top>tap3"
+  },
+  {
+    "class": "firrtl.transforms.DontTouchAnnotation",
+    "target": "~Top|Child>tap"
+  },
+  {
+    "class": "firrtl.transforms.DontTouchAnnotation",
+    "target": "~Top|Bar>inv"
+  }
+]]
+  module InternalPathChild :
+
+    skip
+
+; expected-error @below {{'firrtl.extmodule' op cannot be used for both legacy Wiring and DataTaps simultaneously}}
+  extmodule BlackBox :
+    input sink : UInt<1>
+
+    defname = BlackBox
+
+  module Child :
+
+    inst localparam of BlackBox
+    localparam is invalid
+
+    wire tap : UInt<1>
+    tap is invalid
+
+  module ChildWrapper :
+
+    inst signed of Child
+
+  module Bar :
+
+    wire inv : UInt<1>
+    inv is invalid
+
+  module Foo :
+
+    inst b of Bar
+
+  module Top:
+
+    inst foo of Foo
+
+    wire tap : UInt<1>
+    tap is invalid
+
+    wire tap2 : UInt<1>
+    tap2 is invalid
+
+    wire tap3 : UInt<1>
+    tap3 is invalid
+
+    wire legacy_tap : UInt<1>
+    legacy_tap is invalid
+
+    inst unsigned of ChildWrapper
+
+    inst int of InternalPathChild
diff --git a/test/Dialect/FIRRTL/SFCTests/load-memory-from-file.fir b/test/Dialect/FIRRTL/SFCTests/load-memory-from-file.fir
new file mode 100644
index 000000000..92f952be4
--- /dev/null
+++ b/test/Dialect/FIRRTL/SFCTests/load-memory-from-file.fir
@@ -0,0 +1,41 @@
+; RUN: firtool %s -disable-all-randomization | FileCheck %s --check-prefixes=CHECK,INIT_NONE
+; RUN: firtool %s -annotation-file %s.inline.anno.json -disable-all-randomization | FileCheck %s --check-prefixes=CHECK,INIT_INLINE
+; RUN: firtool %s -annotation-file %s.outline.anno.json -disable-all-randomization | FileCheck %s --check-prefixes=CHECK,INIT_OUTLINE
+
+circuit Foo :
+  module Foo :
+    input clock : Clock
+    input reset : UInt<1>
+    output read : { flip en : UInt<1>, data : UInt<8>, flip addr : UInt<5>}
+    output write : { flip en : UInt<1>, flip data : UInt<8>, flip addr : UInt<5>}
+
+    smem m : UInt<8> [32]
+    read.data is invalid
+    when read.en :
+      read mport read_data_MPORT = m[read.addr], clock
+      read.data <= read_data_MPORT
+    when write.en :
+      write mport MPORT = m[write.addr], clock
+      MPORT <= write.data
+
+      ; CHECK:             module [[memoryModule:[a-zA-Z0-9_]+]](
+      ; CHECK:               reg [7:0] [[memory:[a-zA-Z0-9_]+]][0:31];
+
+      ; INIT_NONE-NOT:       readmem
+
+      ; INIT_INLINE:         initial
+      ; INIT_INLINE-NEXT:      $readmemh("mem1.txt", [[memory]]);
+
+      ; INIT_OUTLINE:        /* This instance is elsewhere emitted as a bind statement.
+      ; INIT_OUTLINE-NEXT:     [[bindModule:[a-zA-Z0-9_]+]] [[bindInstance:[a-zA-Z0-9_]+]] ();
+      ; INIT_OUTLINE-NEXT;   */
+      ; INIT_OUTLINE:        endmodule
+      ;
+      ; INIT_OUTLINE:      FILE "m_combMem_init.sv"
+      ; INIT_OUTLINE-NOT:  FILE
+      ; INIT_OUTLINE:      module [[bindModule]]();
+      ; INIT_OUTLINE:        initial
+      ; INIT_OUTLINE-NEXT:     $readmemb("mem2.txt", [[memoryModule]].[[memory]]);
+      ; INIT_OUTLINE:      endmodule
+      ;
+      ; INIT_OUTLINE:      bind [[memoryModule]] [[bindModule]] [[bindInstance]] ();
diff --git a/test/Dialect/FIRRTL/SFCTests/load-memory-from-file.fir.inline.anno.json b/test/Dialect/FIRRTL/SFCTests/load-memory-from-file.fir.inline.anno.json
new file mode 100644
index 000000000..1d5c323e9
--- /dev/null
+++ b/test/Dialect/FIRRTL/SFCTests/load-memory-from-file.fir.inline.anno.json
@@ -0,0 +1,8 @@
+[
+  {
+    "class": "firrtl.annotations.MemoryFileInlineAnnotation",
+    "target": "~Foo|Foo>m",
+    "filename": "mem1.txt",
+    "hexOrBinary": "h"
+  }
+]
diff --git a/test/Dialect/FIRRTL/SFCTests/load-memory-from-file.fir.outline.anno.json b/test/Dialect/FIRRTL/SFCTests/load-memory-from-file.fir.outline.anno.json
new file mode 100644
index 000000000..4665fc146
--- /dev/null
+++ b/test/Dialect/FIRRTL/SFCTests/load-memory-from-file.fir.outline.anno.json
@@ -0,0 +1,9 @@
+[
+  {
+    "class": "firrtl.annotations.LoadMemoryAnnotation",
+    "target": "Foo.Foo.m",
+    "fileName": "mem2.txt",
+    "hexOrBinary": "b",
+    "originalMemoryNameOpt": "m"
+  }
+]
diff --git a/test/Dialect/FIRRTL/annotations.mlir b/test/Dialect/FIRRTL/annotations.mlir
index 5ded46090..9d47df082 100644
--- a/test/Dialect/FIRRTL/annotations.mlir
+++ b/test/Dialect/FIRRTL/annotations.mlir
@@ -1749,3 +1749,80 @@ firrtl.circuit "Top"  attributes {rawAnnotations = [{
     // CHECK:  firrtl.ref.resolve %[[localparam__gen_ref]] : !firrtl.ref<uint<1>>
   }
 }
+
+// -----
+
+// Test memory initialization setting.
+// CHECK-LABEL: firrtl.circuit "MemoryInitializationAnnotations"
+firrtl.circuit "MemoryInitializationAnnotations" attributes {
+  rawAnnotations = [
+    {
+      class = "firrtl.annotations.LoadMemoryAnnotation",
+      fileName = "mem1.txt",
+      hexOrBinary = "b",
+      originalMemoryNameOpt = "m",
+      target = "~MemoryInitializationAnnotations|MemoryInitializationAnnotations>m1"
+    },
+    {
+      class = "firrtl.annotations.MemoryFileInlineAnnotation",
+      filename = "mem2.txt",
+      hexOrBinary = "h",
+      target = "~MemoryInitializationAnnotations|MemoryInitializationAnnotations>m2"
+    },
+    {
+      class = "firrtl.annotations.LoadMemoryAnnotation",
+      fileName = "mem3.txt",
+      hexOrBinary = "b",
+      originalMemoryNameOpt = "m",
+      target = "~MemoryInitializationAnnotations|MemoryInitializationAnnotations>m3"
+    },
+    {
+      class = "firrtl.annotations.MemoryFileInlineAnnotation",
+      filename = "mem4.txt",
+      hexOrBinary = "h",
+      target = "~MemoryInitializationAnnotations|MemoryInitializationAnnotations>m4"
+    },
+    {
+      class = "firrtl.annotations.LoadMemoryAnnotation",
+      fileName = "mem5.txt",
+      hexOrBinary = "b",
+      originalMemoryNameOpt = "m",
+      target = "~MemoryInitializationAnnotations|MemoryInitializationAnnotations>m5"
+    },
+    {
+      class = "firrtl.annotations.MemoryFileInlineAnnotation",
+      filename = "mem6.txt",
+      hexOrBinary = "h",
+      target = "~MemoryInitializationAnnotations|MemoryInitializationAnnotations>m6"
+    }
+  ]
+} {
+  firrtl.module @MemoryInitializationAnnotations() {
+    // CHECK:      %m1_r = firrtl.mem
+    // CHECK-SAME:   #firrtl.meminit<"mem1.txt", true, false>
+    %m1_r = firrtl.mem Undefined {
+      depth = 2 : i64,
+      name = "m1",
+      portNames = ["r"],
+      readLatency = 1 : i32,
+      writeLatency = 1 : i32
+    } : !firrtl.bundle<addr: uint<1>, en: uint<1>, clk: clock, data flip: uint<8>>
+    // CHECK-NEXT: %m2_r = firrtl.mem
+    // CHECK-SAME:   #firrtl.meminit<"mem2.txt", false, true>
+    %m2_r = firrtl.mem Undefined {
+      depth = 2 : i64,
+      name = "m2",
+      portNames = ["r"],
+      readLatency = 1 : i32,
+      writeLatency = 1 : i32
+    } : !firrtl.bundle<addr: uint<1>, en: uint<1>, clk: clock, data flip: uint<8>>
+    // CHECK-NEXT: %m3 = chirrtl.seqmem Undefined {init = #firrtl.meminit<"mem3.txt", true, false>}
+    %m3 = chirrtl.seqmem Undefined : !chirrtl.cmemory<uint<8>, 32>
+    // CHECK-NEXT: %m4 = chirrtl.seqmem Undefined {init = #firrtl.meminit<"mem4.txt", false, true>}
+    %m4 = chirrtl.seqmem Undefined : !chirrtl.cmemory<uint<8>, 32>
+    // CHECK-NEXT: %m5 = chirrtl.combmem {init = #firrtl.meminit<"mem5.txt", true, false>}
+    %m5 = chirrtl.combmem : !chirrtl.cmemory<uint<8>, 32>
+    // CHECK-NEXT: %m6 = chirrtl.combmem {init = #firrtl.meminit<"mem6.txt", false, true>}
+    %m6 = chirrtl.combmem : !chirrtl.cmemory<uint<8>, 32>
+  }
+}
diff --git a/test/Dialect/FIRRTL/canonicalization.mlir b/test/Dialect/FIRRTL/canonicalization.mlir
index 73c46e0ab..69605fa62 100644
--- a/test/Dialect/FIRRTL/canonicalization.mlir
+++ b/test/Dialect/FIRRTL/canonicalization.mlir
@@ -2553,4 +2553,38 @@ firrtl.module @CrashRegResetWithOneReset(in %clock: !firrtl.clock, in %reset: !f
   firrtl.connect %io_q, %reg : !firrtl.uint<1>, !firrtl.uint<1>
 }
 
+// A read-only memory with memory initialization should not be removed.
+// CHECK-LABEL: firrtl.module @ReadOnlyFileInitialized
+firrtl.module @ReadOnlyFileInitialized(
+  in %clock: !firrtl.clock,
+  in %reset: !firrtl.uint<1>,
+  in %read_en: !firrtl.uint<1>,
+  out %read_data: !firrtl.uint<8>,
+  in %read_addr: !firrtl.uint<5>
+) {
+  // CHECK-NEXT: firrtl.mem
+  // CHECK-SAME:   name = "withInit"
+  %m_r = firrtl.mem Undefined {
+    depth = 32 : i64,
+    groupID = 1 : ui32,
+    init = #firrtl.meminit<"mem1.hex.txt", false, true>,
+    name = "withInit",
+    portNames = ["m_r"],
+    readLatency = 1 : i32,
+    writeLatency = 1 : i32
+  } : !firrtl.bundle<addr: uint<5>, en: uint<1>, clk: clock, data flip: uint<8>>
+  %0 = firrtl.subfield %m_r[addr] :
+    !firrtl.bundle<addr: uint<5>, en: uint<1>, clk: clock, data flip: uint<8>>
+  %1 = firrtl.subfield %m_r[en] :
+    !firrtl.bundle<addr: uint<5>, en: uint<1>, clk: clock, data flip: uint<8>>
+  %2 = firrtl.subfield %m_r[clk] :
+    !firrtl.bundle<addr: uint<5>, en: uint<1>, clk: clock, data flip: uint<8>>
+  %3 = firrtl.subfield %m_r[data] :
+    !firrtl.bundle<addr: uint<5>, en: uint<1>, clk: clock, data flip: uint<8>>
+  firrtl.strictconnect %0, %read_addr : !firrtl.uint<5>
+  firrtl.strictconnect %1, %read_en : !firrtl.uint<1>
+  firrtl.strictconnect %2, %clock : !firrtl.clock
+  firrtl.strictconnect %read_data, %3 : !firrtl.uint<8>
+}
+
 }
diff --git a/test/Dialect/FIRRTL/dedup-locations.mlir b/test/Dialect/FIRRTL/dedup-locations.mlir
index be5148f1d..0a9305983 100644
--- a/test/Dialect/FIRRTL/dedup-locations.mlir
+++ b/test/Dialect/FIRRTL/dedup-locations.mlir
@@ -16,3 +16,52 @@ firrtl.module @Test() {
   firrtl.instance dedup1 @Dedup1()
 }
 }
+
+// CHECK-LABEL: "PortLocations"
+firrtl.circuit "PortLocations" {
+// CHECK: firrtl.module @PortLocs0(in %in: !firrtl.uint<1> loc(fused["1", "2"]))
+firrtl.module @PortLocs0(in %in : !firrtl.uint<1> loc("1")) { }
+firrtl.module @PortLocs1(in %in : !firrtl.uint<1> loc("2")) { }
+firrtl.module @PortLocations() {
+  firrtl.instance portLocs0 @PortLocs0(in in : !firrtl.uint<1>)
+  firrtl.instance portLocs1 @PortLocs1(in in : !firrtl.uint<1>)
+}
+}
+
+// Check that locations are limited.
+// CHECK-LABEL: firrtl.circuit "LimitLoc"
+firrtl.circuit "LimitLoc" {
+  // CHECK: firrtl.module @Simple0()
+  // CHECK-NEXT: loc(fused["A.fir":0:1, "A.fir":1:1, "A.fir":2:1, "A.fir":3:1, "A.fir":4:1, "A.fir":5:1, "A.fir":6:1, "A.fir":7:1])
+  firrtl.module @Simple0() { } loc("A.fir":0:1)
+  // CHECK-NOT: @Simple1
+  firrtl.module @Simple1() { } loc("A.fir":1:1)
+  // CHECK-NOT: @Simple2
+  firrtl.module @Simple2() { } loc("A.fir":2:1)
+  // CHECK-NOT: @Simple3
+  firrtl.module @Simple3() { } loc("A.fir":3:1)
+  // CHECK-NOT: @Simple4
+  firrtl.module @Simple4() { } loc("A.fir":4:1)
+  // CHECK-NOT: @Simple5
+  firrtl.module @Simple5() { } loc("A.fir":5:1)
+  // CHECK-NOT: @Simple6
+  firrtl.module @Simple6() { } loc("A.fir":6:1)
+  // CHECK-NOT: @Simple7
+  firrtl.module @Simple7() { } loc("A.fir":7:1)
+  // CHECK-NOT: @Simple8
+  firrtl.module @Simple8() { } loc("A.fir":8:1)
+  // CHECK-NOT: @Simple9
+  firrtl.module @Simple9() { } loc("A.fir":9:1)
+  firrtl.module @LimitLoc() {
+    firrtl.instance simple0 @Simple0()
+    firrtl.instance simple1 @Simple1()
+    firrtl.instance simple2 @Simple2()
+    firrtl.instance simple3 @Simple3()
+    firrtl.instance simple4 @Simple4()
+    firrtl.instance simple5 @Simple5()
+    firrtl.instance simple6 @Simple6()
+    firrtl.instance simple7 @Simple7()
+    firrtl.instance simple8 @Simple8()
+    firrtl.instance simple9 @Simple9()
+  }
+}
diff --git a/test/Dialect/FIRRTL/dedup.mlir b/test/Dialect/FIRRTL/dedup.mlir
index fa640bad7..a89bfc95d 100644
--- a/test/Dialect/FIRRTL/dedup.mlir
+++ b/test/Dialect/FIRRTL/dedup.mlir
@@ -1,4 +1,4 @@
-// RUN: circt-opt --pass-pipeline='builtin.module(firrtl.circuit(firrtl-dedup))' %s -mlir-print-debuginfo | FileCheck %s
+// RUN: circt-opt --pass-pipeline='builtin.module(firrtl.circuit(firrtl-dedup))' %s | FileCheck %s
 
 // CHECK-LABEL: firrtl.circuit "Empty"
 firrtl.circuit "Empty" {
@@ -628,61 +628,3 @@ firrtl.circuit "Foo"  {
     firrtl.instance y1 @Y()
   }
 }
-
-
-// Check that locations are limited.
-// CHECK-LABEL: firrtl.circuit "LimitLoc"
-firrtl.circuit "LimitLoc" {
-  // CHECK: @Simple0
-  // CHECK-NEXT: loc(#loc[[num:.+]])
-  firrtl.module @Simple0() { } loc(#loc0)
-  // CHECK-NOT: @Simple1
-  firrtl.module @Simple1() { } loc(#loc1)
-  // CHECK-NOT: @Simple2
-  firrtl.module @Simple2() { } loc(#loc2)
-  // CHECK-NOT: @Simple3
-  firrtl.module @Simple3() { } loc(#loc3)
-  // CHECK-NOT: @Simple4
-  firrtl.module @Simple4() { } loc(#loc4)
-  // CHECK-NOT: @Simple5
-  firrtl.module @Simple5() { } loc(#loc5)
-  // CHECK-NOT: @Simple6
-  firrtl.module @Simple6() { } loc(#loc6)
-  // CHECK-NOT: @Simple7
-  firrtl.module @Simple7() { } loc(#loc7)
-  // CHECK-NOT: @Simple8
-  firrtl.module @Simple8() { } loc(#loc8)
-  // CHECK-NOT: @Simple9
-  firrtl.module @Simple9() { } loc(#loc9)
-  firrtl.module @LimitLoc() {
-    firrtl.instance simple0 @Simple0()
-    firrtl.instance simple1 @Simple1()
-    firrtl.instance simple2 @Simple2()
-    firrtl.instance simple3 @Simple3()
-    firrtl.instance simple4 @Simple4()
-    firrtl.instance simple5 @Simple5()
-    firrtl.instance simple6 @Simple6()
-    firrtl.instance simple7 @Simple7()
-    firrtl.instance simple8 @Simple8()
-    firrtl.instance simple9 @Simple9()
-  }
-}
-  #loc0 = loc("A.fir":0:1)
-  #loc1 = loc("A.fir":1:1)
-  #loc2 = loc("A.fir":2:1)
-  #loc3 = loc("A.fir":3:1)
-  #loc4 = loc("A.fir":4:1)
-  #loc5 = loc("A.fir":5:1)
-  #loc6 = loc("A.fir":6:1)
-  #loc7 = loc("A.fir":7:1)
-  #loc8 = loc("A.fir":8:1)
-  #loc9 = loc("A.fir":9:1)
-// CHECK: [[L1:#loc.*]] = loc("A.fir":0:1)
-// CHECK: [[L2:#loc.*]] = loc("A.fir":1:1)
-// CHECK: [[L3:#loc.*]] = loc("A.fir":2:1)
-// CHECK: [[L4:#loc.*]] = loc("A.fir":3:1)
-// CHECK: [[L5:#loc.*]] = loc("A.fir":4:1)
-// CHECK: [[L6:#loc.*]] = loc("A.fir":5:1)
-// CHECK: [[L7:#loc.*]] = loc("A.fir":6:1)
-// CHECK: [[L8:#loc.*]] = loc("A.fir":7:1)
-// CHECK: #loc[[num]] = loc(fused[[[L1]], [[L2]], [[L3]], [[L4]], [[L5]], [[L6]], [[L7]], [[L8]]])
diff --git a/test/Dialect/FIRRTL/errors.mlir b/test/Dialect/FIRRTL/errors.mlir
index 5d044a625..7fae65d5f 100644
--- a/test/Dialect/FIRRTL/errors.mlir
+++ b/test/Dialect/FIRRTL/errors.mlir
@@ -93,6 +93,29 @@ firrtl.circuit "foo" {
     portNames = ["in0"], portAnnotations = [], portSyms = []} : () -> ()
 }
 
+// -----
+
+firrtl.circuit "foo" {
+// expected-error @+1 {{requires valid port locations}}
+"firrtl.module"() ( {
+  ^entry:
+}) {sym_name = "foo", portTypes = [!firrtl.uint], portDirections = 1 : i1,
+    portNames = ["in0"], portAnnotations = [], portSyms = []} : () -> ()
+}
+
+// -----
+
+firrtl.circuit "foo" {
+// expected-error @+1 {{requires 1 port locations}}
+"firrtl.module"() ( {
+  ^entry:
+}) {sym_name = "foo", portTypes = [!firrtl.uint], portDirections = 1 : i1,
+    portNames = ["in0"], portAnnotations = [], portSyms = [],
+    portLocations = []} : () -> ()
+}
+
+
+
 
 // -----
 
@@ -101,7 +124,8 @@ firrtl.circuit "foo" {
 "firrtl.module"() ( {
   ^entry:
 }) {sym_name = "foo", portTypes = [!firrtl.uint], portDirections = 1 : i1,
-    portNames = ["in0"], portAnnotations = [], portSyms = []} : () -> ()
+    portNames = ["in0"], portAnnotations = [], portSyms = [],
+    portLocations = [loc("loc")]} : () -> ()
 }
 
 // -----
@@ -111,7 +135,8 @@ firrtl.circuit "foo" {
 "firrtl.module"() ( {
   ^entry(%a: i1):
 }) {sym_name = "foo", portTypes = [!firrtl.uint], portDirections = 1 : i1,
-    portNames = ["in0"], portAnnotations = [], portSyms = []} : () -> ()
+    portNames = ["in0"], portAnnotations = [], portSyms = [],
+    portLocations = [loc("foo")]} : () -> ()
 }
 
 // -----
diff --git a/test/Dialect/FIRRTL/legacy-wiring-errors.mlir b/test/Dialect/FIRRTL/legacy-wiring-errors.mlir
new file mode 100644
index 000000000..e132c3e21
--- /dev/null
+++ b/test/Dialect/FIRRTL/legacy-wiring-errors.mlir
@@ -0,0 +1,61 @@
+// RUN: circt-opt --pass-pipeline='builtin.module(firrtl.circuit(firrtl-lower-annotations))' -split-input-file %s -verify-diagnostics
+
+// Every Wiring pin must have exactly one defined source
+//
+// expected-error @+1 {{Unable to resolve source for pin: "foo_out"}}
+firrtl.circuit "Foo" attributes {
+  rawAnnotations = [
+    {
+      class = "firrtl.passes.wiring.SinkAnnotation",
+      target = "Foo.Foo.out",
+      pin = "foo_out"
+    }]} {
+  firrtl.module @Foo(out %out: !firrtl.uint<1>) {
+      firrtl.skip
+  }
+}
+
+// -----
+
+// Every Wiring pin must have at least one defined sink
+//
+// expected-error @+1 {{Unable to resolve sink(s) for pin: "foo_in"}}
+firrtl.circuit "Foo" attributes {
+  rawAnnotations = [
+    {
+      class = "firrtl.passes.wiring.SourceAnnotation",
+      target = "Foo.Foo.in",
+      pin = "foo_in"
+    }]} {
+  firrtl.module @Foo(in %in: !firrtl.uint<1>) {
+      firrtl.skip
+  }
+}
+
+// -----
+
+// Multiple SourceAnnotations for the same pin are forbidden
+//
+// expected-error @+2 {{Unable to apply annotation: {class = "firrtl.passes.wiring.SourceAnnotation", pin = "foo_out", target = "Foo.Foo.b"}}}
+// expected-error @+1 {{More than one firrtl.passes.wiring.SourceAnnotation defined for pin "foo_out"}}
+firrtl.circuit "Foo" attributes {
+  rawAnnotations = [
+    {
+      class = "firrtl.passes.wiring.SinkAnnotation",
+      target = "Foo.Foo.out",
+      pin = "foo_out"
+    },
+    {
+      class = "firrtl.passes.wiring.SourceAnnotation",
+      target = "Foo.Foo.a",
+      pin = "foo_out"
+    },
+    {
+      class = "firrtl.passes.wiring.SourceAnnotation",
+      target = "Foo.Foo.b",
+      pin = "foo_out"
+    }]} {
+  firrtl.module @Foo(in %a: !firrtl.uint<1>, in %b: !firrtl.uint<1>, out %out: !firrtl.uint<1>) {
+      firrtl.skip
+  }
+}
diff --git a/test/Dialect/FIRRTL/legacy-wiring.mlir b/test/Dialect/FIRRTL/legacy-wiring.mlir
new file mode 100644
index 000000000..28507d6bf
--- /dev/null
+++ b/test/Dialect/FIRRTL/legacy-wiring.mlir
@@ -0,0 +1,117 @@
+// RUN: circt-opt --pass-pipeline='builtin.module(firrtl.circuit(firrtl-lower-annotations))' --split-input-file %s | FileCheck %s
+
+// Check added ports are real type
+// CHECK-LABEL: firrtl.circuit "FooBar"
+firrtl.circuit "FooBar" attributes {
+  rawAnnotations = [
+    {
+      class = "firrtl.passes.wiring.SinkAnnotation",
+      target = "FooBar.Foo.io.out",
+      pin = "foo_out"
+    },
+    {
+      class = "firrtl.passes.wiring.SourceAnnotation",
+      target = "FooBar.FooBar.io.in",
+      pin = "foo_out"
+    }]} {
+  // CHECK: firrtl.module @Foo
+  // The real port type of the source should be bored
+  // CHECK-SAME: in %io_out__bore: !firrtl.uint<1>
+  firrtl.module@Foo(out %io: !firrtl.bundle<out: uint<1>>) {
+      firrtl.skip
+  }
+  // CHECK: firrtl.module @Bar
+  // The real port type of the source should be bored in the parent
+  // CHECK-SAME: in %foo_io_out__bore: !firrtl.uint<1>
+  firrtl.module @Bar(out %io: !firrtl.bundle<out: uint<1>>) {
+      %0 = firrtl.subfield %io[out] : !firrtl.bundle<out: uint<1>>
+      // CHECK: firrtl.instance foo
+      // CHECK-SAME: in io_out__bore: !firrtl.uint<1>
+      %foo_io = firrtl.instance foo interesting_name  @Foo(out io: !firrtl.bundle<out: uint<1>>)
+      %1 = firrtl.subfield %foo_io[out] : !firrtl.bundle<out: uint<1>>
+      firrtl.strictconnect %0, %1 : !firrtl.uint<1>
+  }
+  // CHECK: firrtl.module @FooBar
+  firrtl.module @FooBar(out %io: !firrtl.bundle<in flip: uint<1>, out: uint<1>>) {
+      %0 = firrtl.subfield %io[out] : !firrtl.bundle<in flip: uint<1>, out: uint<1>>
+      // CHECK: firrtl.instance bar
+      // CHECK-SAME: in foo_io_out__bore: !firrtl.uint<1>
+      %bar_io = firrtl.instance bar interesting_name  @Bar(out io: !firrtl.bundle<out: uint<1>>)
+      %1 = firrtl.subfield %bar_io[out] : !firrtl.bundle<out: uint<1>>
+      firrtl.strictconnect %0, %1 : !firrtl.uint<1>
+  }
+}
+
+// -----
+
+// Test the behaviour of single source, multiple sink
+// CHECK-LABEL: firrtl.circuit "FooBar"
+firrtl.circuit "FooBar" attributes {
+  rawAnnotations = [
+    {
+      class = "firrtl.passes.wiring.SourceAnnotation",
+      target = "FooBar.FooBar.io.in",
+      pin = "in"
+    },
+    {
+      class = "firrtl.passes.wiring.SinkAnnotation",
+      target = "FooBar.Foo.io.out",
+      pin = "in"
+    },
+    {
+      class = "firrtl.passes.wiring.SinkAnnotation",
+      target = "FooBar.Foo_1.io.out",
+      pin = "in"
+    },
+    {
+      class = "firrtl.passes.wiring.SinkAnnotation",
+      target = "FooBar.Bar.io.out",
+      pin = "in"
+    }]} {
+  // CHECK: firrtl.module @Foo
+  // CHECK-SAME: in %io_out__bore: !firrtl.uint<1>
+  firrtl.module @Foo(out %io: !firrtl.bundle<out: uint<1>>) {
+    firrtl.skip
+    // CHECK: %0 = firrtl.subfield %io[out] : !firrtl.bundle<out: uint<1>>
+    // CHECK: firrtl.connect %0, %io_out__bore : !firrtl.uint<1>, !firrtl.uint<1>
+  }
+  // CHECK: firrtl.module @Foo_1
+  // CHECK-SAME: in %io_out__bore: !firrtl.uint<1>
+  firrtl.module @Foo_1(out %io: !firrtl.bundle<out: uint<1>>) {
+    firrtl.skip
+    // CHECK: %0 = firrtl.subfield %io[out] : !firrtl.bundle<out: uint<1>>
+    // CHECK: firrtl.connect %0, %io_out__bore : !firrtl.uint<1>, !firrtl.uint<1>
+  }
+  // CHECK: firrtl.module @Bar
+  // CHECK-SAME: in %io_out__bore: !firrtl.uint<1>
+  firrtl.module @Bar(out %io: !firrtl.bundle<out: uint<1>>) {
+    firrtl.skip
+    // CHECK: %0 = firrtl.subfield %io[out] : !firrtl.bundle<out: uint<1>>
+    // CHECK: firrtl.connect %0, %io_out__bore : !firrtl.uint<1>, !firrtl.uint<1>
+  }
+  // CHECK: firrtl.module @FooBar
+  firrtl.module @FooBar(out %io: !firrtl.bundle<in flip: uint<1>, out_foo0: uint<1>, out_foo1: uint<1>, out_bar: uint<1>>) {
+    // CHECK: %0 = firrtl.subfield %io[in] : !firrtl.bundle<in flip: uint<1>, out_foo0: uint<1>, out_foo1: uint<1>, out_bar: uint<1>>
+    %0 = firrtl.subfield %io[out_bar] : !firrtl.bundle<in flip: uint<1>, out_foo0: uint<1>, out_foo1: uint<1>, out_bar: uint<1>>
+    %1 = firrtl.subfield %io[out_foo1] : !firrtl.bundle<in flip: uint<1>, out_foo0: uint<1>, out_foo1: uint<1>, out_bar: uint<1>>
+    %2 = firrtl.subfield %io[out_foo0] : !firrtl.bundle<in flip: uint<1>, out_foo0: uint<1>, out_foo1: uint<1>, out_bar: uint<1>>
+    // CHECK: firrtl.instance foo0
+    // CHECK-SAME: in io_out__bore: !firrtl.uint<1>
+    %foo0_io = firrtl.instance foo0 interesting_name  @Foo(out io: !firrtl.bundle<out: uint<1>>)
+    %3 = firrtl.subfield %foo0_io[out] : !firrtl.bundle<out: uint<1>>
+    // CHECK: firrtl.instance foo1
+    // CHECK-SAME: in io_out__bore: !firrtl.uint<1>
+    %foo1_io = firrtl.instance foo1 interesting_name  @Foo_1(out io: !firrtl.bundle<out: uint<1>>)
+    %4 = firrtl.subfield %foo1_io[out] : !firrtl.bundle<out: uint<1>>
+    // CHECK: firrtl.instance bar
+    // CHECK-SAME: in io_out__bore: !firrtl.uint<1>
+    %bar_io = firrtl.instance bar interesting_name  @Bar(out io: !firrtl.bundle<out: uint<1>>)
+    %5 = firrtl.subfield %bar_io[out] : !firrtl.bundle<out: uint<1>>
+    firrtl.strictconnect %2, %3 : !firrtl.uint<1>
+    firrtl.strictconnect %1, %4 : !firrtl.uint<1>
+    firrtl.strictconnect %0, %5 : !firrtl.uint<1>
+    // CHECK: firrtl.connect %foo0_io_out__bore, %0 : !firrtl.uint<1>, !firrtl.uint<1>
+    // CHECK: firrtl.connect %foo1_io_out__bore, %0 : !firrtl.uint<1>, !firrtl.uint<1>
+    // CHECK: firrtl.connect %bar_io_out__bore, %0 : !firrtl.uint<1>, !firrtl.uint<1>
+  }
+}
diff --git a/test/Dialect/FIRRTL/parse-basic.fir b/test/Dialect/FIRRTL/parse-basic.fir
index cb3917907..636ec847f 100644
--- a/test/Dialect/FIRRTL/parse-basic.fir
+++ b/test/Dialect/FIRRTL/parse-basic.fir
@@ -280,7 +280,7 @@ circuit MyModule :     ; CHECK: firrtl.circuit "MyModule" {
     ; CHECK: firrtl.printf %clock, %reset, "Something interesting!\0A %x %x" (%_t, %_t_2) : !firrtl.vector<uint<1>, 12>, !firrtl.vector<uint<1>, 12>
     printf(clock, reset, "Something interesting!\n %x %x", _t, _t_2)
 
-    ; CHECK: firrtl.printf %clock, %reset, "Something interesting!\0A %x %x" {name = "printf_0"}(%_t, %_t_2) : !firrtl.vector<uint<1>, 12>, !firrtl.vector<uint<1>, 12>
+    ; CHECK: firrtl.printf %clock, %reset, "Something interesting!\0A %x %x" {name = "printf_0"} (%_t, %_t_2) : !firrtl.vector<uint<1>, 12>, !firrtl.vector<uint<1>, 12>
     printf(clock, reset, "Something interesting!\n %x %x", _t, _t_2) : printf_0
 
     ; CHECK: firrtl.stop %clock, %reset, 42
diff --git a/test/Dialect/FIRRTL/parse-locations.fir b/test/Dialect/FIRRTL/parse-locations.fir
index dddc93f2e..08fea9a20 100644
--- a/test/Dialect/FIRRTL/parse-locations.fir
+++ b/test/Dialect/FIRRTL/parse-locations.fir
@@ -2,10 +2,13 @@
 
 circuit MyModule :  @[CIRCUIT.scala 127]
 
-  ; CHECK-LABEL: firrtl.module @MyModule(in %in: !firrtl.uint, out %out: !firrtl.uint<8>) {
+  ; CHECK-LABEL: firrtl.module @MyModule(
+  ; CHECK-SAME:    in %in: !firrtl.uint loc("InputPort.scala":0:0)
+  ; CHECK-SAME:    out %out: !firrtl.uint<8> loc("OutputPort.scala":0:0)
+  ; CHECK-SAME:  ) {
   module MyModule :   @[FooBar.scala 369:27]
-    input in: UInt
-    output out: UInt<8>
+    input in: UInt      @[InputPort.scala 0:0]
+    output out: UInt<8> @[OutputPort.scala 0:0]
 
     ; CHECK: firrtl.connect {{.*}}loc("Somewhere.galaxy":42:1)
     out <= in   @[Somewhere.galaxy 42:1]
diff --git a/test/Dialect/HW/basic.mlir b/test/Dialect/HW/basic.mlir
index e40f2b30e..d7b65a584 100644
--- a/test/Dialect/HW/basic.mlir
+++ b/test/Dialect/HW/basic.mlir
@@ -153,6 +153,11 @@ hw.module @signed_arrays(%arg0: si8) -> (out: !hw.array<2xsi8>) {
   hw.output %result : !hw.array<2xsi8>
 }
 
+// Check that we pass the verifier that the module's function type matches
+// the block argument types when using InOutTypes.
+// CHECK: hw.module @InOutPort(%arg0: !hw.inout<i1>)
+hw.module @InOutPort(%arg0: !hw.inout<i1>) -> () { }
+
 /// Port names that aren't valid MLIR identifiers are handled with `argNames`
 /// attribute being explicitly printed.
 // https://github.com/llvm/circt/issues/1822
diff --git a/test/Dialect/HW/locations.mlir b/test/Dialect/HW/locations.mlir
new file mode 100644
index 000000000..fb76b3a10
--- /dev/null
+++ b/test/Dialect/HW/locations.mlir
@@ -0,0 +1,32 @@
+// RUN: circt-opt %s | circt-opt | FileCheck %s -check-prefix BASIC
+// RUN: circt-opt %s --mlir-print-debuginfo | circt-opt --mlir-print-debuginfo --mlir-print-local-scope | FileCheck %s -check-prefix DEBUG
+
+// Basic IR parser+printer round tripping test. The debug locations should only
+// be printed when the required, and they should be accurately parsed back in.
+
+hw.module @test0(%input: i7) -> (output: i7) { hw.output %input : i7 }
+hw.module @test1(%input: i7 {hw.arg = "arg"}) -> (output: i7 {hw.res = "res"}) { hw.output %input : i7 }
+hw.module @test2(%input: i7 loc("arg")) -> (output: i7 loc("res")) { hw.output %input : i7 }
+hw.module @test3(%input: i7 {hw.arg = "arg"} loc("arg")) -> (output: i7 {hw.res = "res"} loc("res")) { hw.output %input : i7 }
+hw.module.extern @test4(%input: i7) -> (output: i7)
+hw.module.extern @test5(%input: i7 {hw.arg = "arg"}) -> (output: i7 {hw.res = "res"})
+hw.module.extern @test6(%input: i7 loc("arg")) -> (output: i7 loc("res"))
+hw.module.extern @test7(%input: i7 {hw.arg = "arg"} loc("arg")) -> (output: i7 {hw.res = "res"} loc("res"))
+
+// BASIC: hw.module @test0(%input: i7) -> (output: i7)
+// BASIC: hw.module @test1(%input: i7 {hw.arg = "arg"}) -> (output: i7 {hw.res = "res"})
+// BASIC: hw.module @test2(%input: i7) -> (output: i7)
+// BASIC: hw.module @test3(%input: i7 {hw.arg = "arg"}) -> (output: i7 {hw.res = "res"})
+// BASIC: hw.module.extern @test4(%input: i7) -> (output: i7)
+// BASIC: hw.module.extern @test5(%input: i7 {hw.arg = "arg"}) -> (output: i7 {hw.res = "res"})
+// BASIC: hw.module.extern @test6(%input: i7) -> (output: i7)
+// BASIC: hw.module.extern @test7(%input: i7 {hw.arg = "arg"}) -> (output: i7 {hw.res = "res"})
+
+// DEBUG: hw.module @test0(%input: i7 loc({{.+}})) -> (output: i7 loc({{.+}}))
+// DEBUG: hw.module @test1(%input: i7 {hw.arg = "arg"} loc({{.+}})) -> (output: i7 {hw.res = "res"} loc({{.+}}))
+// DEBUG: hw.module @test2(%input: i7 loc("arg")) -> (output: i7 loc("res"))
+// DEBUG: hw.module @test3(%input: i7 {hw.arg = "arg"} loc("arg")) -> (output: i7 {hw.res = "res"} loc("res"))
+// DEBUG: hw.module.extern @test4(%input: i7 loc({{.+}})) -> (output: i7 loc({{.+}}))
+// DEBUG: hw.module.extern @test5(%input: i7 {hw.arg = "arg"} loc({{.+}})) -> (output: i7 {hw.res = "res"} loc({{.+}}))
+// DEBUG: hw.module.extern @test6(%input: i7 loc("arg")) -> (output: i7 loc("res"))
+// DEBUG: hw.module.extern @test7(%input: i7 {hw.arg = "arg"} loc("arg")) -> (output: i7 {hw.res = "res"} loc("res"))
\ No newline at end of file
diff --git a/test/Dialect/SV/basic.mlir b/test/Dialect/SV/basic.mlir
index 879d0eeb0..f55cb055d 100644
--- a/test/Dialect/SV/basic.mlir
+++ b/test/Dialect/SV/basic.mlir
@@ -270,13 +270,13 @@ hw.module @test1(%arg0: i1, %arg1: i1, %arg8: i8) {
   // Tests for ReadMemOp ($readmemb/$readmemh)
   // CHECK-NEXT: sv.initial {
   // CHECK-NEXT:   %memForReadMem = sv.reg
-  // CHECK-NEXT:   sv.readmem @MemForReadMem, "file1.txt", MemBaseBin
-  // CHECK-NEXT:   sv.readmem @MemForReadMem, "file2.txt", MemBaseHex
+  // CHECK-NEXT:   sv.readmem %memForReadMem, "file1.txt", MemBaseBin
+  // CHECK-NEXT:   sv.readmem %memForReadMem, "file2.txt", MemBaseHex
   // CHECK-NEXT: }
   sv.initial {
     %memForReadMem = sv.reg sym @MemForReadMem : !hw.inout<uarray<8xi32>>
-    sv.readmem @MemForReadMem, "file1.txt", MemBaseBin
-    sv.readmem @MemForReadMem, "file2.txt", MemBaseHex
+    sv.readmem %memForReadMem, "file1.txt", MemBaseBin : !hw.inout<uarray<8xi32>>
+    sv.readmem %memForReadMem, "file2.txt", MemBaseHex : !hw.inout<uarray<8xi32>>
   }
 
   // CHECK-NEXT: hw.output
diff --git a/test/Dialect/SV/hw-legalize-modules-packed-arrays.mlir b/test/Dialect/SV/hw-legalize-modules-packed-arrays.mlir
index b1030bb25..682d2c702 100644
--- a/test/Dialect/SV/hw-legalize-modules-packed-arrays.mlir
+++ b/test/Dialect/SV/hw-legalize-modules-packed-arrays.mlir
@@ -1,8 +1,6 @@
-// RUN: circt-opt -hw-legalize-modules -verify-diagnostics %s | FileCheck %s
+// RUN: circt-opt -split-input-file -hw-legalize-modules -verify-diagnostics %s | FileCheck %s
 
 module attributes {circt.loweringOptions = "disallowPackedArrays"} {
-
-// CHECK-LABEL: hw.module @reject_arrays
 hw.module @reject_arrays(%arg0: i8, %arg1: i8, %arg2: i8,
                          %arg3: i8, %sel: i2, %clock: i1)
    -> (a: !hw.array<4xi8>) {
@@ -19,7 +17,10 @@ hw.module @reject_arrays(%arg0: i8, %arg1: i8, %arg2: i8,
   %1 = sv.read_inout %reg : !hw.inout<array<4xi8>>
   hw.output %1 : !hw.array<4xi8>
 }
+}
 
+// -----
+module attributes {circt.loweringOptions = "disallowPackedArrays"} {
 // CHECK-LABEL: hw.module @array_create_get_comb
 hw.module @array_create_get_comb(%arg0: i8, %arg1: i8, %arg2: i8, %arg3: i8,
                                  %sel: i2)
@@ -83,4 +84,31 @@ hw.module @array_create_get_default(%arg0: i8, %arg1: i8, %arg2: i8, %arg3: i8,
   }
 }
 
+// CHECK-LABEL: hw.module @array_constant_get_comb
+hw.module @array_constant_get_comb(%sel: i2)
+   -> (a: i8) {
+  // CHECK: %casez_tmp = sv.reg  : !hw.inout<i8>
+  // CHECK: sv.alwayscomb  {
+  // CHECK:   sv.case casez %sel : i2
+  // CHECK:   case b00: {
+  // CHECK:     sv.bpassign %casez_tmp, %c3_i8 : i8
+  // CHECK:   }
+  // CHECK:   case b01: {
+  // CHECK:     sv.bpassign %casez_tmp, %c2_i8 : i8
+  // CHECK:   }
+  // CHECK:   case b10: {
+  // CHECK:     sv.bpassign %casez_tmp, %c1_i8 : i8
+  // CHECK:   }
+  // CHECK:   default: {
+  // CHECK:     sv.bpassign %casez_tmp, %c0_i8 : i8
+  // CHECK:   }
+  // CHECK: }
+  %0 = hw.aggregate_constant [0 : i8, 1 : i8, 2 : i8, 3 : i8] : !hw.array<4xi8>
+  // CHECK: %0 = sv.read_inout %casez_tmp : !hw.inout<i8>
+  %1 = hw.array_get %0[%sel] : !hw.array<4xi8>, i2
+
+  // CHECK: hw.output %0 : i8
+  hw.output %1 : i8
+}
+
 }  // end builtin.module
diff --git a/test/Dialect/SV/hw-memsim.mlir b/test/Dialect/SV/hw-memsim.mlir
index 91e449879..36d74797d 100644
--- a/test/Dialect/SV/hw-memsim.mlir
+++ b/test/Dialect/SV/hw-memsim.mlir
@@ -5,7 +5,7 @@
 // RUN: circt-opt -pass-pipeline="builtin.module(hw-memory-sim{disable-mem-randomization disable-reg-randomization})" %s | FileCheck %s --check-prefix COMMON --implicit-check-not RANDOMIZE_REG --implicit-check-not RANDOMIZE_MEM
 // RUN: circt-opt -pass-pipeline="builtin.module(hw-memory-sim{add-vivado-ram-address-conflict-synthesis-bug-workaround})" %s | FileCheck %s --check-prefixes=CHECK,COMMON,VIVADO
 
-hw.generator.schema @FIRRTLMem, "FIRRTL_Memory", ["depth", "numReadPorts", "numWritePorts", "numReadWritePorts", "readLatency", "writeLatency", "width", "readUnderWrite", "writeUnderWrite", "writeClockIDs"]
+hw.generator.schema @FIRRTLMem, "FIRRTL_Memory", ["depth", "numReadPorts", "numWritePorts", "numReadWritePorts", "readLatency", "writeLatency", "width", "readUnderWrite", "writeUnderWrite", "writeClockIDs", "initFilename", "initIsBinary", "initIsInline"]
 
 // COMMON-LABEL: @complex
 hw.module @complex(%clock: i1, %reset: i1, %r0en: i1, %mode: i1, %data0: i16) -> (data1: i16, data2: i16) {
@@ -71,7 +71,7 @@ hw.module @WriteOrderedDifferentClock(%clock: i1, %clock2: i1, %w0_addr: i4, %w0
   hw.output
 }
 
-hw.module.generated @FIRRTLMem_1_1_1_16_10_0_1_0_0, @FIRRTLMem(%ro_addr_0: i4, %ro_en_0: i1, %ro_clock_0: i1,%rw_addr_0: i4, %rw_en_0: i1,  %rw_clock_0: i1, %rw_wmode_0: i1, %rw_wdata_0: i16,  %wo_addr_0: i4, %wo_en_0: i1, %wo_clock_0: i1, %wo_data_0: i16) -> (ro_data_0: i16, rw_rdata_0: i16) attributes {depth = 10 : i64, numReadPorts = 1 : ui32, numReadWritePorts = 1 : ui32, numWritePorts = 1 : ui32, readLatency = 0 : ui32, readUnderWrite = 0 : ui32, width = 16 : ui32, writeClockIDs = [], writeLatency = 1 : ui32, writeUnderWrite = 0 : i32}
+hw.module.generated @FIRRTLMem_1_1_1_16_10_0_1_0_0, @FIRRTLMem(%ro_addr_0: i4, %ro_en_0: i1, %ro_clock_0: i1,%rw_addr_0: i4, %rw_en_0: i1,  %rw_clock_0: i1, %rw_wmode_0: i1, %rw_wdata_0: i16,  %wo_addr_0: i4, %wo_en_0: i1, %wo_clock_0: i1, %wo_data_0: i16) -> (ro_data_0: i16, rw_rdata_0: i16) attributes {depth = 10 : i64, numReadPorts = 1 : ui32, numReadWritePorts = 1 : ui32, numWritePorts = 1 : ui32, readLatency = 0 : ui32, readUnderWrite = 0 : ui32, width = 16 : ui32, writeClockIDs = [], writeLatency = 1 : ui32, writeUnderWrite = 0 : i32, initFilename = "", initIsBinary = false, initIsInline = false}
 
 //COMMON-LABEL: @FIRRTLMem_1_1_1_16_10_0_1_0_0
 //CHECK-SAME:  attributes {comment = "VCS coverage exclude_file"}
@@ -134,7 +134,7 @@ hw.module.generated @FIRRTLMem_1_1_1_16_10_0_1_0_0, @FIRRTLMem(%ro_addr_0: i4, %
 //CHECK-NEXT:  }
 //CHECK-NEXT:  hw.output %[[readres]], %[[rwres]]
 
-hw.module.generated @FIRRTLMem_1_1_1_16_10_2_4_0_0, @FIRRTLMem(%ro_addr_0: i4, %ro_en_0: i1, %ro_clock_0: i1,%rw_addr_0: i4, %rw_en_0: i1,  %rw_clock_0: i1, %rw_wmode_0: i1, %rw_wdata_0: i16, %wo_addr_0: i4, %wo_en_0: i1, %wo_clock_0: i1, %wo_data_0: i16) -> (ro_data_0: i16, rw_rdata_0: i16) attributes {depth = 10 : i64, numReadPorts = 1 : ui32, numReadWritePorts = 1 : ui32, numWritePorts = 1 : ui32, readLatency = 2 : ui32, readUnderWrite = 0 : ui32, width = 16 : ui32, writeClockIDs = [], writeLatency = 4 : ui32, writeUnderWrite = 0 : i32}
+hw.module.generated @FIRRTLMem_1_1_1_16_10_2_4_0_0, @FIRRTLMem(%ro_addr_0: i4, %ro_en_0: i1, %ro_clock_0: i1,%rw_addr_0: i4, %rw_en_0: i1,  %rw_clock_0: i1, %rw_wmode_0: i1, %rw_wdata_0: i16, %wo_addr_0: i4, %wo_en_0: i1, %wo_clock_0: i1, %wo_data_0: i16) -> (ro_data_0: i16, rw_rdata_0: i16) attributes {depth = 10 : i64, numReadPorts = 1 : ui32, numReadWritePorts = 1 : ui32, numWritePorts = 1 : ui32, readLatency = 2 : ui32, readUnderWrite = 0 : ui32, width = 16 : ui32, writeClockIDs = [], writeLatency = 4 : ui32, writeUnderWrite = 0 : i32, initFilename = "", initIsBinary = false, initIsInline = false}
 
 //COMMON-LABEL: @FIRRTLMem_1_1_1_16_10_2_4_0_0
 //COM: This produces a lot of output, we check one field's pipeline
@@ -155,24 +155,24 @@ hw.module.generated @FIRRTLMem_1_1_1_16_10_2_4_0_0, @FIRRTLMem(%ro_addr_0: i4, %
 //CHECK-NEXT:    [[ADDR_1R:%.+]] = sv.read_inout [[ADDR_1]] : !hw.inout<i4>
 //CHECK-NEXT:    {{%.+}} = sv.array_index_inout %Memory[[[ADDR_1R]]] : !hw.inout<uarray<10xi16>>, i4
 
-hw.module.generated @FIRRTLMem_1_1_1_16_1_0_1_0_0, @FIRRTLMem(%ro_addr_0: i4, %ro_en_0: i1, %ro_clock_0: i1,%rw_addr_0: i4, %rw_en_0: i1,  %rw_clock_0: i1, %rw_wmode_0: i1, %rw_wdata_0: i16,  %wo_addr_0: i4, %wo_en_0: i1, %wo_clock_0: i1, %wo_data_0: i16) -> (ro_data_0: i16, rw_rdata_0: i16) attributes {depth = 1 : i64, numReadPorts = 1 : ui32, numReadWritePorts = 1 : ui32, numWritePorts = 1 : ui32, readLatency = 0 : ui32, readUnderWrite = 0 : ui32, width = 16 : ui32, writeClockIDs = [], writeLatency = 1 : ui32, writeUnderWrite = 0 : i32}
+hw.module.generated @FIRRTLMem_1_1_1_16_1_0_1_0_0, @FIRRTLMem(%ro_addr_0: i4, %ro_en_0: i1, %ro_clock_0: i1,%rw_addr_0: i4, %rw_en_0: i1,  %rw_clock_0: i1, %rw_wmode_0: i1, %rw_wdata_0: i16,  %wo_addr_0: i4, %wo_en_0: i1, %wo_clock_0: i1, %wo_data_0: i16) -> (ro_data_0: i16, rw_rdata_0: i16) attributes {depth = 1 : i64, numReadPorts = 1 : ui32, numReadWritePorts = 1 : ui32, numWritePorts = 1 : ui32, readLatency = 0 : ui32, readUnderWrite = 0 : ui32, width = 16 : ui32, writeClockIDs = [], writeLatency = 1 : ui32, writeUnderWrite = 0 : i32, initFilename = "", initIsBinary = false, initIsInline = false}
 // COMMON-LABEL: @FIRRTLMem_1_1_1_16_1_0_1_0_0
 // CHECK-NOT: infer_mux_override
 
-hw.module.generated @FIRRTLMemOneAlways, @FIRRTLMem( %wo_addr_0: i4, %wo_en_0: i1, %wo_clock_0: i1,%wo_data_0: i8, %wo_addr_1: i4,  %wo_en_1: i1, %wo_clock_1: i1, %wo_data_1: i8) attributes {depth = 16 : i64, numReadPorts = 0 : ui32, numReadWritePorts = 0 : ui32, numWritePorts = 2 : ui32, readLatency = 1 : ui32, readUnderWrite = 0 : ui32, width = 8 : ui32, writeClockIDs = [0 : i32, 0 : i32], writeLatency = 1 : ui32, writeUnderWrite = 1 : i32}
+hw.module.generated @FIRRTLMemOneAlways, @FIRRTLMem( %wo_addr_0: i4, %wo_en_0: i1, %wo_clock_0: i1,%wo_data_0: i8, %wo_addr_1: i4,  %wo_en_1: i1, %wo_clock_1: i1, %wo_data_1: i8) attributes {depth = 16 : i64, numReadPorts = 0 : ui32, numReadWritePorts = 0 : ui32, numWritePorts = 2 : ui32, readLatency = 1 : ui32, readUnderWrite = 0 : ui32, width = 8 : ui32, writeClockIDs = [0 : i32, 0 : i32], writeLatency = 1 : ui32, writeUnderWrite = 1 : i32, initFilename = "", initIsBinary = false, initIsInline = false}
 
 //COMMON-LABEL: @FIRRTLMemOneAlways
 //CHECK-COUNT-1:  sv.always
 //CHECK-NOT:      sv.always
 
-hw.module.generated @FIRRTLMemTwoAlways, @FIRRTLMem( %wo_addr_0: i4, %wo_en_0: i1, %wo_clock_0: i1,%wo_data_0: i8, %wo_addr_1: i4,  %wo_en_1: i1, %wo_clock_1: i1, %wo_data_1: i8) attributes {depth = 16 : i64, numReadPorts = 0 : ui32, numReadWritePorts = 0 : ui32, numWritePorts = 2 : ui32, readLatency = 1 : ui32, readUnderWrite = 0 : ui32, width = 8 : ui32, writeClockIDs = [0 : i32, 1 : i32], writeLatency = 1 : ui32, writeUnderWrite = 1 : i32}
+hw.module.generated @FIRRTLMemTwoAlways, @FIRRTLMem( %wo_addr_0: i4, %wo_en_0: i1, %wo_clock_0: i1,%wo_data_0: i8, %wo_addr_1: i4,  %wo_en_1: i1, %wo_clock_1: i1, %wo_data_1: i8) attributes {depth = 16 : i64, numReadPorts = 0 : ui32, numReadWritePorts = 0 : ui32, numWritePorts = 2 : ui32, readLatency = 1 : ui32, readUnderWrite = 0 : ui32, width = 8 : ui32, writeClockIDs = [0 : i32, 1 : i32], writeLatency = 1 : ui32, writeUnderWrite = 1 : i32, initFilename = "", initIsBinary = false, initIsInline = false}
 
 //COMMON-LABEL: @FIRRTLMemTwoAlways
 //CHECK-COUNT-2:  sv.always
 //CHECK-NOT:      sv.always
 
 
-  hw.module.generated @FIRRTLMem_1_1_0_32_16_1_1_0_1_a, @FIRRTLMem(%R0_addr: i4, %R0_en: i1, %R0_clk: i1, %W0_addr: i4, %W0_en: i1, %W0_clk: i1, %W0_data: i32, %W0_mask: i4) -> (R0_data: i32) attributes {depth = 16 : i64, maskGran = 8 : ui32, numReadPorts = 1 : ui32, numReadWritePorts = 0 : ui32, numWritePorts = 1 : ui32, readLatency = 1 : ui32, readUnderWrite = 0 : ui32, width = 32 : ui32, writeClockIDs = [0 : i32], writeLatency = 1 : ui32, writeUnderWrite = 1 : i32}
+  hw.module.generated @FIRRTLMem_1_1_0_32_16_1_1_0_1_a, @FIRRTLMem(%R0_addr: i4, %R0_en: i1, %R0_clk: i1, %W0_addr: i4, %W0_en: i1, %W0_clk: i1, %W0_data: i32, %W0_mask: i4) -> (R0_data: i32) attributes {depth = 16 : i64, maskGran = 8 : ui32, numReadPorts = 1 : ui32, numReadWritePorts = 0 : ui32, numWritePorts = 1 : ui32, readLatency = 1 : ui32, readUnderWrite = 0 : ui32, width = 32 : ui32, writeClockIDs = [0 : i32], writeLatency = 1 : ui32, writeUnderWrite = 1 : i32, initFilename = "", initIsBinary = false, initIsInline = false}
   hw.module @memTestFoo(%clock: i1, %rAddr: i4, %rEn: i1, %wAddr: i4, %wEn: i1, %wMask: i4, %wData: i32) -> (rData: i32) attributes {firrtl.moduleHierarchyFile = #hw.output_file<"testharness_hier.json", excludeFromFileList>} {
     %memory.R0_data = hw.instance "memory" @FIRRTLMem_1_1_0_32_16_1_1_0_1_a(R0_addr: %rAddr: i4, R0_en: %rEn: i1, R0_clk: %clock: i1, W0_addr: %wAddr: i4, W0_en: %wEn: i1, W0_clk: %clock: i1, W0_data: %wData: i32, W0_mask: %wMask: i4) -> (R0_data: i32)
     hw.output %memory.R0_data : i32
@@ -201,7 +201,7 @@ hw.module.generated @FIRRTLMemTwoAlways, @FIRRTLMem( %wo_addr_0: i4, %wo_en_0: i
   // CHECK-NEXT:      %[[v220:.+]] = sv.indexed_part_select_inout %[[v26]][%[[c0_i32]] : 8] : !hw.inout<i32>, i32
   // CHECK-NEXT:      sv.passign %[[v220]], %[[v15]] : i8
 
-  hw.module.generated @FIRRTLMem_1_1_0_32_16_1_1_0_1_b, @FIRRTLMem(%R0_addr: i4, %R0_en: i1, %R0_clk: i1, %W0_addr: i4, %W0_en: i1, %W0_clk: i1, %W0_data: i32, %W0_mask: i2) -> (R0_data: i32) attributes {depth = 16 : i64, maskGran = 16 : ui32, numReadPorts = 1 : ui32, numReadWritePorts = 0 : ui32, numWritePorts = 1 : ui32, readLatency = 2 : ui32, readUnderWrite = 0 : ui32, width = 32 : ui32, writeClockIDs = [0 : i32], writeLatency = 3 : ui32, writeUnderWrite = 1 : i32}
+  hw.module.generated @FIRRTLMem_1_1_0_32_16_1_1_0_1_b, @FIRRTLMem(%R0_addr: i4, %R0_en: i1, %R0_clk: i1, %W0_addr: i4, %W0_en: i1, %W0_clk: i1, %W0_data: i32, %W0_mask: i2) -> (R0_data: i32) attributes {depth = 16 : i64, maskGran = 16 : ui32, numReadPorts = 1 : ui32, numReadWritePorts = 0 : ui32, numWritePorts = 1 : ui32, readLatency = 2 : ui32, readUnderWrite = 0 : ui32, width = 32 : ui32, writeClockIDs = [0 : i32], writeLatency = 3 : ui32, writeUnderWrite = 1 : i32, initFilename = "", initIsBinary = false, initIsInline = false}
   hw.module @memTestBar(%clock: i1, %rAddr: i4, %rEn: i1, %wAddr: i4, %wEn: i1, %wMask: i2, %wData: i32) -> (rData: i32) attributes {firrtl.moduleHierarchyFile = #hw.output_file<"testharness_hier.json", excludeFromFileList>} {
     %memory.R0_data = hw.instance "memory" @FIRRTLMem_1_1_0_32_16_1_1_0_1_b(R0_addr: %rAddr: i4, R0_en: %rEn: i1,
     R0_clk: %clock: i1, W0_addr: %wAddr: i4, W0_en: %wEn: i1, W0_clk: %clock: i1, W0_data: %wData: i32, W0_mask: %wMask:  i2) -> (R0_data: i32)
@@ -242,7 +242,7 @@ hw.module.generated @FIRRTLMemTwoAlways, @FIRRTLMem( %wo_addr_0: i4, %wo_en_0: i
 hw.module.generated @FIRRTLMem_1_1_1_16_10_2_4_0_0_multi, @FIRRTLMem(%ro_addr_0: i4, %ro_en_0: i1, %ro_clock_0: i1,%rw_addr_0:
 i4, %rw_en_0: i1,  %rw_clock_0: i1, %rw_wmode_0: i1, %rw_wdata_0: i16,  %rw_wmask_0: i2,  %wo_addr_0: i4, %wo_en_0: i1,
 %wo_clock_0: i1, %wo_data_0: i16, %wo_mask_0: i2) -> (ro_data_0: i16, rw_rdata_0: i16) attributes {depth = 10 : i64,
-numReadPorts = 1 : ui32, numReadWritePorts = 1 : ui32,maskGran = 8 :ui32, numWritePorts = 1 : ui32, readLatency = 2 : ui32, readUnderWrite = 0 : ui32, width = 16 : ui32, writeClockIDs = [], writeLatency = 4 : ui32, writeUnderWrite = 0 : i32}
+numReadPorts = 1 : ui32, numReadWritePorts = 1 : ui32,maskGran = 8 :ui32, numWritePorts = 1 : ui32, readLatency = 2 : ui32, readUnderWrite = 0 : ui32, width = 16 : ui32, writeClockIDs = [], writeLatency = 4 : ui32, writeUnderWrite = 0 : i32, initFilename = "", initIsBinary = false, initIsInline = false}
 
 // COMMON-LABEL:  hw.module @FIRRTLMem_1_1_1_16_10_2_4_0_0_multi
 // CHECK-SAME: %ro_addr_0: i4, %ro_en_0: i1, %ro_clock_0: i1, %rw_addr_0: i4,
@@ -288,15 +288,15 @@ numReadPorts = 1 : ui32, numReadWritePorts = 1 : ui32,maskGran = 8 :ui32, numWri
 
 // COMMON-LABEL: hw.module @PR2769
 // CHECK-NOT: _GEN
-hw.module.generated @PR2769, @FIRRTLMem(%ro_addr_0: i4, %ro_en_0: i1, %ro_clock_0: i1,%rw_addr_0: i4, %rw_en_0: i1,  %rw_clock_0: i1, %rw_wmode_0: i1, %rw_wdata_0: i16,  %wo_addr_0: i4, %wo_en_0: i1, %wo_clock_0: i1, %wo_data_0: i16) -> (ro_data_0: i16, rw_rdata_0: i16) attributes {depth = 10 : i64, numReadPorts = 1 : ui32, numReadWritePorts = 1 : ui32, numWritePorts = 1 : ui32, readLatency = 0 : ui32, readUnderWrite = 0 : ui32, width = 16 : ui32, writeClockIDs = [], writeLatency = 1 : ui32, writeUnderWrite = 0 : i32}
+hw.module.generated @PR2769, @FIRRTLMem(%ro_addr_0: i4, %ro_en_0: i1, %ro_clock_0: i1,%rw_addr_0: i4, %rw_en_0: i1,  %rw_clock_0: i1, %rw_wmode_0: i1, %rw_wdata_0: i16,  %wo_addr_0: i4, %wo_en_0: i1, %wo_clock_0: i1, %wo_data_0: i16) -> (ro_data_0: i16, rw_rdata_0: i16) attributes {depth = 10 : i64, numReadPorts = 1 : ui32, numReadWritePorts = 1 : ui32, numWritePorts = 1 : ui32, readLatency = 0 : ui32, readUnderWrite = 0 : ui32, width = 16 : ui32, writeClockIDs = [], writeLatency = 1 : ui32, writeUnderWrite = 0 : i32, initFilename = "", initIsBinary = false, initIsInline = false}
 
 // COMMON-LABEL: hw.module @RandomizeWeirdWidths
 // CHECK: sv.ifdef.procedural "RANDOMIZE_MEM_INIT"
 // CHECK-NEXT{LITERAL}: sv.verbatim "for (initvar = 0; initvar < 10; initvar = initvar + 1) begin\0A  {{0}} = {{`RANDOM}, {`RANDOM}, {`RANDOM}, {`RANDOM}, {`RANDOM}};\0A  Memory[initvar] = {{0}}[144:0];\0Aend"
-hw.module.generated @RandomizeWeirdWidths, @FIRRTLMem(%ro_addr_0: i4, %ro_en_0: i1, %ro_clock_0: i1,%rw_addr_0: i4, %rw_en_0: i1,  %rw_clock_0: i1, %rw_wmode_0: i1, %rw_wdata_0: i145, %wo_addr_0: i4, %wo_en_0: i1, %wo_clock_0: i1, %wo_data_0: i145) -> (ro_data_0: i145, rw_rdata_0: i145) attributes {depth = 10 : i64, numReadPorts = 1 : ui32, numReadWritePorts = 1 : ui32, numWritePorts = 1 : ui32, readLatency = 2 : ui32, readUnderWrite = 0 : ui32, width = 145 : ui32, writeClockIDs = [], writeLatency = 4 : ui32, writeUnderWrite = 0 : i32}
+hw.module.generated @RandomizeWeirdWidths, @FIRRTLMem(%ro_addr_0: i4, %ro_en_0: i1, %ro_clock_0: i1,%rw_addr_0: i4, %rw_en_0: i1,  %rw_clock_0: i1, %rw_wmode_0: i1, %rw_wdata_0: i145, %wo_addr_0: i4, %wo_en_0: i1, %wo_clock_0: i1, %wo_data_0: i145) -> (ro_data_0: i145, rw_rdata_0: i145) attributes {depth = 10 : i64, numReadPorts = 1 : ui32, numReadWritePorts = 1 : ui32, numWritePorts = 1 : ui32, readLatency = 2 : ui32, readUnderWrite = 0 : ui32, width = 145 : ui32, writeClockIDs = [], writeLatency = 4 : ui32, writeUnderWrite = 0 : i32, initFilename = "", initIsBinary = false, initIsInline = false}
 
 // COMMON-LABEL: hw.module @ReadWriteWithHighReadLatency
-hw.module.generated @ReadWriteWithHighReadLatency, @FIRRTLMem(%rw_addr: i4, %rw_en: i1,  %rw_clock: i1, %rw_wmode: i1, %rw_wdata: i16) -> (rw_rdata: i16) attributes {depth = 16 : i64, numReadPorts = 0 : ui32, numReadWritePorts = 1 : ui32, numWritePorts = 0 : ui32, readLatency = 4 : ui32, readUnderWrite = 0 : ui32, width = 16 : ui32, writeClockIDs = [], writeLatency = 3 : ui32, writeUnderWrite = 0 : i32}
+hw.module.generated @ReadWriteWithHighReadLatency, @FIRRTLMem(%rw_addr: i4, %rw_en: i1,  %rw_clock: i1, %rw_wmode: i1, %rw_wdata: i16) -> (rw_rdata: i16) attributes {depth = 16 : i64, numReadPorts = 0 : ui32, numReadWritePorts = 1 : ui32, numWritePorts = 0 : ui32, readLatency = 4 : ui32, readUnderWrite = 0 : ui32, width = 16 : ui32, writeClockIDs = [], writeLatency = 3 : ui32, writeUnderWrite = 0 : i32, initFilename = "", initIsBinary = false, initIsInline = false}
 // CHECK: [[MEM:%.+]] = sv.reg
 
 // Common pipeline stages (2x)
@@ -345,7 +345,7 @@ hw.module.generated @ReadWriteWithHighReadLatency, @FIRRTLMem(%rw_addr: i4, %rw_
 // CHECK: [[WPTR:%.+]] = sv.array_index_inout [[MEM]][[[ADDR_1R]]]
 
 // COMMON-LABEL: hw.module @ReadWriteWithHighWriteLatency
-hw.module.generated @ReadWriteWithHighWriteLatency, @FIRRTLMem(%rw_addr: i4, %rw_en: i1,  %rw_clock: i1, %rw_wmode: i1, %rw_wdata: i16) -> (rw_rdata: i16) attributes {depth = 16 : i64, numReadPorts = 0 : ui32, numReadWritePorts = 1 : ui32, numWritePorts = 0 : ui32, readLatency = 2 : ui32, readUnderWrite = 0 : ui32, width = 16 : ui32, writeClockIDs = [], writeLatency = 5 : ui32, writeUnderWrite = 0 : i32}
+hw.module.generated @ReadWriteWithHighWriteLatency, @FIRRTLMem(%rw_addr: i4, %rw_en: i1,  %rw_clock: i1, %rw_wmode: i1, %rw_wdata: i16) -> (rw_rdata: i16) attributes {depth = 16 : i64, numReadPorts = 0 : ui32, numReadWritePorts = 1 : ui32, numWritePorts = 0 : ui32, readLatency = 2 : ui32, readUnderWrite = 0 : ui32, width = 16 : ui32, writeClockIDs = [], writeLatency = 5 : ui32, writeUnderWrite = 0 : i32, initFilename = "", initIsBinary = false, initIsInline = false}
 // CHECK: [[MEM:%.+]] = sv.reg
 
 // Common pipeline stages (2x)
diff --git a/test/Transforms/strip-debuginfo-pred.mlir b/test/Transforms/strip-debuginfo-pred.mlir
index ddb51c9bc..dc441e3c5 100644
--- a/test/Transforms/strip-debuginfo-pred.mlir
+++ b/test/Transforms/strip-debuginfo-pred.mlir
@@ -11,3 +11,11 @@ func.func @inline_notation() {
   } loc(fused["foo", "foo.txt":10:8]) 
   return
 }
+
+// CHECK: hw.module @MyModule(%a: i1 loc(unknown)) -> (b: i1 loc(unknown))
+hw.module @MyModule(%a : i1 loc("a.txt":0:0)) -> (b : i1 loc ("b.txt":0:0)) {
+  hw.output %a : i1
+}
+
+// CHECK: hw.module.extern @MyExtModule(%a: i1 loc(unknown)) -> (b: i1 loc(unknown))
+hw.module.extern @MyExtModule(%a : i1 loc("a.txt":0:0)) -> (b : i1 loc ("b.txt":0:0))
diff --git a/test/circt-as-dis/basic-firrtl.mlir b/test/circt-as-dis/basic-firrtl.mlir
index 7a52b1821..33d45f889 100644
--- a/test/circt-as-dis/basic-firrtl.mlir
+++ b/test/circt-as-dis/basic-firrtl.mlir
@@ -1,6 +1,6 @@
-// RUN: circt-as %s -o - | circt-opt | FileCheck %s
-// RUN: circt-opt %s -emit-bytecode | circt-dis | FileCheck %s
-// RUN: circt-as %s -o - | circt-dis | FileCheck %s
+// RUN: circt-as %s -o - | circt-opt | FileCheck -strict-whitespace %s
+// RUN: circt-opt %s -emit-bytecode | circt-dis | FileCheck -strict-whitespace  %s
+// RUN: circt-as %s -o - | circt-dis | FileCheck -strict-whitespace  %s
 
 firrtl.circuit "Top" {
   firrtl.module @Top(in %in : !firrtl.uint<8>,
@@ -9,6 +9,8 @@ firrtl.circuit "Top" {
   }
 }
 
-// CHECK-LABEL: firrtl.module @Top(in %in: !firrtl.uint<8>, out %out: !firrtl.uint<8>) {
-// CHECK-NEXT:    firrtl.strictconnect %out, %in : !firrtl.uint<8>
+// CHECK-LABEL: firrtl.circuit "Top" {
+// CHECK-NEXT:    firrtl.module @Top(in %in: !firrtl.uint<8>, out %out: !firrtl.uint<8>) {
+// CHECK-NEXT:      firrtl.strictconnect %out, %in : !firrtl.uint<8>
+// CHECK-NEXT:    }
 // CHECK-NEXT:  }
diff --git a/test/firtool/firtool.fir b/test/firtool/firtool.fir
index d656b5268..f4e6478a2 100644
--- a/test/firtool/firtool.fir
+++ b/test/firtool/firtool.fir
@@ -136,7 +136,8 @@ circuit test_mod : %[[{"class": "circt.testNT", "data": "a"}]]
 ; VERILOG-NEXT:    output       c,
 ; VERILOG-NEXT:                 out_implicitTrunc,
 ; VERILOG-NEXT:                 out_prettifyExample,
-; VERILOG-NEXT:                 out_multibitMux);
+; VERILOG-NEXT:                 out_multibitMux
+; VERILOG-NEXT:    );
 ; VERILOG-EMPTY:
 ; VERILOG-NEXT:    wire [9:0] _prettifyExample_out1;
 ; VERILOG-NEXT:    wire [9:0] _prettifyExample_out2;
@@ -216,7 +217,8 @@ circuit test_mod : %[[{"class": "circt.testNT", "data": "a"}]]
 ; VERILOG-NEXT:   input        inp_1,
 ; VERILOG-NEXT:   input  [4:0] inp_2,
 ; VERILOG-NEXT:   output [2:0] out1,
-; VERILOG-NEXT:                out2);
+; VERILOG-NEXT:                out2
+; VERILOG-NEXT:   );
 ; VERILOG-EMPTY:
 ; VERILOG-NEXT:   wire [5:0] _GEN = {inp_2[4], inp_2} << inp_1;
 ; VERILOG-NEXT:   assign out1 = _GEN[2:0];
@@ -253,9 +255,10 @@ circuit test_mod : %[[{"class": "circt.testNT", "data": "a"}]]
     a_q <= r
 
 ; VERILOG-LABEL: module FlipFlop(
-; VERILOG-NEXT:    input clock,
-; VERILOG-NEXT:          a_d,
-; VERILOG-NEXT:    output a_q);
+; VERILOG-NEXT:    input  clock,
+; VERILOG-NEXT:           a_d,
+; VERILOG-NEXT:    output a_q
+; VERILOG-NEXT:  );
 ; VERILOG:         always @(posedge clock)
 ; VERILOG-NEXT:      r <= a_d;
 ; VERILOG:         assign a_q = r;
diff --git a/test/firtool/print-before.fir b/test/firtool/print-before.fir
index cd630fbbe..bca270456 100644
--- a/test/firtool/print-before.fir
+++ b/test/firtool/print-before.fir
@@ -1,7 +1,6 @@
 ; Ensure firtool can dump MLIR from various points of the pipeline.
 ; Check passes from different components and registration categories.
 ; RUN: firtool %s -mlir-print-ir-before=cse 2>&1 | FileCheck %s -Dpass=CSE
-; RUN: firtool %s -mlir-print-ir-before=strip-debuginfo -strip-debug-info 2>&1 | FileCheck %s -Dpass=StripDebugInfo
 ; RUN: firtool %s -mlir-print-ir-before=firrtl-inliner 2>&1 | FileCheck %s -Dpass=Inliner
 ; RUN: firtool %s -mlir-print-ir-before=firrtl-lower-annotations 2>&1 | FileCheck %s -Dpass=LowerFIRRTLAnnotations
 ; RUN: firtool %s -mlir-print-ir-before=firrtl-grand-central 2>&1 | FileCheck %s -Dpass=GrandCentral
diff --git a/tools/esi/esi-cosim-runner.py.in b/tools/esi/esi-cosim-runner.py.in
index bd2a90fbb..9155a752d 100755
--- a/tools/esi/esi-cosim-runner.py.in
+++ b/tools/esi/esi-cosim-runner.py.in
@@ -29,13 +29,15 @@ class CosimTestRunner:
     class to allow for per-test mutable state variables."""
 
   def __init__(self, testFile, schema, tmpdir, addlArgs, interactive: bool,
-               include_aux_files: bool):
+               include_aux_files: bool, exec: bool, exec_args: str):
     """Parse a test file. Look for comments we recognize anywhere in the
         file. Assemble a list of sources."""
 
     self.args = addlArgs
     self.file = testFile
     self.interactive = interactive
+    self.exec = exec
+    self.exec_args = exec_args
     self.runs = list()
     self.srcdir = os.path.dirname(self.file)
     self.sources = list()
@@ -53,30 +55,16 @@ class CosimTestRunner:
                             "ESI", "CosimDpi.capnp")
     self.schema = schema
 
-    fileReader = open(self.file, "r")
-    sources = []
-    for line in fileReader:
-      # Arguments to circt-rtl-sim, except for source files list
-      m = re.match(r"^(//|#)\s*ARGS:(.*)$", line)
-      if m:
-        self.args.extend(m.group(2).split())
-      # SOURCES are the additional source files (if any). If specified,
-      # must include the current file. These files are either absolute or
-      # relative to the current file.
-      m = re.match(r"^(//|#)\s*SOURCES:(.*)$", line)
-      if m:
-        sources.extend(m.group(2).split())
-      # Run this Python line.
-      m = re.match(r"^(//|#)\s*PY:(.*)$", line)
-      if m:
-        self.runs.append(m.group(2).strip())
-    fileReader.close()
-
-    self.sources = [
-        (src if os.path.isabs(src) else os.path.join(self.srcdir, src))
-        for src in self.sources
-    ]
+    if not self.exec:
+      fileReader = open(self.file, "r")
+      for line in fileReader:
+        # Run this Python line.
+        m = re.match(r"^(//|#)\s*PY:(.*)$", line)
+        if m:
+          self.runs.append(m.group(2).strip())
+      fileReader.close()
 
+    self.sources = []
     # Include the cosim DPI SystemVerilog files.
     if include_aux_files:
       esiInclude = os.path.join("@CIRCT_BINARY_DIR@", "include", "circt",
@@ -96,7 +84,6 @@ class CosimTestRunner:
         + self.sources + self.args
     print("[INFO] Compile command: " + " ".join(cmd))
     vrun = subprocess.run(cmd, capture_output=True, text=True)
-    # cwd=self.execdir)
     output = vrun.stdout + "\n----- STDERR ------\n" + vrun.stderr
     if vrun.returncode != 0:
       print("====== Compilation failure:")
@@ -205,14 +192,24 @@ class CosimTestRunner:
         time.sleep(0.05)
 
       # Write the test script.
-      self.writeScript(port)
+      if not self.exec:
+        self.writeScript(port)
 
       # Pycapnp complains if the PWD environment var doesn't match the
       # actual CWD.
       testEnv = os.environ.copy()
       testEnv["PWD"] = os.getcwd()
+      testEnv["PYTHONPATH"] = testEnv[
+          "PYTHONPATH"] + f":{os.path.dirname(__file__)}"
       # Run the test script.
-      cmd = [sys.executable, "-u", "script.py"]
+      if self.exec:
+        args = [str(port), self.schema] + self.exec_args.split(" ")
+        if self.file.endswith(".py"):
+          cmd = [sys.executable, "-u", self.file] + args
+        else:
+          cmd = [self.file] + args
+      else:
+        cmd = [sys.executable, "-u", "script.py"]
       print("[INFO] Test run command: " + " ".join(cmd))
       testProc = subprocess.run(cmd,
                                 stdout=testStdout,
@@ -300,6 +297,14 @@ def __main__(args):
   argparser.add_argument("--no-aux-files",
                          action="store_true",
                          help="Don't include the ESI cosim auxiliary files.")
+  argparser.add_argument(
+      "--exec",
+      action="store_true",
+      help="Instead of inline python, run an executable or python "
+      "script with the sim port and schema path as the first two arguments.")
+  argparser.add_argument("--test-args",
+                         default="",
+                         help="Extra args to pass to the test.")
   argparser.add_argument("source", help="The source run spec file")
   argparser.add_argument("addlArgs",
                          nargs=argparse.REMAINDER,
@@ -319,7 +324,8 @@ def __main__(args):
   os.chdir(testDir)
 
   runner = CosimTestRunner(args.source, args.schema, args.tmpdir, args.addlArgs,
-                           args.interactive, not args.no_aux_files)
+                           args.interactive, not args.no_aux_files, args.exec,
+                           args.test_args)
   rc = runner.compile()
   if rc != 0:
     return rc
diff --git a/tools/firtool/firtool.cpp b/tools/firtool/firtool.cpp
index bc8053bc3..580a4bfcc 100644
--- a/tools/firtool/firtool.cpp
+++ b/tools/firtool/firtool.cpp
@@ -905,7 +905,8 @@ static LogicalResult processBuffer(
           }));
 
     if (stripDebugInfo)
-      exportPm.addPass(mlir::createStripDebugInfoPass());
+      exportPm.addPass(circt::createStripDebugInfoWithPredPass(
+          [](mlir::Location loc) { return true; }));
 
     // Emit a single file or multiple files depending on the output format.
     switch (outputFormat) {
